{"meta":{"title":"Jeff","subtitle":"Jeffの记事本","description":"本科 | 计算机科学与技术","author":"Jeff","url":"https://robertjeff2.github.io","root":"/"},"pages":[{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.445Z","comments":true,"path":"about/index.html","permalink":"https://robertjeff2.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.446Z","comments":true,"path":"categories/index.html","permalink":"https://robertjeff2.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.451Z","comments":true,"path":"tags/index.html","permalink":"https://robertjeff2.github.io/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"friends/index.html","permalink":"https://robertjeff2.github.io/friends/index.html","excerpt":"","text":""},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.326Z","comments":true,"path":"404.html","permalink":"https://robertjeff2.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-07-22T07:08:22.446Z","updated":"2021-07-22T07:08:22.446Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://robertjeff2.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-07-22T07:08:22.448Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://robertjeff2.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.339Z","comments":true,"path":"List/index.html","permalink":"https://robertjeff2.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.445Z","comments":true,"path":"archives/index.html","permalink":"https://robertjeff2.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-07-22T07:08:22.447Z","comments":true,"path":"census/index.html","permalink":"https://robertjeff2.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-10-16T07:24:47.502Z","comments":true,"path":"contact/index.html","permalink":"https://robertjeff2.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"resource/index.html","permalink":"https://robertjeff2.github.io/resource/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.340Z","comments":true,"path":"List/music/index.html","permalink":"https://robertjeff2.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-07-22T07:08:22.332Z","updated":"2021-07-22T07:08:22.332Z","comments":true,"path":"List/galleries/index.html","permalink":"https://robertjeff2.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.339Z","comments":true,"path":"List/movies/index.html","permalink":"https://robertjeff2.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-07-22T07:08:22.332Z","updated":"2021-07-22T07:08:22.332Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.340Z","comments":true,"path":"List/tools/index.html","permalink":"https://robertjeff2.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-07-22T07:08:22.333Z","updated":"2021-07-22T07:08:22.333Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-07-22T07:08:22.333Z","updated":"2021-07-22T07:08:22.333Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-07-22T07:08:22.334Z","updated":"2021-07-22T07:08:22.334Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-07-22T07:08:22.334Z","updated":"2021-07-22T07:08:22.334Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-07-22T07:08:22.335Z","updated":"2021-07-22T07:08:22.335Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-07-22T07:08:22.336Z","updated":"2021-07-22T07:08:22.336Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-07-22T07:08:22.336Z","updated":"2021-07-22T07:08:22.336Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-07-22T07:08:22.337Z","updated":"2021-07-22T07:08:22.337Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-07-22T07:08:22.337Z","updated":"2021-07-22T07:08:22.337Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-07-22T07:08:22.338Z","updated":"2021-07-22T07:08:22.338Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-07-22T07:08:22.338Z","updated":"2021-07-22T07:08:22.338Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript中的this","slug":"JavaScript中的this","date":"2021-10-18T12:51:42.000Z","updated":"2021-10-18T15:18:24.784Z","comments":true,"path":"posts/a5ceba90.html","link":"","permalink":"https://robertjeff2.github.io/posts/a5ceba90.html","excerpt":"","text":"问：如何判断this的指向？ 在全局环境中调用就指向 window。 作为对象的方法调用就指向该对象。 作为构造函数调用就指向这个新创建的对象。 可以使用 apply,call,bind 改变 this 指向。 箭头函数中的 this 与定义时所处的上下文绑定，且不能被改变， 箭头函数 this 指向取决于它外层找到的离它最近的第一个非箭头函数的 this。 一、定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别 无论是否在严格模式下，在全局执行环境中(任何函数体外部)this都指向全局对象 在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定） this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象 example： function baz() { // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar的调用位置 } function bar() { // 当前调用栈是：baz --&gt; bar // 因此，当前调用位置在baz中 console.log( \"bar\" ); foo(); // &lt;-- foo的调用位置 } function foo() { // 当前调用栈是：baz --&gt; bar --&gt; foo // 因此，当前调用位置在bar中 console.log( \"foo\" ); } baz(); // &lt;-- baz的调用位置 this 在函数执行过程中，this 一旦被确定了，就不可以再更改 var a = 10; var obj = { a: 20 } function fn() { this = obj; // 修改this，运行后会报错 console.log(this.a); } fn(); this在类中this在类中的表现与在函数中类似，因为类本质上也是函数。 在类的构造函数中，this 是一个常规对象。类中所有非静态的方法都会被添加到 this 的原型中： class Example { constructor() { const proto = Object.getPrototypeOf(this); console.log(Object.getOwnPropertyNames(proto)); } first(){} second(){} static third(){} } new Example(); // ['constructor', 'first', 'second'] 二、具体情况分析apply、call方法在非严格模式下使用call和apply时，如果用做this值不是对象，则会被尝试转换为对象。 null和 undefined会被转换为全局对象 function bar() { console.log(Object.prototype.toString.call(this)); } bar.call(7); // [object Number] bar.call('foo'); // [object String] bar.call(undefined); // [object global] bind方法ECMAScript 5 引入了 Function.prototype.bind()。调用 f.bind(someObject) 会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。 function f(){ return this.a; } var g = f.bind({a:\"azerty\"}); console.log(g()); // azerty var h = g.bind({a:'yoo'}); // bind只生效一次！ console.log(h()); // azerty var o = {a:37, f:f, g:g, h:h}; console.log(o.a, o.f(), o.g(), o.h()); // 37, 37, azerty, azerty 箭头函数在箭头函数中，this 与封闭词法环境的 this 保持一致。在全局代码中，它将被设置为全局对象： 注意：如果将 this 传递给 call、bind、或者 apply 来调用箭头函数，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为 null。 // 创建一个含有bar方法的obj对象， // bar返回一个函数， // 这个函数返回this， // 这个返回的函数是以箭头函数创建的， // 所以它的this被永久绑定到了它外层函数的this。 // bar的值可以在调用中设置，这反过来又设置了返回函数的值。 var obj = { bar: function() { var x = (() =&gt; this); return x; } }; // 作为obj对象的一个方法来调用bar，把它的this绑定到obj。 // 将返回的函数的引用赋值给fn。 var fn = obj.bar(); // 直接调用fn而不设置this， // 通常(即不使用箭头函数的情况)默认为全局对象 // 若在严格模式则为undefined console.log(fn() === obj); // true // 但是注意，如果你只是引用obj的方法， // 而没有调用它 var fn2 = obj.bar; // 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。 console.log(fn2()() == window); // true 在上面的例子中，一个赋值给了 obj.bar 的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 A 调用时，函数 B 的 this 被永久设置为 obj.bar（函数 A）的 this。当返回的函数（函数 B）被调用时，它 this 始终是最初设置的。在上面的代码示例中，函数 B 的 this 被设置为函数 A 的 this，即 obj，所以即使被调用的方式通常将其设置为 undefined 或全局对象（或者如前面示例中的其他全局执行环境中的方法），它的 this 也仍然是 obj 。 作为对象的方法当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象。 下面的例子中，当 o.f() 被调用时，函数内的 this 将绑定到 o 对象。 var o = { prop: 37, f: function() { return this.prop; } }; console.log(o.f()); // 37 //可以理解为 o.f().call(o) 原型链中的this对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样。 var o = { f: function() { return this.a + this.b; } }; var p = Object.create(o); p.a = 1; p.b = 4; console.log(p.f()); // 5 在这个例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。虽然最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p。也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p。这是 JavaScript 的原型继承中的一个有趣的特性。 构造函数中当一个函数用作构造函数时（使用 new关键字），它的 this 被绑定到正在构造的新对象。 虽然构造函数返回的默认值是 this 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 this 对象）。 /* * 构造函数这样工作: * * function MyConstructor(){ * // 函数实体写在这里 * // 根据需要在this上创建属性，然后赋值给它们，比如： * this.fum = \"nom\"; * // 等等... * * // 如果函数具有返回对象的return语句， * // 则该对象将是 new 表达式的结果。 * // 否则，表达式的结果是当前绑定到 this 的对象。 * //（即通常看到的常见情况）。 * } */ function C(){ this.a = 37; } var o = new C(); console.log(o.a); // logs 37 function C2(){ this.a = 37; return {a:38}; } o = new C2(); console.log(o.a); // logs 38 在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与 this 绑定的默认对象被丢弃了。（这基本上使得语句 “this.a = 37;” 成了 “僵尸” 代码，实际上并不是真正的 “僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。 DOM事件处理函数当函数被用作事件处理函数时，它的 this 指向触发事件的元素（一些浏览器在使用非 addEventListener 的函数动态地添加监听函数时不遵守这个约定）。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://robertjeff2.github.io/tags/JS/"}]},{"title":"elementplus踩坑","slug":"elementplus踩坑","date":"2021-09-20T07:29:24.000Z","updated":"2021-10-18T12:52:24.936Z","comments":true,"path":"posts/753e8c51.html","link":"","permalink":"https://robertjeff2.github.io/posts/753e8c51.html","excerpt":"","text":"坑一：elememt-plus 版本问题在引入element-plus插件时的坑 视频版本是1.0.2beta64 此时通过npm安装的最新版本为1.1.0beta12 然而组件库在1.1.0版本做了一次breaking changes 修改了引入的方式 通过查阅文档后修复 Breaking changes made in 1.1.0-beta.1 · Discussion #3020 · element-plus/element-plus (github.com) 坑二 还是element-plus问题没安装之前一切正常 安装好element-plus后 npm run serve 直接报错 vue项目引入ElementUI-plus运行npm run serve后出现报错，网页内容无法显示： “export ‘createElementBlock‘ (imported as ‘_createElementBlock‘) was not found in ‘vue‘ 进度98% 大概跟导包方式有关系 解决方案：升级vue版本 升级vue 到最新版本 执行 npm install vue@3.2.4 –force 升级后报错消失 网页正常显示 这个element-plus 更新太快了 让我看一个月前的课程看起来像是一年前的一样hhhh","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://robertjeff2.github.io/tags/vue3/"}]}],"categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://robertjeff2.github.io/tags/JS/"},{"name":"vue3","slug":"vue3","permalink":"https://robertjeff2.github.io/tags/vue3/"}]}