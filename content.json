{"meta":{"title":"Jeff","subtitle":"Jeffの记事本","description":"本科 | 计算机科学与技术","author":"Jeff","url":"https://robertjeff2.github.io","root":"/"},"pages":[{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.445Z","comments":true,"path":"about/index.html","permalink":"https://robertjeff2.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.446Z","comments":true,"path":"categories/index.html","permalink":"https://robertjeff2.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.451Z","comments":true,"path":"tags/index.html","permalink":"https://robertjeff2.github.io/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"friends/index.html","permalink":"https://robertjeff2.github.io/friends/index.html","excerpt":"","text":""},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.326Z","comments":true,"path":"404.html","permalink":"https://robertjeff2.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-07-22T07:08:22.446Z","updated":"2021-07-22T07:08:22.446Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://robertjeff2.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-07-22T07:08:22.448Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://robertjeff2.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.339Z","comments":true,"path":"List/index.html","permalink":"https://robertjeff2.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.445Z","comments":true,"path":"archives/index.html","permalink":"https://robertjeff2.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-07-22T07:08:22.447Z","comments":true,"path":"census/index.html","permalink":"https://robertjeff2.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-10-16T07:24:47.502Z","comments":true,"path":"contact/index.html","permalink":"https://robertjeff2.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"resource/index.html","permalink":"https://robertjeff2.github.io/resource/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.340Z","comments":true,"path":"List/music/index.html","permalink":"https://robertjeff2.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-07-22T07:08:22.332Z","updated":"2021-07-22T07:08:22.332Z","comments":true,"path":"List/galleries/index.html","permalink":"https://robertjeff2.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.339Z","comments":true,"path":"List/movies/index.html","permalink":"https://robertjeff2.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-07-22T07:08:22.332Z","updated":"2021-07-22T07:08:22.332Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.340Z","comments":true,"path":"List/tools/index.html","permalink":"https://robertjeff2.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-07-22T07:08:22.333Z","updated":"2021-07-22T07:08:22.333Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-07-22T07:08:22.333Z","updated":"2021-07-22T07:08:22.333Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-07-22T07:08:22.334Z","updated":"2021-07-22T07:08:22.334Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-07-22T07:08:22.334Z","updated":"2021-07-22T07:08:22.334Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-07-22T07:08:22.335Z","updated":"2021-07-22T07:08:22.335Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-07-22T07:08:22.336Z","updated":"2021-07-22T07:08:22.336Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-07-22T07:08:22.336Z","updated":"2021-07-22T07:08:22.336Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-07-22T07:08:22.337Z","updated":"2021-07-22T07:08:22.337Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-07-22T07:08:22.337Z","updated":"2021-07-22T07:08:22.337Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-07-22T07:08:22.338Z","updated":"2021-07-22T07:08:22.338Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-07-22T07:08:22.338Z","updated":"2021-07-22T07:08:22.338Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS之两栏三栏布局","slug":"CSS之两栏三栏布局","date":"2021-10-20T09:39:30.000Z","updated":"2021-10-20T11:24:59.966Z","comments":true,"path":"posts/bfdfcbd4.html","link":"","permalink":"https://robertjeff2.github.io/posts/bfdfcbd4.html","excerpt":"","text":"两栏、三栏布局一、概念两栏布局两栏布局实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满， 比如 Ant Design 文档，蓝色区域为主要内容布局容器，侧边栏为次要内容布局容器 这里称宽度较小的列父元素为次要布局容器，宽度较大的列父元素为主要布局容器 这种布局适用于内容上具有明显主次关系的网页 三栏布局三栏布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之 最常见的就是github： 二、两栏布局双栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在 实现思路也非常的简单： 浮动实现 使用 float 左浮左边栏 右边模块使用 margin-left 撑出内容块做内容展示 为父级元素添加BFC，防止下方元素飞到上方内容 &lt;style&gt; .box{ overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt; } .left { float: left; width: 200px; background-color: gray; height: 400px; } .right { margin-left: 210px; background-color: lightgray; height: 200px; } &lt;/style&gt; &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;左边&lt;/div&gt; &lt;div class=\"right\"&gt;右边&lt;/div&gt; &lt;/div&gt; flex弹性布局&lt;style&gt; .box{ display: flex; } .left { width: 100px; } .right { flex: 1; } &lt;/style&gt; &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;左边&lt;/div&gt; &lt;div class=\"right\"&gt;右边&lt;/div&gt; &lt;/div&gt; flex可以说是最好的方案了，代码少，使用简单 注意的是，flex容器的一个默认属性值:align-items: stretch; 这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start 三、三栏布局实现三栏布局中间自适应的布局方式有： 两边使用 float，中间使用 margin 两边使用 absolute，中间使用 margin display: table 实 flex实现 grid网格布局 两边使用 float，中间使用 margin需要将中间的内容放在html结构最后，否则右侧会臣在中间内容的下方 实现代码如下： &lt;style&gt; .wrap { background: #eee; overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt; padding: 20px; height: 200px; } .left { width: 200px; height: 200px; float: left; background: coral; } .right { width: 120px; height: 200px; float: right; background: lightblue; } .middle { margin-left: 220px; height: 200px; background: lightpink; margin-right: 140px; } &lt;/style&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;左侧&lt;/div&gt; &lt;div class=\"right\"&gt;右侧&lt;/div&gt; &lt;div class=\"middle\"&gt;中间&lt;/div&gt; &lt;/div&gt; 原理如下： 两边固定宽度，中间宽度自适应。 利用中间元素的margin值控制两边的间距 宽度小于左右部分宽度之和时，右侧部分会被挤下去 这种实现方式存在缺陷： 主体内容是最后加载的。 右边在主体内容之前，如果是响应式设计，不能简单的换行展示 两边使用 absolute，中间使用 margin基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序 &lt;style&gt; .container { position: relative; } .left, .right, .main { height: 200px; line-height: 200px; text-align: center; } .left { position: absolute; top: 0; left: 0; width: 100px; background: green; } .right { position: absolute; top: 0; right: 0; width: 100px; background: green; } .main { margin: 0 110px; background: black; color: white; } &lt;/style&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;左边固定宽度&lt;/div&gt; &lt;div class=\"right\"&gt;右边固定宽度&lt;/div&gt; &lt;div class=\"main\"&gt;中间自适应&lt;/div&gt; &lt;/div&gt; 实现流程： 左右两边使用绝对定位，固定在两侧。 中间占满一行，但通过 margin和左右两边留出10px的间隔 使用 display: table 实现&lt;style&gt; .container { height: 200px; line-height: 200px; text-align: center; display: table; table-layout: fixed; width: 100%; } .left, .right, .main { display: table-cell; } .left, .right { width: 100px; background: green; } .main { background: black; color: white; width: 100%; } &lt;/style&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;左边固定宽度&lt;/div&gt; &lt;div class=\"main\"&gt;中间自适应&lt;/div&gt; &lt;div class=\"right\"&gt;右边固定宽度&lt;/div&gt; &lt;/div&gt;实现原理： 外层通过 display: table设置为表格，设置 table-layout: fixed表示列宽自身宽度决定，而不是自动计算。 内层的左中右通过 display: table-cell设置为表格单元。 左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度 使用flex实现&lt;style type=\"text/css\"&gt; .wrap { display: flex; justify-content: space-between;&lt;--定义了子元素在主轴(横轴)上的对齐方式 } .left, .right, .middle { height: 100px; } .left { width: 200px; background: coral; } .right { width: 120px; background: lightblue; } .middle { background: #555; width: 100%; margin: 0 20px; } &lt;/style&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;左侧&lt;/div&gt; &lt;div class=\"middle\"&gt;中间&lt;/div&gt; &lt;div class=\"right\"&gt;右侧&lt;/div&gt; &lt;/div&gt;实现过程： 仅需将容器设置为display:flex;， 盒内元素两端对其，将中间元素设置为100%宽度，或者设为flex:1，即可填充空白 盒内元素的高度撑开容器的高度 优点： 结构简单直观 可以结合 flex的其他功能实现更多效果，例如使用 order属性调整显示顺序，让主体内容优先加载，但展示在中间 grid网格布局&lt;style&gt; .wrap { display: grid; width: 100%; grid-template-columns: 300px auto 300px; } .left, .right, .middle { height: 100px; } .left { background: coral; } .right { width: 300px; background: lightblue; } .middle { background: #555; } &lt;/style&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;左侧&lt;/div&gt; &lt;div class=\"middle\"&gt;中间&lt;/div&gt; &lt;div class=\"right\"&gt;右侧&lt;/div&gt; &lt;/div&gt; 标签用于展示行列数据，不适合用于布局。但是可以使用 display: table 来实现布局的效果","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://robertjeff2.github.io/tags/CSS/"}]},{"title":"CSS之盒子模型与BFC","slug":"CSS之盒子模型","date":"2021-10-20T09:13:21.000Z","updated":"2021-10-20T11:27:04.161Z","comments":true,"path":"posts/404ade06.html","link":"","permalink":"https://robertjeff2.github.io/posts/404ade06.html","excerpt":"","text":"盒子模型一、盒子模型是什么？就是用来装页面上的元素的矩形区域。CSS 中的盒子模型包括IE 盒子模型和标准的W3C 盒子模型。 box-sizing(有3 个值哦)：border-box,padding-box,content-box. 一个盒子由四个部分组成：content、padding、border、margin content，即实际内容，显示文本和图像 boreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成 padding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响 margin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域 二、IE盒子模型（怪异盒子模型） 从上图可以看到： 盒子总宽度 = width + margin; 盒子总高度 = height + margin; 也就是，width/height 包含了 padding和 border值 三、标准盒子模型（W3C）标准盒子模型，是浏览器默认的盒子模型 下面看看标准盒子模型的模型图： 从上图可以看到： 盒子总宽度 = width + padding + border + margin; 盒子总高度 = height + padding + border + margin 也就是，width/height 只是内容高度，不包含 padding 和 border值 浏览器默认为w3c标准模型 四、Box-sizingCSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度. 语法： box-sizing: content-box|border-box|inherit: content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致 border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致 inherit 指定 box-sizing 属性的值，应该从父元素继承 五、区别：从图中我们可以看出，这两种盒子模型最主要的区别就是width 的包含范围，在 标准的盒子模型中，width 指content 部分的宽度，在IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差 异：标准盒子模型的盒子宽度：左右border+左右padding+width IE 盒子模型的盒子宽度：width 在CSS3 中引入了box-sizing 属性，box-sizing:content-box; 表示的是w3c 标准盒子模型， box-sizing:border-box表示IE的盒子模型 最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右 padding+width。 六、盒模型的边距重叠主要分三种重叠， 重叠规则：一大一小取最大,一正一负取和 相邻元素之间的重叠 父子嵌套的重叠 空的块级元素 1.相邻元素之间 // css * { margin:0; padding:0; border:0; } #d1 { width:100px; height:100px; margin-top:20px; margin-bottom:20px; background-color:red; } #d2 { width:100px; height:100px; margin-top:10px; background-color:blue; } // html &lt;div id=\"d1\"&gt; &lt;/div&gt; &lt;div id=\"d2\"&gt; &lt;/div&gt; 2.父子嵌套重叠 // css * { margin:0; padding:0; border:0; } #outer { width:300px; height:300px; background-color:red; margin-top:20px; } #inner { width:50px; height:50px; background-color:blue; margin-top:10px; } // html &lt;div id=\"outer\"&gt; &lt;div id=\"inner\"&gt; &lt;/div&gt; &lt;/div&gt; 3.空的块级元素 BFC一、概念什么是BFC 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 渲染规则： 内部的盒子会在垂直方向上一个接一个的放置 对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此 BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 BFC目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素 二、触发条件触发BFC的条件包含不限于： 根元素，即HTML元素 浮动元素：float值为left、right overflow值不为 visible，为 auto、scroll、hidden display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid position的值为absolute或fixed 三、应用场景防止margin重叠（塌陷）&lt;style&gt; p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; } &lt;/style&gt; &lt;body&gt; &lt;p&gt;Haha&lt;/p &gt; &lt;p&gt;Hehe&lt;/p &gt; &lt;/body&gt; 页面显示如下 两个p元素之间的距离为100px，发生了margin重叠（塌陷），以最大的为准，如果第一个P的margin为80的话，两个P之间的距离还是100，以最大的为准。 前面讲到，同一个BFC的俩个相邻的盒子的margin会发生重叠 可以在p外面包裹一层容器，并触发这个容器生成一个BFC，那么两个p就不属于同一个BFC，则不会出现margin重叠 &lt;style&gt; .wrap { overflow: hidden;// 新的BFC } p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; } &lt;/style&gt; &lt;body&gt; &lt;p&gt;Haha&lt;/p &gt; &lt;div class=\"wrap\"&gt; &lt;p&gt;Hehe&lt;/p &gt; &lt;/div&gt; &lt;/body&gt; 此时，margin便不会发生重叠： 清除内部浮动例子代码如下： &lt;style&gt; .par { border: 5px solid #fcc; width: 300px; } .child { border: 5px solid #f66; width:100px; height: 100px; float: left; } &lt;/style&gt; &lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 页面显示如图： 而BFC在计算高度时，浮动元素也会参与，所以我们可以触发.par元素产生BFC，则内部浮动元素计算高度时候也会计算 .par { overflow: hidden; } 最终实现了清除浮动的效果： 自适应多栏布局例子代码： &lt;style&gt; body { width: 300px; position: relative; } .aside { width: 100px; height: 150px; float: left; background: #f66; } .main { height: 200px; background: #fcc; } &lt;/style&gt; &lt;body&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/body&gt; 页面显示如图所示： 前面讲到，每个元素的左外边距与包含块的左边界相接触 因此，虽然.aslide为浮动元素，但是main的左边依然会与包含块的左边相接触 而BFC的区域不会与浮动盒子重叠 所以我们可以通过触发main生成BFC，以此适应两栏布局 .main { overflow: hidden; } 这时候，新的BFC不会与浮动的.aside元素重叠。因此会根据包含块的宽度，和.aside的宽度，自动变窄 效果如下：","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://robertjeff2.github.io/tags/CSS/"}]},{"title":"JavaScript中的this","slug":"JavaScript中的this","date":"2021-10-18T12:51:42.000Z","updated":"2021-10-18T15:18:37.313Z","comments":true,"path":"posts/a5ceba90.html","link":"","permalink":"https://robertjeff2.github.io/posts/a5ceba90.html","excerpt":"","text":"问：如何判断this的指向？ 在全局环境中调用就指向 window。 作为对象的方法调用就指向该对象。 作为构造函数调用就指向这个新创建的对象。 可以使用 apply,call,bind 改变 this 指向。 箭头函数中的 this 与定义时所处的上下文绑定，且不能被改变， 箭头函数 this 指向取决于它外层找到的离它最近的第一个非箭头函数的 this。 一、定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别 无论是否在严格模式下，在全局执行环境中(任何函数体外部)this都指向全局对象 在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定） this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象 example： function baz() { // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar的调用位置 } function bar() { // 当前调用栈是：baz --&gt; bar // 因此，当前调用位置在baz中 console.log( \"bar\" ); foo(); // &lt;-- foo的调用位置 } function foo() { // 当前调用栈是：baz --&gt; bar --&gt; foo // 因此，当前调用位置在bar中 console.log( \"foo\" ); } baz(); // &lt;-- baz的调用位置 this 在函数执行过程中，this 一旦被确定了，就不可以再更改 var a = 10; var obj = { a: 20 } function fn() { this = obj; // 修改this，运行后会报错 console.log(this.a); } fn(); this在类中this在类中的表现与在函数中类似，因为类本质上也是函数。 在类的构造函数中，this 是一个常规对象。类中所有非静态的方法都会被添加到 this 的原型中： class Example { constructor() { const proto = Object.getPrototypeOf(this); console.log(Object.getOwnPropertyNames(proto)); } first(){} second(){} static third(){} } new Example(); // ['constructor', 'first', 'second'] 二、具体情况分析apply、call方法在非严格模式下使用call和apply时，如果用做this值不是对象，则会被尝试转换为对象。 null和 undefined会被转换为全局对象 function bar() { console.log(Object.prototype.toString.call(this)); } bar.call(7); // [object Number] bar.call('foo'); // [object String] bar.call(undefined); // [object global] bind方法ECMAScript 5 引入了 Function.prototype.bind()。调用 f.bind(someObject) 会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。 function f(){ return this.a; } var g = f.bind({a:\"azerty\"}); console.log(g()); // azerty var h = g.bind({a:'yoo'}); // bind只生效一次！ console.log(h()); // azerty var o = {a:37, f:f, g:g, h:h}; console.log(o.a, o.f(), o.g(), o.h()); // 37, 37, azerty, azerty 箭头函数在箭头函数中，this 与封闭词法环境的 this 保持一致。在全局代码中，它将被设置为全局对象： 注意：如果将 this 传递给 call、bind、或者 apply 来调用箭头函数，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为 null。 // 创建一个含有bar方法的obj对象， // bar返回一个函数， // 这个函数返回this， // 这个返回的函数是以箭头函数创建的， // 所以它的this被永久绑定到了它外层函数的this。 // bar的值可以在调用中设置，这反过来又设置了返回函数的值。 var obj = { bar: function() { var x = (() =&gt; this); return x; } }; // 作为obj对象的一个方法来调用bar，把它的this绑定到obj。 // 将返回的函数的引用赋值给fn。 var fn = obj.bar(); // 直接调用fn而不设置this， // 通常(即不使用箭头函数的情况)默认为全局对象 // 若在严格模式则为undefined console.log(fn() === obj); // true // 但是注意，如果你只是引用obj的方法， // 而没有调用它 var fn2 = obj.bar; // 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。 console.log(fn2()() == window); // true 在上面的例子中，一个赋值给了 obj.bar 的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 A 调用时，函数 B 的 this 被永久设置为 obj.bar（函数 A）的 this。当返回的函数（函数 B）被调用时，它 this 始终是最初设置的。在上面的代码示例中，函数 B 的 this 被设置为函数 A 的 this，即 obj，所以即使被调用的方式通常将其设置为 undefined 或全局对象（或者如前面示例中的其他全局执行环境中的方法），它的 this 也仍然是 obj 。 作为对象的方法当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象。 下面的例子中，当 o.f() 被调用时，函数内的 this 将绑定到 o 对象。 var o = { prop: 37, f: function() { return this.prop; } }; console.log(o.f()); // 37 //可以理解为 o.f().call(o) 原型链中的this对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样。 var o = { f: function() { return this.a + this.b; } }; var p = Object.create(o); p.a = 1; p.b = 4; console.log(p.f()); // 5 在这个例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。虽然最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p。也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p。这是 JavaScript 的原型继承中的一个有趣的特性。 构造函数中当一个函数用作构造函数时（使用 new关键字），它的 this 被绑定到正在构造的新对象。 虽然构造函数返回的默认值是 this 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 this 对象）。 /* * 构造函数这样工作: * * function MyConstructor(){ * // 函数实体写在这里 * // 根据需要在this上创建属性，然后赋值给它们，比如： * this.fum = \"nom\"; * // 等等... * * // 如果函数具有返回对象的return语句， * // 则该对象将是 new 表达式的结果。 * // 否则，表达式的结果是当前绑定到 this 的对象。 * //（即通常看到的常见情况）。 * } */ function C(){ this.a = 37; } var o = new C(); console.log(o.a); // logs 37 function C2(){ this.a = 37; return {a:38}; } o = new C2(); console.log(o.a); // logs 38 在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与 this 绑定的默认对象被丢弃了。（这基本上使得语句 “this.a = 37;” 成了 “僵尸” 代码，实际上并不是真正的 “僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。 DOM事件处理函数当函数被用作事件处理函数时，它的 this 指向触发事件的元素（一些浏览器在使用非 addEventListener 的函数动态地添加监听函数时不遵守这个约定）。","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"https://robertjeff2.github.io/tags/JS/"}]},{"title":"elementplus踩坑","slug":"elementplus踩坑","date":"2021-09-20T07:29:24.000Z","updated":"2021-10-18T12:52:24.936Z","comments":true,"path":"posts/753e8c51.html","link":"","permalink":"https://robertjeff2.github.io/posts/753e8c51.html","excerpt":"","text":"坑一：elememt-plus 版本问题在引入element-plus插件时的坑 视频版本是1.0.2beta64 此时通过npm安装的最新版本为1.1.0beta12 然而组件库在1.1.0版本做了一次breaking changes 修改了引入的方式 通过查阅文档后修复 Breaking changes made in 1.1.0-beta.1 · Discussion #3020 · element-plus/element-plus (github.com) 坑二 还是element-plus问题没安装之前一切正常 安装好element-plus后 npm run serve 直接报错 vue项目引入ElementUI-plus运行npm run serve后出现报错，网页内容无法显示： “export ‘createElementBlock‘ (imported as ‘_createElementBlock‘) was not found in ‘vue‘ 进度98% 大概跟导包方式有关系 解决方案：升级vue版本 升级vue 到最新版本 执行 npm install vue@3.2.4 –force 升级后报错消失 网页正常显示 这个element-plus 更新太快了 让我看一个月前的课程看起来像是一年前的一样hhhh","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://robertjeff2.github.io/tags/vue3/"}]}],"categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://robertjeff2.github.io/tags/CSS/"},{"name":"JS","slug":"JS","permalink":"https://robertjeff2.github.io/tags/JS/"},{"name":"vue3","slug":"vue3","permalink":"https://robertjeff2.github.io/tags/vue3/"}]}