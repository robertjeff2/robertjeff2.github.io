{"meta":{"title":"Jeff","subtitle":"Jeffの记事本","description":"本科 | 计算机科学与技术","author":"Jeff","url":"https://robertjeff2.github.io","root":"/"},"pages":[{"title":"about","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.445Z","comments":true,"path":"about/index.html","permalink":"https://robertjeff2.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.446Z","comments":true,"path":"categories/index.html","permalink":"https://robertjeff2.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.451Z","comments":true,"path":"tags/index.html","permalink":"https://robertjeff2.github.io/tags/index.html","excerpt":"","text":""},{"title":"友链","date":"2019-07-19T08:42:10.000Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"friends/index.html","permalink":"https://robertjeff2.github.io/friends/index.html","excerpt":"","text":""},{"title":"404","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.326Z","comments":true,"path":"404.html","permalink":"https://robertjeff2.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-07-22T07:08:22.446Z","updated":"2021-07-22T07:08:22.446Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://robertjeff2.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"","date":"2021-07-22T07:08:22.448Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://robertjeff2.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"放松一下","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.339Z","comments":true,"path":"List/index.html","permalink":"https://robertjeff2.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2021-07-22T07:08:22.445Z","comments":true,"path":"archives/index.html","permalink":"https://robertjeff2.github.io/archives/index.html","excerpt":"","text":""},{"title":"统计","date":"2020-10-31T02:11:28.000Z","updated":"2021-07-22T07:08:22.447Z","comments":true,"path":"census/index.html","permalink":"https://robertjeff2.github.io/census/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-10-24T16:00:00.000Z","updated":"2021-10-16T07:24:47.502Z","comments":true,"path":"contact/index.html","permalink":"https://robertjeff2.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！"},{"title":"资源分享","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.448Z","comments":true,"path":"resource/index.html","permalink":"https://robertjeff2.github.io/resource/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.340Z","comments":true,"path":"List/music/index.html","permalink":"https://robertjeff2.github.io/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2021-07-22T07:08:22.332Z","updated":"2021-07-22T07:08:22.332Z","comments":true,"path":"List/galleries/index.html","permalink":"https://robertjeff2.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2019-08-10T08:41:10.000Z","updated":"2021-07-22T07:08:22.339Z","comments":true,"path":"List/movies/index.html","permalink":"https://robertjeff2.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"乖巧小狗","date":"2021-07-22T07:08:22.332Z","updated":"2021-07-22T07:08:22.332Z","comments":true,"path":"List/galleries/乖巧小狗/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E4%B9%96%E5%B7%A7%E5%B0%8F%E7%8B%97/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2019-07-19T08:40:27.000Z","updated":"2021-07-22T07:08:22.340Z","comments":true,"path":"List/tools/index.html","permalink":"https://robertjeff2.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-07-22T07:08:22.333Z","updated":"2021-07-22T07:08:22.333Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""},{"title":"动漫人物","date":"2021-07-22T07:08:22.333Z","updated":"2021-07-22T07:08:22.333Z","comments":true,"path":"List/galleries/动漫人物/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E4%BA%BA%E7%89%A9/index.html","excerpt":"","text":""},{"title":"动漫插画","date":"2021-07-22T07:08:22.334Z","updated":"2021-07-22T07:08:22.334Z","comments":true,"path":"List/galleries/动漫插画/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E6%8F%92%E7%94%BB/index.html","excerpt":"","text":""},{"title":"动漫风景","date":"2021-07-22T07:08:22.334Z","updated":"2021-07-22T07:08:22.334Z","comments":true,"path":"List/galleries/动漫风景/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%8A%A8%E6%BC%AB%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""},{"title":"呆萌猫咪","date":"2021-07-22T07:08:22.335Z","updated":"2021-07-22T07:08:22.335Z","comments":true,"path":"List/galleries/呆萌猫咪/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%91%86%E8%90%8C%E7%8C%AB%E5%92%AA/index.html","excerpt":"","text":""},{"title":"城市风光","date":"2021-07-22T07:08:22.336Z","updated":"2021-07-22T07:08:22.336Z","comments":true,"path":"List/galleries/城市风光/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E5%9F%8E%E5%B8%82%E9%A3%8E%E5%85%89/index.html","excerpt":"","text":""},{"title":"清新花卉","date":"2021-07-22T07:08:22.336Z","updated":"2021-07-22T07:08:22.336Z","comments":true,"path":"List/galleries/清新花卉/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E6%B8%85%E6%96%B0%E8%8A%B1%E5%8D%89/index.html","excerpt":"","text":""},{"title":"炫酷跑车","date":"2021-07-22T07:08:22.337Z","updated":"2021-07-22T07:08:22.337Z","comments":true,"path":"List/galleries/炫酷跑车/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%82%AB%E9%85%B7%E8%B7%91%E8%BD%A6/index.html","excerpt":"","text":""},{"title":"璀璨星空","date":"2021-07-22T07:08:22.337Z","updated":"2021-07-22T07:08:22.337Z","comments":true,"path":"List/galleries/璀璨星空/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%92%80%E7%92%A8%E6%98%9F%E7%A9%BA/index.html","excerpt":"","text":""},{"title":"甜美食品","date":"2021-07-22T07:08:22.338Z","updated":"2021-07-22T07:08:22.338Z","comments":true,"path":"List/galleries/甜美食品/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E7%94%9C%E7%BE%8E%E9%A3%9F%E5%93%81/index.html","excerpt":"","text":""},{"title":"自然风景","date":"2021-07-22T07:08:22.338Z","updated":"2021-07-22T07:08:22.338Z","comments":true,"path":"List/galleries/自然风景/index.html","permalink":"https://robertjeff2.github.io/List/galleries/%E8%87%AA%E7%84%B6%E9%A3%8E%E6%99%AF/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript之原型","slug":"JavaScript之原型","date":"2021-10-29T07:58:54.000Z","updated":"2021-10-29T08:36:00.843Z","comments":true,"path":"posts/421d035.html","link":"","permalink":"https://robertjeff2.github.io/posts/421d035.html","excerpt":"","text":"原型prototype原型JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象 当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾 准确地说，这些属性和方法定义在Object的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身 这个属性指向函数的原型对象，这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。 构造函数，原型和实例的关系 每个构造函数都有一个原型对象 原型对象都包含一个指向构造函数的指针 而实例都包含一个指向原型对象的指针 下面举个例子： 函数可以有属性。 每个函数都有一个特殊的属性叫作原型prototype function doSomething(){} console.log( doSomething.prototype ); 浏览器中打印输出： { constructor: ƒ doSomething(), __proto__: { constructor: ƒ Object(), hasOwnProperty: ƒ hasOwnProperty(), isPrototypeOf: ƒ isPrototypeOf(), propertyIsEnumerable: ƒ propertyIsEnumerable(), toLocaleString: ƒ toLocaleString(), toString: ƒ toString(), valueOf: ƒ valueOf() } } 上面这个对象，就是大家常说的原型对象 可以看到，原型对象有一个自有属性constructor，这个属性指向该函数，如下图关系展示 原型链未完待续…","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"}]},{"title":"JavaScript之继承","slug":"JavaScript之继承","date":"2021-10-29T07:45:31.000Z","updated":"2021-10-29T07:49:16.357Z","comments":true,"path":"posts/33c658fc.html","link":"","permalink":"https://robertjeff2.github.io/posts/33c658fc.html","excerpt":"","text":"继承继承（inheritance）是面向对象软件技术当中的一个概念。 如果一个类别B“继承自”另一个类别A，就把这个B称为“A的子类”，而把A称为“B的父类别”也可以称“A是B的超类” 继承的优点 继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码 在子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"}]},{"title":"JavaScript排序算法","slug":"JavaScript排序算法","date":"2021-10-28T06:37:04.000Z","updated":"2021-10-29T07:46:25.486Z","comments":true,"path":"posts/54fc474f.html","link":"","permalink":"https://robertjeff2.github.io/posts/54fc474f.html","excerpt":"","text":"排序算法 冒泡排序function bubbleSort(arr) { let len = arr.length; for (let i = 0; i &lt; len - 1; i++) { for (let j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } return arr; } 选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 function selectSort(arr) { let len = arr.lentgth; for (let i = 0; i &lt; len; i++) { let minIndex = i; for (let j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { minIndex = j; } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; } } return arr; } 插入排序将待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） function insertSort(arr) { let len = arr.length; for (let i = 1; i &lt; len; i++) { let current = arr[i]; let preIndex = i - 1; while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) { arr[preIndex + 1] = arr[preIndex]; preIndex--; } arr[preIndex + 1] = current; } return arr; }","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://robertjeff2.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"计网之从URL输入到网页产生","slug":"计网之从URL输入到网页产生","date":"2021-10-27T11:10:10.000Z","updated":"2021-10-27T15:11:07.587Z","comments":true,"path":"posts/922b3870.html","link":"","permalink":"https://robertjeff2.github.io/posts/922b3870.html","excerpt":"","text":"输入 URL 敲下回车后发生了什么?一、总体进程简单的分析，从输入 URL到回车后发生的行为如下： URL解析 DNS 解析 TCP 连接 HTTP 请求 响应请求 页面渲染 1.URL解析 浏览器解析URL获取协议，域名，端口，路径 2.DNS 解析2.查看浏览器是否有资源的缓存 有。判断是否过期 没过期。直接读取缓存 过期。 Etag和If-None-Match Last-Modify和lf-Modified-Since 文件修改了则把新资源发给浏览器（状态码200），没修改则告诉浏览器读取缓存（状态码304） 没有则进行下一步 首先进行DNS解析 寻找浏览器是否存在缓存，若没有 寻找操作系统是否存在缓存，若没有 寻找hosts文件中是否有域名和ip的对应关系，若没有 查找路由器中是否有缓存 寻找DNS服务器是否没缓存，若没有 向根域名服务器发送请求 生成HTTP请求 TCP 连接 建立TCP连接，三次握手 客户端发送一个SYN=1,Seq=X的TCP包 服务端发回一个SYN=1,ACK=X+1，Seq=Y的TCP包 客户端发送ACK=Y+1，Seq=Y + 1的TCP包 HTTP 请求 如果是HTTP请求 对HTTP报文进行报文分割并标记序号和端口号 如果是HTTPS请求 将HTTP报文交给TLS处理，TLS和服务端进行TLS握手，交换版本信息，加密算法，压缩算法，随机数（浏览器一个，客户端一个）。 服务端发送证书，浏览器用CA的公钥对其进行验证。 浏览器用服务端的公钥加密生成的预备主密码发送给服务端，两个随机数和预备主密码生成主密码 使用主密码生成对称加密的密钥对，消息认证码的密钥对，对称加密的CBC分组（分组模式）需要的初始化向量密钥对。 握手之后进行加密，对HTTP报文分组，分组后压缩，压缩后的数据和MAC一起加密。 对称加密保障私密性，消息认证码保障完整性，数字证书保障认证，防止中间人攻击。 对TCP报文打包，加入源IP地址和目标IP地址。 根据目标IP地址和路由表，查询下一跳路由。使用ARP查询下一跳路由的MAC地址。 对IP报文打包并附上MAC地址。 发送数据，服务端接收到请求并返回响应。 响应请求 浏览器接收到HTTP响应，关闭TCP连接或保持复用，四次挥手。 （如果返回了HTML）根据响应头的字符集进行解码 如果响应头没有字符集，则浏览器会默认用一套解码规则，当解析html解析到meta标签中的编码规则时，则替换成新的解码方式重新解码。 页面渲染 资源预解析，会将一些请求资源提前加入请求队列中 解析HTML为DOM树 标记化（tokenizing）: 将HTML解析成标记 构建树（tree construction）: 根据标记生成DOM树 解析CSS为CSSOM 根据DOM树和CSSOM生成DOM渲染树 从DOM的根节点遍历所有可见节点，对其应用对应的CSSOM规则。不可见节点包括（script, meta标签， 被css隐藏的节点） 布局：浏览器获取每个渲染对象的位置和尺寸 绘制：将计算好的像素绘制到屏幕 渲染层/合成层合并","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://robertjeff2.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"JavaScript之手写代码","slug":"JavaScript之手写代码","date":"2021-10-26T12:25:02.000Z","updated":"2021-10-26T13:15:04.192Z","comments":true,"path":"posts/71f176fb.html","link":"","permalink":"https://robertjeff2.github.io/posts/71f176fb.html","excerpt":"","text":"手写JS代码实现call函数 call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数 语法：function.call(thisArg, arg1, arg2, …) call方法的第一个参数也是this的指向，后面传入的是一个参数列表 跟apply一样，改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次 Function.prototype.call = function (context, ...args) { // context为null时，context设置为window context = context || window// 若没有传入this, 默认绑定window对象 context.fn = this // this指向调用call的对象,即我们要改变this指向的函数 let result = context.fn(...args)// 执行当前函数 delete context.fn// 删除我们声明的fn属性 return result // 返回函数执行结果 } 实现apply函数 apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。语法：func.apply(thisArg, [argsArray]) apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入 改变this指向后原函数会立即执行，且此方法只是临时改变this指向一次 apply()和call()类似，区别在于call()接收参数列表，而apply()接收一个参数数组，所以我们在call()的实现上简单改一下入参形式即可 Function.prototype.apply = function (context, args) { context = context || window// 若没有传入this, 默认绑定window对象 context.fn = this // this指向调用call的对象,即我们要改变this指向的函数 let result = context.fn(...args)// 执行当前函数（此处说明一下：虽然apply()接收的是一个数组，但在调用原函数时，依然要展开参数数组。可以对照原生apply()，原函数接收到展开的参数数组） delete context.fn// 删除我们声明的fn属性 return result// 返回函数执行结果 } 手写bind函数 bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。 语法: function.bind(thisArg, arg1, arg2, …) 首先来分析Bind的几个特点：1、函数调用，改变this 2、返回一个绑定this的函数 3、接收多个参数 4、支持柯里化形式传参fn(1)(2) Function.prototype.bind = function (context, ...args) { return (...newArgs) =&gt; { return this.call(context, ...args, ...newArgs) } }","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"}]},{"title":"LeetCode记录","slug":"LeetCode记录","date":"2021-10-26T12:22:51.000Z","updated":"2021-10-29T07:20:54.755Z","comments":true,"path":"posts/7a0c201d.html","link":"","permalink":"https://robertjeff2.github.io/posts/7a0c201d.html","excerpt":"","text":"LeetCode[3] 无重复字符的最长子串给定一个字符串，找出其中不含有重复字符的 最长子串 的长度。 最优解 滑动窗口 其实通过观察可以优化，我们制作一个窗口，让窗口中的字符串满足题目要求（无重复） 怎么让他满足要求呢？ 那就要滑动窗口了，循环去掉左边第一个元素，直到窗口中元素无重复，此时再扩大窗口 滑动窗口有两个关键点：扩张 + 收缩 首先（右指针）扩张到滑动窗口不满足条件的时候暂停， （左指针）开始收缩窗口，让窗口满足条件后再进行扩张（右指针） 需要注意的是，每次移动右指针，当发现新加入的字符在当前区间内已经存在时，需要移动左指针到已存在字符的下一位。 /* * @lc app=leetcode.cn id=3 lang=javascript * * [3] 无重复字符的最长子串 */ // @lc code=start /** * @param {string} s * @return {number} */ var lengthOfLongestSubstring = function (s) { let n = s.length; let [i, j, len] = [0, 0, 0]; let set = new Set(); while (i &lt; n &amp;&amp; j &lt; n) { if (set.has(s[j])) { set.delete(s[i++]); } else { set.add(s[j++]); len = Math.max(len, j - i); } } return len; }; // @lc code=end 15. 三数之和给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 /* * @lc app=leetcode.cn id=15 lang=javascript * * [15] 三数之和 */ // @lc code=start /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function (nums) { let res = []; let n = nums.length; nums.sort((a, b) =&gt; a - b); for (let i = 0; i &lt; n - 2; i++) { if (nums[i] == nums[i - 1]) continue; let l = i + 1; let r = n - 1; while (l &lt; r) { let m = nums[i] + nums[l] + nums[r]; if (m == 0) { res.push([nums[i], nums[l], nums[r]]); while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) l++; while (l &lt; r &amp;&amp; nums[r] == nums[r + 1]) r--; l++; r--; } if (m &gt; 0) r--; if (m &lt; 0) l++; } } return res; }; // @lc code=end // @lc code=end //先排序，然后采用双指针，注意相等的情况 二叉树的中序遍历给定一个二叉树的根节点 root ，返回它的 中序 遍历。 /* * @lc app=leetcode.cn id=94 lang=javascript * * [94] 二叉树的中序遍历 */ // @lc code=start /** * Definition for a binary tree node. * function TreeNode(val, left, right) { * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * } */ /** * @param {TreeNode} root * @return {number[]} */ var inorderTraversal = function(root) { const res= [] const stk =[] while(root ||stk.length){ while(root){ stk.push(root) root=root.left } root =stk.pop() res.push(root.val) root=root.right } return res }; // @lc code=end","categories":[],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://robertjeff2.github.io/tags/LeetCode/"}]},{"title":"JavaScript之防抖和节流","slug":"JavaScript之防抖和节流","date":"2021-10-25T01:59:20.000Z","updated":"2021-10-25T03:46:58.068Z","comments":true,"path":"posts/581ef0de.html","link":"","permalink":"https://robertjeff2.github.io/posts/581ef0de.html","excerpt":"","text":"函数防抖和节流一、是什么本质上是优化高频率执行代码的一种手段 如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能 为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用throttle（节流）和debounce（防抖）的方式来减少调用频率 定义 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时 二、防抖每次事件触发后总是等待一段时间执行，如果在等待时间内事件再次触发，则重新计算等待时间（停止触发的时候只会执行一次,最后一次生效） 这里模拟一个输入框，当连续输入多个字符时，只有等待了足够的timer才执行log操作。 &lt;input type=\"text\" name=\"\" value=\"\"&gt; &lt;script type=\"text/javascript\"&gt; let el = document.querySelector('input') el.addEventListener(\"input\", debounce(A, 500)) function debounce(fn, delay) { let timer = null return function () { timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; { fn.call(this) }, delay) } } function A() { console.log(this.value) } &lt;/script&gt; 三、节流每次事件触发后总是等待一段时间执行，如果在等待时间内事件再次触发（事件触发时有其他事件在等待），则不作处理。如果事件触发时没有其他事件在等待，则将事件进行绑定（等待时间到则进行事件执行）多次触发事件时只有一次生效，对应时间内只执行一次，第一次生效。 function throttle(fn,time=1000){ let canRun=true;//阀门打开 return function (){ if(!canRun)return false canRun=false//使用定时器 关闭阀门 setTimeout(()=&gt;{ fn.call(this) canRun=true//执行完毕开启阀门 },time) } } setInterval(throttle(function() { console.log(\"hello world\") }), 100) 四、应用场景防抖search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 登录、发短信等按钮避免用户点击太快，以致于发送了多次请求。 调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多。 文本编辑器实时保存，当无任何更改操作一秒后进行保存。 节流scroll 事件，每隔一秒计算一次位置信息等。 浏览器播放事件，每个一秒计算一次进度信息等。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"}]},{"title":"CSS之垂直水平居中","slug":"CSS之垂直水平居中","date":"2021-10-24T05:00:24.000Z","updated":"2021-10-24T05:43:32.359Z","comments":true,"path":"posts/63fa0374.html","link":"","permalink":"https://robertjeff2.github.io/posts/63fa0374.html","excerpt":"","text":"CSS垂直水平居中的几种方法文本垂直居中&lt;style rel=\"stylesheet\" type=\"text/css\"&gt; .text{ width: 200px; height: 200px; text-align: center; line-height: 200px; background: skyblue } &lt;/style&gt; &lt;div class=\"text\"&gt;文本垂直居中&lt;/div&gt; 实现效果： 元素垂直居中1.绝对定位 利用 calc 计算偏移量使用绝对性定位，已知盒子自身宽高，利用 calc 计算偏移量进行定位 body{margin: 0;padding: 0;} .calc{ position: absolute; width: 200px; height: 200px; left:calc((100% - 200px)/2); top:calc((100% - 200px)/2); background: yellowgreen;/* 方便看效果 */ } &lt;/style&gt; &lt;!-- html 结构 --&gt; &lt;div class=\"calc\"&gt;元素垂直居中&lt;/div&gt; 实现效果： 2.绝对定位 利用margin:auto属性使用绝对定位，利用 margin:auto 属性，对已知宽高的盒子进行自动偏移定位 &lt;!-- css 样式 --&gt; &lt;style rel=\"stylesheet\" type=\"text/css\"&gt; /* 绝对性定位 */ .div { width:200px; height:200px; position:absolute; top:0; right:0; bottom:0; left:0; margin: auto; background: skyblue; } &lt;/style&gt; &lt;!-- html 结构 --&gt; &lt;div class=\"div\"&gt;margin: auto;元素垂直居中&lt;/div&gt; 实现效果： 3.绝对定位 利用 margin 负值属性使用绝对定位，利用 margin 负值属性，对已知宽高的盒子进行计算偏移量进行定位 &lt;!-- css 样式 --&gt; &lt;style rel=\"stylesheet\" type=\"text/css\"&gt; .div { position:absolute; top:50%; left:50%; width:200px; height: 200px; margin-top: -100px; margin-left: -100px; /*margin-left: -100px 0 0 -100px;*/ background:red; } &lt;/style&gt; &lt;!-- html 结构 --&gt; &lt;div class=\"div\"&gt;margin: -100px;元素垂直居中&lt;/div&gt; 实现效果： 4.绝对定位 利用 transform 属性使用绝对定位，利用 transform 属性，对未知宽高的盒子进行自动偏移定位 &lt;!-- css 样式 --&gt; &lt;style rel=\"stylesheet\" type=\"text/css\"&gt; .div { position: absolute; /* 相对定位或绝对定位均可 */ width:200px; height:200px; top: 50%; left: 50%; transform: translate(-50%,-50%); background-color: pink; } &lt;/style&gt; &lt;!-- html 结构 --&gt; &lt;div class=\"div\"&gt;利用 transform 进行垂直居中&lt;/div&gt; 实现效果： 5.Flex布局使用Flex布局，利用 align-items: center; 与 justify-content: center; 属性，对未知宽高的盒子进行自动偏移定位，父元素需要设置高度 &lt;style type=\"text/css\"&gt; .container{ display: flex; align-items: center; justify-content: center; height: 100vh; } .container div{ width: 200px; height: 200px; background-color: greenyellow; } &lt;/style&gt; &lt;div class=\"container\"&gt; &lt;div&gt;利用flex布局进行水平垂直居中&lt;/div&gt; &lt;/div&gt; 实现效果： 6.table-cell 布局使用 table-cell 布局，利用 display: table-cell; 、 vertical-align: middle; 与 text-align: center; 属性，对未知宽高的盒子进行自动偏移定位，父元素需要设置宽高，适合有父元素元素的定位 &lt;!-- css 样式 --&gt; &lt;style rel=\"stylesheet\" type=\"text/css\"&gt; /* table-cell 不需要盒子本身宽高*/ .table-cell { display: table-cell; vertical-align: middle; text-align: center; width: 500px; height: 500px; background: pink; } .table-cell div{ width: 200px; height: 200px; background:skyblue; display: inline-block; } &lt;/style&gt; &lt;!-- html 结构 --&gt; &lt;div class=\"table-cell\"&gt; &lt;div &gt;利用 table-cell 进行水平垂直居中&lt;/div&gt; &lt;/div&gt; 实现效果：","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://robertjeff2.github.io/tags/CSS/"}]},{"title":"JavaScript之数组扁平化实现","slug":"JavaScript之数组扁平化实现","date":"2021-10-22T11:31:33.000Z","updated":"2021-10-25T03:49:33.196Z","comments":true,"path":"posts/7dac7232.html","link":"","permalink":"https://robertjeff2.github.io/posts/7dac7232.html","excerpt":"","text":"数组扁平化一、什么是数组扁平化 扁平化，顾名思义就是减少复杂性装饰，使其事物本身更简洁、简单，突出主题。 数组扁平化，对着上面意思套也知道了，就是将一个复杂的嵌套多层的数组，一层一层的转化为层级较少或者只有一层的数组。 二、实现方式1.ES6提供的flat方法arr.flat([depth]) depth表示展开深度，默认为1，这里直接传入Infinity(无限大，所以不论多少层都可以展开)。 ary = arr.flat(Infinity) console.log([1, [2, 3, [4, 5]]].flat(Infinity)) Array.prototype.flat() 特性总结 Array.prototype.flat() 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。 不传参数时，默认“拉平”一层，可以传入一个整数，表示想要“拉平”的层数。 传入 &lt;=0 的整数将返回原数组，不“拉平” Infinity 关键字作为参数时，无论多少层嵌套，都会转为一维数组 如果原数组有空位，Array.prototype.flat() 会跳过空位。 2.ES6的解构运算符…+some() ... 每次只能展开最外层的数组，被 [].concat 后，arr 就扁平化一次。 function flatten(arr){ while(arr.some(item =&gt; Array.isArray(item))){ arr = [].concat(...arr); } return arr; } const arr = [1, [2, [3, 4]]]; console.log(flatten(arr)); 3.reduce reduce 本身就是一个迭代循环器，通常用于累加，所以根据这一特点有以下： let arr = [1, [2, [3, 4]]]; function flatten(arr) { return arr.reduce(function(prev, next){ return prev.concat(Array.isArray(next) ? flatten(next) : next) }, []) } console.log(flatten(arr)) //reduce搭配扩展运算符 const flatten = (array) =&gt; array.reduce((acc,cur)=&gt; (Array.isArray(cur)?[...acc,...flatten(cur)]:[...acc,cur]),[]) 4.递归实现递归的遍历每一项，当为数组时则继续，不为数组则concat。 function flatten(arr) { var result = []; for (var i = 0, len = arr.length; i &lt; len; i++) { if (Array.isArray(arr[i])) { result = result.concat(flatten(arr[i])) } else { result.push(arr[i]) } } return result; } 5.toString()+split数字类型会变成字符串，所以这个其实并不是真正的扁平化 var arr = [1, [2, [3, 4]]]; function flatten(arr) { return arr.toString().split(','); } console.log(flatten(arr)); // [\"1\", \"2\", \"3\", \"4\"] 6.正则逻辑就是转成字符串之后，进行正则匹配，把所有[]去掉，然后在最外层加一个[]； var arr = [1, [2, [3, 4]]]; function flatten(arr) { let str = JSON.stringify(arr); str = str.replace(/(\\[|\\])/g, ''); str = '[' + str + ']'; return JSON.parse(str); } console.log(flatten(arr)); // [1, 2, 3, 4]","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"}]},{"title":"JavaScript之闭包","slug":"JavaScript之闭包","date":"2021-10-22T11:30:16.000Z","updated":"2021-10-28T05:43:18.850Z","comments":true,"path":"posts/db7d8843.html","link":"","permalink":"https://robertjeff2.github.io/posts/db7d8843.html","excerpt":"","text":"闭包（closure）一、闭包是什么闭包 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure） 也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域 在 JavaScript中，每当创建一个函数，闭包就会在函数创建的同时被创建出来，作为函数内部与外部连接起来的一座桥梁。 例子： function init() { var name = \"Mozilla\"; // name 是一个被 init 创建的局部变量 function displayName() { // displayName() 是内部函数，一个闭包 alert(name); // 使用了父函数中声明的变量 } displayName(); } init(); displayName() 没有自己的局部变量。然而，由于闭包的特性，它可以访问到外部函数的变量 二、学习前准备JS执行上下文简单的来说，执行上下文是一种对Javascript代码执行环境的抽象概念，也就是说只要有Javascript代码运行，那么它就一定是运行在执行上下文中 执行上下文的类型分为三种： 全局执行上下文：只有一个，浏览器中的全局对象就是 window对象，this 指向这个全局对象 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文 Eval 函数执行上下文： 指的是运行在 eval 函数中的代码，很少用而且不建议使用 紫色框住的部分为全局上下文，蓝色和橘色框起来的是不同的函数上下文。只有全局上下文（的变量）能被其他任何上下文访问 可以有任意多个函数上下文，每次调用函数创建一个新的上下文，会创建一个私有作用域，函数内部声明的任何变量都不能在当前函数作用域外部直接访问 执行上下文的生命周期执行上下文的生命周期包括三个阶段：创建阶段 → 执行阶段 → 回收阶段 创建阶段创建阶段即当函数被调用，但未执行任何其内部代码之前 创建阶段做了三件事： 确定 this 的值，也被称为 This Binding LexicalEnvironment（词法环境） 组件被创建 VariableEnvironment（变量环境） 组件被创建 This Binding确定this的值我们前面讲到，this的值是在执行的时候才能确认，定义的时候不能确认 词法环境词法环境有两个组成部分： 全局环境：是一个没有外部环境的词法环境，其外部环境引用为null，有一个全局对象，this 的值指向这个全局对象 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象，外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境 变量环境变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性 在 ES6 中，词法环境和变量环境的区别在于前者用于存储函数声明和变量（ let 和 const ）绑定，而后者仅用于存储变量（ var ）绑定 执行阶段在这阶段，执行变量赋值、代码执行 如果 Javascript 引擎在源代码中声明的实际位置找不到变量的值，那么将为其分配 undefined 值 回收阶段执行上下文出栈等待虚拟机回收执行上下文 JS调用栈执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文 当Javascript引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中 每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中 引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文 let a = 'Hello World!'; function first() { console.log('Inside first function'); second(); console.log('Again inside first function'); } function second() { console.log('Inside second function'); } first(); console.log('Inside Global Execution Context'); 转换成图的形式 简单分析一下流程： 创建全局上下文请压入执行栈 first函数被调用，创建函数执行上下文并压入栈 执行first函数过程遇到second函数，再创建一个函数执行上下文并压入栈 second函数执行完毕，对应的函数执行上下文被推出执行栈，执行下一个执行上下文first函数 first函数执行完毕，对应的函数执行上下文也被推出栈中，然后执行全局上下文 所有代码执行完毕，全局上下文也会被推出栈中，程序结束 三、闭包的本质本质当前环境中存在指向父级作用域的引用 特性函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 优缺点优点：能够实现封装和缓存等。 缺点：①消耗内存； ​ ②使用不当会造成内存泄露。 闭包的解决方法在退出函数之前，将不使用的局部变量全部删除。 四、闭包的应用场景任何闭包的使用场景都离不开这两点： 创建私有变量 延长变量的生命周期 一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的 在日常的使用中，闭包通常有以下几种场景： 通过循环给页面上多个 dom 节点绑定事件 做一个简单的cache工具，实现闭包隐藏数据，只提供 API 函数柯里化 单例模式单例模式是一种常见的涉及模式，它保证了一个类只有一个实例。实现方法一般是先判断实例是否存在，如果存在就直接返回，否则就创建了再返回。单例模式的好处就是避免了重复实例化带来的内存开销： // 单例模式 function Singleton(){ this.data = 'singleton'; } Singleton.getInstance = (function () { var instance; return function(){ if (instance) { return instance; } else { instance = new Singleton(); return instance; } } })(); var sa = Singleton.getInstance(); var sb = Singleton.getInstance(); console.log(sa === sb); // true console.log(sa.data); // 'singleton' 模拟私有属性javascript 没有 java 中那种 public private 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性： // 模拟私有属性 function getGeneratorFunc () { var _name = 'John'; var _age = 22; return function () { return { getName: function () {return _name;}, getAge: function() {return _age;} }; }; } var obj = getGeneratorFunc()(); obj.getName(); // John obj.getAge(); // 22 obj._age; // undefined 函数柯里化是什么函数柯里化是将一个接收多个参数的函数变为接收任意参数且最终返回一个函数的一种技术方式，其最终支持的是方法的连续调用，每次返回新的函数，在最终符合条件或者使用完所有的传参时终止函数调用。 柯里化的作用与特点函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。 例子有一个add函数，用于返回所有参数的和，add(1, 2, 3, 4, 5)返回的是15，那么现在要将其变为类似 add(1)(2)(3)(4)(5) 或者 add(1)(2, 3, 4)(5) 的形式，并且功能相同，这就是柯里化想要达到的效果。 function add(...args) { function fn(...newArgs) { return sum(...args, ...newArgs) } // 重点是这个toString // 当最后返回函数的时候，自动调用toString函数进行累加 fn.toString = () =&gt; { return args.reduce((a, b) =&gt; { return a + b }) } return fn } //现在浏览器调用会返回函数，需要手动执行toString()方法 //或者将console.log改成alert 解法2 function add() { // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = Array.prototype.slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var _adder = function() { _args.push(...arguments); // 这里的返回是为了让后面的()调用的时候能拿到这个函数体，有点递归意思 return _adder; } // 这个是最后输出的时候被调用的，return 后面如果是函数体， // 为了输出函数体字符串会自动调用toString方法 // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () { return _args.reduce(function (a, b) { return a + b; }); } // 这个return是第一次调用的时候返回上面的函数体， // 这样后面所有的括号再执行的时候就是执行_adder函数体 return _adder; } var re = add(1,2)(3)(4)(5) console.log(re.toString())//15 闭包会造成内存泄漏吗？答：闭包本身并不会造成内存泄漏，造成了内存泄漏一般是程序员的bug 先来理解什么是内存泄漏 百度百科：内存泄漏是指程序中已动态分配的堆内存由于某种原因，程序未释放或者无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就能一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设为 null。 跟闭包和内存泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JavaScript的问题。在 IE浏览器中，由于BOM和DOM中的对象是使用 C++以COM对象的方式实现的，而COM对象的垃圾收集机制采用的是引用计数策略。在基于引用计数策略的垃圾回收机制中，如果两个对象之间形成了循环引用，那么这两个对象都无法被回收，但循环引用造成的内存泄露在本质上也不是闭包造成的。 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环引用中的变量设为null即可。将变量设置为null意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。 ——引用于《 JavaScript设计模式与开发实践 》 关于闭包会造成内存泄漏主要是由于IE浏览器（主要是IE6）早期的垃圾回收机制存在BUG，跟闭包本身是没有关系的。 但是大量滥用闭包很容易导致内存泄漏，闭包会造成对象引用的生命周期脱离当前函数的上下文，因此，如果不仔细考虑闭包函数的生命周期，的确有可能出现意料之外的内存泄漏，当然，从严格意义上讲，这是程序员自己的bug，而不是闭包的错。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"}]},{"title":"JavaScript之Array对象","slug":"JavaScript之Array对象","date":"2021-10-22T03:03:13.000Z","updated":"2021-10-25T02:41:25.152Z","comments":true,"path":"posts/1e82aa9b.html","link":"","permalink":"https://robertjeff2.github.io/posts/1e82aa9b.html","excerpt":"","text":"Array对象允许存储键值集合，这很好。 但很多时候我们发现还需要 有序集合，里面的元素都是按顺序排列的。例如，我们可能需要存储一些列表，比如用户、商品以及 HTML 元素等。 这里使用对象就不是很方便了，因为对象不能提供能够管理元素顺序的方法。我们不能在已有的元素“之间”插入一个新的属性。这种场景下对象就不太适用了。 这时一个特殊的数据结构数组（Array）就派上用场了，它能存储有序的集合。 声明声明数组有好几种基本的方式，但不外乎基于以下两种方式声明： let arr = new Array();// 构造函数法 let arr = [];// 字面量赋值法 如果知道数组中元素的数量，那么可以给构造函数传入一个数值，然后 length 属性就会被自动创建并设置为这个值。比如，下面的代码会创建一个初始 length 为 20 的数组： let colors = new Array(20); 而如果这个值是其他类型的，则会创建一个只包含该特定值的数组： let colors = new Array(3); // 创建一个包含3 个元素的数组 let names = new Array('Greg'); // 创建一个只包含一个元素，即字符串'Greg'的数组 在使用 Array 构造函数时，也可以省略 new 操作符，结果是一样的。 注意：与对象一样，在使用数组字面量表示法创建数组不会调用 Array 构造函数。 Array 构造函数还有两个 ES6 新增的用于创建数组的静态方法：from()和 of()。from()用于将类数组结构转换为数组实例，而 of()用于将一组参数转换为数组实例。 Array.from()的第一个参数是一个类数组对象，或任何可迭代对象。这种方式可用于很多场合： // 字符串会被拆分为单字符数组 console.log(Array.from('Matt')); // ['M', 'a', 't', 't'] // 可以使用from()将集合和映射转换为一个新数组 const m = new Map().set(1, 2).set(3, 4); const s = new Set().add(1).add(2).add(3).add(4); console.log(Array.from(m)); // [[1, 2], [3, 4]] console.log(Array.from(s)); // [1, 2, 3, 4] // Array.from()对现有数组执行浅复制 const a1 = [1, 2, 3, 4]; const a2 = Array.from(a1); console.log(a1); // [1, 2, 3, 4] console.log(a1 === a2); // false // 可以使用任何可迭代对象 const iter = { *[Symbol.iterator]() { yield 1; yield 2; yield 3; yield 4; }, }; console.log(Array.from(iter)); // [1, 2, 3, 4] // arguments 对象可以被轻松地转换为数组 function getArgsArray() { return Array.from(arguments); } console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4] // from()也能转换带有必要属性的自定义对象 const arrayLikeObject = { 0: 1, 1: 2, 2: 3, 3: 4, length: 4, }; console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4] Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函数中 this 的值。但这个重写的 this 值在箭头函数中不适用。 const a1 = [1, 2, 3, 4]; const a2 = Array.from(a1, (x) =&gt; x ** 2); const a3 = Array.from( a1, function (x) { return x ** this.exponent; }, {exponent: 2}, ); console.log(a2); // [1, 4, 9, 16] console.log(a3); // [1, 4, 9, 16] Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6 之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法： console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4] console.log(Array.of(undefined)); // [undefined] 检测数组一个经典的 ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作用域）的情况下，使用 instanceof 操作符就足矣： if (value instanceof Array) { // 操作数组 } 使用 instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的 Array 构造函数。如果要把数组从一个框架传给另一个框架，则这个数组的构造函数将有别于在第二个框架内本地创建的数组。 为解决这个问题，ECMAScript 提供了 Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子： if (Array.isArray(value)) { // 操作数组 } 数组常见方法搜索与位置方法ECMAScript 提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。 严格相等ECMAScript 提供了 3 个严格相等的搜索方法：indexOf()、lastIndexOf()和 includes()。其中，前两个方法在所有版本中都可用，而第三个方法是 ECMAScript 7 新增的。这些方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。indexOf()和 includes()方法从数组前头（第一项）开始向后搜索，而 lastIndexOf()从数组末尾（最后一项）开始向前搜索。 indexOf()和 lastIndexOf()都返回要查找的元素在数组中的位置，如果没找到则返回-1。includes()返回布尔值，表示是否至少找到一个与指定元素匹配的项。在比较第一个参数跟数组每一项时，会使用全等（===）比较，也就是说两项必须严格相等。下面来看一些例子： let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; console.log(numbers.indexOf(4)); // 3 console.log(numbers.lastIndexOf(4)); // 5 console.log(numbers.includes(4)); // true console.log(numbers.indexOf(4, 4)); // 5 console.log(numbers.lastIndexOf(4, 4)); // 3 console.log(numbers.includes(4, 7)); // false let person = {name: 'Nicholas'}; let people = [{name: 'Nicholas'}]; let morePeople = [person]; console.log(people.indexOf(person)); // -1 console.log(morePeople.indexOf(person)); // 0 console.log(people.includes(person)); // false console.log(morePeople.includes(person)); // true indexOf() 和 incudes() 的不同 indexOf()在搜索时会使用 === ，数组中存在 NaN 时，这就会产生意想不到的结果，例如： let NaNs = [NaN, NaN]; console.log(NaNs.indexOF(NaN)); // -1 但是使用 includes() 就会避免这个问题，因为 includes() 在搜索时会使用 Object.is() 进行比较： let NaNs = [NaN, NaN]; console.log(NaNs.includes(NaN)); // true 断言函数ECMAScript 也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。断言函数的返回值决定了相应索引的元素是否被认为匹配。 断言函数接收 3 个参数：元素、索引和数组本身。其中元素是数组中当前搜索的元素，索引是当前元素的索引，而数组就是正在搜索的数组。断言函数返回真值，表示是否匹配。 find()和 findIndex()方法使用了断言函数。这两个方法都从数组的最小索引开始。find()返回第一个匹配的元素，findIndex()返回第一个匹配元素的索引。这两个方法也都接收第二个可选的参数，用于指定断言函数内部 this 的值。 const people = [ { name: 'Matt', age: 27, }, { name: 'Nicholas', age: 29, }, ]; console.log(people.find((element, index, array) =&gt; element.age &lt; 28)); // {name: 'Matt', age: 27} console.log(people.findIndex((element, index, array) =&gt; element.age &lt; 28)); // 0 找到匹配项后，这两个方法都不再继续搜索。 const evens = [2, 4, 6]; // 找到匹配后，永远不会检查数组的最后一个元素 evens.find((element, index, array) =&gt; { console.log(element); console.log(index); console.log(array); return element === 4; }); // 2 // 0 // [2, 4, 6] // 4 // 1 // [2, 4, 6] 排序方法数组有两个方法可以用来对元素重新排序：reverse()和 sort()。顾名思义，reverse()方法就是将数组元素反向排列。比如： let values = [1, 2, 3, 4, 5]; values.reverse(); console.log(values); // 5,4,3,2,1 //V8引擎710行 // In-place QuickSort algorithm. // For short (length &lt;= 22) arrays, insertion sort is used for efficiency. V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于22的数组使用 InsertionSort，比22大的数组则使用 QuickSort。 这里，数组 values 的初始状态为[1,2,3,4,5]。通过调用 reverse()反向排序，得到了[5,4,3,2,1]。这个方法很直观，但不够灵活，所以才有了 sort()方法。 默认情况下，sort()会按照升序重新排列数组元素，即最小的值在前面，最大的值在后面。为此，sort()会在每一项上调用 String()转型函数，然后比较字符串来决定顺序。即使数组的元素都是数值，也会先把数组转换为字符串再比较、排序。比如： let values = [0, 1, 5, 10, 15]; values.sort(); console.log(values); // 0,1,10,15,5 一开始数组中数值的顺序是正确的，但调用 sort()会按照这些数值的字符串形式重新排序。因此，即使 5 小于 10，但字符串’10’在字符串’5’的前头，所以 10 还是会排到 5 前面。很明显，这在多数情况下都不是最合适的。为此，sort()方法可以接收一个 比较函数，用于判断哪个值应该排在前面。 比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，就返回负值；如果两个参数相等，就返回 0；如果第一个参数应该排在第二个参数后面，就返回正值。下面是使用简单比较函数的一个例子： function compare(value1, value2) { if (value1 &lt; value2) { return -1; } else if (value1 &gt; value2) { return 1; } else { return 0; } } 这个比较函数可以适用于大多数数据类型，可以把它当作参数传给 sort()方法，如下所示： let values = [0, 1, 5, 10, 15]; values.sort(compare); console.log(values); // 0,1,5,10,15 在给 sort()方法传入比较函数后，数组中的数值在排序后保持了正确的顺序，同理，比较函数也能产生降序。 简写为一个箭头函数： let values = [0, 1, 5, 10, 15]; values.sort((a, b) =&gt; (a &lt; b ? 1 : a &gt; b ? -1 : 0)); console.log(values); // 15,10,5,1,0 当然，如果只是想反转数组的顺序，reverse()更简单也更快。 注意 reverse()和 sort()都返回调用它们的数组的引用。 如果数组的元素是数值，或者是其 valueOf()方法返回数值的对象（如 Date 对象），这个比较函数还可以写得更简单，因为这时可以直接用第二个值减去第一个值： function compare(value1, value2) { return value2 - value1; } 比较函数就是要返回小于 0、0 和大于 0 的数值，因此减法操作完全可以满足要求。 栈方法栈是一种后进先出（LIFO，Last-In-First-Out）的结构，也就是最近添加的项先被删除。数据项的插入（称为 推入，push）和删除（称为 弹出，pop）只在栈的一个地方发生，即栈顶。ECMAScript 数组提供了 push()和 pop()方法，以实现类似栈的行为。 push()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。pop()方法则用于删除数组的最后一项，同时减少数组的 length 值，返回被删除的项。来看下面的例子： let colors = new Array(); // 创建一个数组 let count = colors.push('red', 'green'); // 推入两项 console.log(count); // 2 count = colors.push('black'); // 再推入一项 console.log(count); // 3 let item = colors.pop(); // 取得最后一项 console.log(item); // black console.log(colors.length); // 2 队列方法队列以先进先出（FIFO，First-In-First-Out）形式限制访问。队列在列表末尾添加数据，但从列表开头获取数据。因为有了在数据末尾添加数据的 push()方法，所以要模拟队列就差一个从数组开头取得数据的方法了。这个数组方法叫 shift()，它会删除数组的第一项并返回它，然后数组长度减 1。使用 shift()和 push()，可以把数组当成队列来使用： let colors = new Array(); // 创建一个数组 let count = colors.push('red', 'green'); // 推入两项 console.log(count); // 2 count = colors.push('black'); // 再推入一项 console.log(count); // 3 let item = colors.shift(); // 取得第一项 console.log(item); // red console.log(colors.length); // 2 ECMAScript 也为数组提供了 unshift()方法。顾名思义，unshift()就是执行跟 shift()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。通过使用 unshift()和 pop()，可以在相反方向上模拟队列，即在数组开头添加新数据，在数组末尾取得数据，如下例所示： let colors = new Array(); // 创建一个数组 let count = colors.unshift('red', 'green'); // 从数组开头推入两项 console.log(count); // 2 count = colors.unshift('black'); // 再推入一项 console.log(count); // 3 let item = colors.pop(); // 取得最后一项 console.log(item); // green console.log(colors.length); // 2 操作方法concat()对于数组中的元素，我们有很多操作方法。比如，concat()方法可以在现有数组全部元素基础上创建一个新数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果传入一个或多个数组，则 concat()会把这些数组的每一项都添加到结果数组。如果参数不是数组，则直接把它们添加到结果数组末尾。来看下面的例子： let colors = ['red', 'green', 'blue']; let colors2 = colors.concat('yellow', ['black', 'brown']); console.log(colors); // ['red', 'green','blue'] console.log(colors2); // ['red', 'green', 'blue', 'yellow', 'black', 'brown'] 这里先创建一个包含 3 个值的数组 colors。然后 colors 调用 concat()方法，传入字符串’yellow’和一个包含’black’和’brown’的数组。保存在 colors2 中的结果就是[‘red’, ‘green’, ‘blue’,’yellow’, ‘black’, ‘brown’]。原始数组 colors 保持不变。 slice()方法 slice()用于创建一个包含原有数组中一个或多个元素的新数组。slice()方法可以接收一个或两个参数：返回元素的开始索引和结束索引。如果只有一个参数，则 slice()会返回该索引到数组末尾的所有元素。如果有两个参数，则 slice()返回从开始索引到结束索引对应的所有元素，其中不包含结束索引对应的元素。记住，这个操作不影响原始数组。来看下面的例子： let colors = ['red', 'green', 'blue', 'yellow', 'purple']; let colors2 = colors.slice(1); let colors3 = colors.slice(1, 4); console.log(colors2); // green,blue,yellow,purple console.log(colors3); // green,blue,yellow 这里，colors 数组一开始有 5 个元素。调用 slice()传入 1 会得到包含 4 个元素的新数组。其中不包括’red’，这是因为拆分操作要从位置 1 开始，即从’green’开始。得到的 colors2 数组包含’green’、’blue’、’yellow’和’purple’。colors3 数组是通过调用 slice()并传入 1 和 4 得到的，即从位置 1 开始复制到位置 3。因此 colors3 包含’green’、’blue’和’yellow’。 splice()最强大的数组方法就属 splice()了，使用它的方式可以有很多种。splice()的主要目的是在数组中间插入元素，但有 3 种不同的方式使用这个方法。 删除。需要给 splice()传 2 个参数：要删除的第一个元素的位置和要删除的元素数量。可以从数组中删除任意多个元素，比如 splice(0, 2)会删除前两个元素。 插入。需要给 splice()传 3 个参数：开始位置、0（要删除的元素数量）和要插入的元素，可以在数组中指定的位置插入元素。第三个参数之后还可以传第四个、第五个参数，乃至任意多个要插入的元素。比如，splice(2, 0, ‘red’, ‘green’)会从数组位置 2 开始插入字符串’red’和’green’。 替换。splice()在删除元素的同时可以在指定位置插入新元素，同样要传入 3 个参数：开始位置、要删除元素的数量和要插入的任意多个元素。要插入的元素数量不一定跟删除的元素数量一致。比如，splice(2, 1, ‘red’, ‘green’)会在位置 2 删除一个元素，然后从该位置开始向数组中插入’red’和’green’。 splice()方法始终返回这样一个数组，它包含从数组中被删除的元素（如果没有删除元素，则返回空数组）。以下示例展示了上述 3 种使用方式。 let colors = ['red', 'green', 'blue']; let removed = colors.splice(0, 1); // 删除第一项 console.log(colors); // green,blue console.log(removed); // red，只有一个元素的数组 removed = colors.splice(1, 0, 'yellow', 'orange'); // 在位置1 插入两个元素 console.log(colors); // green,yellow,orange,blue console.log(removed); // 空数组 removed = colors.splice(1, 1, 'red', 'purple'); // 插入两个值，删除一个元素 console.log(colors); // green,red,purple,orange,blue console.log(removed); // yellow，只有一个元素的数组 这个例子中，colors 数组一开始包含 3 个元素。第一次调用 splice()时，只删除了第一项，colors 中还有’green’和’blue’。第二次调用 slice()时，在位置 1 插入两项，然后 colors 包含’green’、’yellow’、’orange’和’blue’。这次没删除任何项，因此返回空数组。最后一次调用 splice()时删除了位置 1 上的一项，同时又插入了’red’和’purple’。最后，colors 数组包含’green’、’red’、’purple’、’orange’和’blue’。 迭代方法ECMAScript 为数组定义了 5 个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数，以及可选的作为函数运行上下文的作用域对象（影响函数中 this 的值）。传给每个方法的函数接收 3 个参数：数组元素、元素索引和数组本身。因具体方法而异，这个函数的执行结果可能会也可能不会影响方法的返回值。数组的 5 个迭代方法如下。 every()：对数组每一项都运行传入的函数，如果对每一项函数都返回 true，则这个方法返回 true。 filter()：对数组每一项都运行传入的函数，函数返回 true 的项会组成数组之后返回。 forEach()：对数组每一项都运行传入的函数，没有返回值。 map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。 some()：对数组每一项都运行传入的函数，如果有一项函数返回 true，则这个方法返回 true。 这些方法都不改变调用它们的数组。 every()和some()注意：若收到一个空数组，这两个在一切情况下都会返回 true。 every()和 some()是最相似的，都是从数组中搜索符合某个条件的元素。对 every()来说，传入的函数必须对每一项都返回 true，它才会返回 true；否则，它就返回 false。而对 some()来说，只要有一项让传入的函数返回 true，它就会返回 true。下面是一个例子： let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let everyResult = numbers.every((item, index, array) =&gt; item &gt; 2); console.log(everyResult); // false let someResult = numbers.some((item, index, array) =&gt; item &gt; 2); console.log(someResult); // true 以上代码调用了 every()和 some()，传入的函数都是在给定项大于 2 时返回 true。every()返回 false 是因为并不是每一项都能达到要求。而 some()返回 true 是因为至少有一项满足条件。 filter()这个方法基于给定的函数来决定某一项是否应该包含在它返回的数组中。 let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let filterResult = numbers.filter((item, index, array) =&gt; item &gt; 2); console.log(filterResult); // 3,4,5,4,3 这里，调用 filter()返回的数组包含 3、4、5、4、3，因为只有对这些项传入的函数才返回 true。这个方法非常适合从数组中筛选满足给定条件的元素。 map()map()方法也会返回一个数组。这个数组的每一项都是对原始数组中同样位置的元素运行传入函数而返回的结果。例如，可以将一个数组中的每一项都乘以 2，并返回包含所有结果的数组，如下所示： let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; let mapResult = numbers.map((item, index, array) =&gt; item * 2); console.log(mapResult); // 2,4,6,8,10,8,6,4,2 以上代码返回了一个数组，包含原始数组中每个值乘以 2 的结果。这个方法非常适合创建一个与原始数组元素一一对应的新数组。 forEach()这个方法只会对每一项运行传入的函数，没有返回值。本质上，forEach()方法相当于使用 for 循环遍历数组 let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]; numbers.forEach((item, index, array) =&gt; { // 执行某些操作 }); 迭代器方法在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法：keys()、values()和 entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而 entries()返回索引/值对的迭代器： const a = ['foo', 'bar', 'baz', 'qux']; // 因为这些方法都返回迭代器，所以可以将它们的内容通过Array.from()直接转换为数组实例 const aKeys = Array.from(a.keys()); const aValues = Array.from(a.values()); const aEntries = Array.from(a.entries()); console.log(aKeys); // [0, 1, 2, 3] console.log(aValues); // ['foo', 'bar', 'baz', 'qux'] console.log(aEntries); // [[0, 'foo'], [1, 'bar'], [2, 'baz'], [3, 'qux']] 使用 ES6 的解构可以非常容易地在循环中拆分键/值对： const a = ['foo', 'bar', 'baz', 'qux']; for (const [idx, element] of a.entries()) { console.log(idx); console.log(element); } // 0 // foo // 1 // bar // 2 // baz // 3 // qux 归并方法ECMAScript 为数组提供了两个归并方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，并在此基础上构建一个最终返回值。reduce()方法从数组第一项开始遍历到最后一项。而 reduceRight()从最后一项开始遍历至第一项。 归并函数 reduce() 方法必须传入一个 **归并函数(reducer)**。归并函数接收 4 个参数： previousValue。这个值表示每次执行时的上一个值，在归并函数第 1 次执行时，这个值就是数组的第 1 个值（如果没有提供 initialValue 见下）。 currentValue。这个值表示每次执行时当前处理的值，在归并函数第 1 次执行时，这个值就是数组的第 2 个值（如果没有提供 initialValue 见下）。 currentIndex。这个值表示当前处理值在数组中的索引。 array。表示调用 reduce() 的数组本身。 初始值 此外，reduce() 方法可以选择性地传入一个 初始值(initialValue) ，当传入一个初始值时，第 1 次执行的 previousValue 为该初始值，currentValue 为数组的第 1 个值。 初始值是出于安全性考虑。这是因为如果数组为空且没有初始值，进行归并操作会抛出 TypeError。 如果数组仅有一个元素且没有初始值，或者提供了初始值但数组为空，那么该唯一值将被返回，归并操作不会得到执行。 推荐开发者在进行归并操作时提供初始值，这样就会避免报错。 来看下面的例子： const maxReducer = (pre, cur) =&gt; Math.max(pre.x, cur.x); // reduce() 没有初始值 [{x: 2}, {x: 22}, {x: 42}].reduce(maxReducer); // NaN [{x: 2}, {x: 22}].reduce(maxReducer); // 22 [{x: 2}].reduce(maxReducer); // { x: 2 } [].reduce(maxReducer); // TypeError 如果一开始就提供了初始值，就不会报错： [].reduce(maxReducer, -Infinity); // -Infinity 数组累加 可以使用 reduce()函数便捷地累加数组中所有数值，比如： let integers = [1, 2, 3, 4, 5]; let sum = integers.reduce((pre, cur) =&gt; pre + cur， 0); console.log(sum); // 15 第一次执行归并函数时，prev 是 1，cur 是 2。第二次执行时，prev 是 3（1 + 2），cur 是 3（数组第三项）。如此递进，直到把所有项都遍历一次，最后返回归并结果。 打平数组 结合 reduce() 和 concat() 方法可以便捷地将二维数组打平为一维数组： let arr = [1, [2, 3], 4, [5, 6]]; let flattenedArr = arr.reduce((pre, cur) =&gt; pre.concat(cur), []); console.log(flattenedArr); // [ 1, 2, 3, 4, 5, 6 ] 在第一次执行时，previousValue 为 []，currentValue 为 1，[].concat(1) 结果为 [1]。第 2 次执行时，previousValue 为 [1]，currentValue 为 [2,3]，[1].concat([2,3]) 结果为 [1,2,3]，以此类推。 数组计数 let letters = ['a', 'b', 'c', 'c', 'c', 'd', 'd']; let countedLetters = letters.reduce(function (countedLetters, letter) { if (letter in countedLetters) { countedLetters[letter]++; } else { countedLetters[letter] = 1; } return countedLetters; }, {}); console.log(countedLetters); // { a: 1, b: 1, c: 3, d: 2 } 在第 1 次执行时，previousValue 为 {}，currentValue 为 ‘a’，letters 中没有 ‘a’，故把属性 a 的值设为 1，结果为 {a: 1}。同理可得出，第 3 次执行的结果为 {a: 1, b: 1, c: 1}。第 4 次执行时，由于 letters 中有 c 属性，因此 c 属性的值自增。以此类推。 数组去重 let myArray = ['a', 'b', 'a', 'b', 'c', 'e', 'e', 'c', 'd', 'd', 'd', 'd']; let uniqueArr = myArray.reduce(function (uniqueArr, cur) { if (uniqueArr.indexOf(cur) === -1) { uniqueArr.push(cur); } return uniqueArr; }, []); console.log(uniqueArr); // [ 'a', 'b', 'c', 'e', 'd' ] 当然这种方法对 NaN 就有问题了，这是因为 indexOf 在进行搜索的比较时会使用 ===，而 NaN === NaN 返回 false。来看下面的例子： let NaNs = [NaN, NaN]; console.log(NaNs.indexOf(NaN)); // -1 尽管 NaNs 数组中有 2 个 NaN，但使用 indexOf() 进行搜索后，会得出-1，这表示 NaNs 中没有 NaN。 此时，使用 includes() 就可以避免这个问题： let arr = [1, 1, NaN, NaN]; let uniaueArr = arr.reduce( (pre, cur) =&gt; (pre.includes(cur) ? pre : [...pre, cur]), [], ); console.log(uniaueArr); // [1, NaN] 在这个例子中，第 1 次执行时，previousValue 为 []，currentValue 为 1，previousValue 中不包含 1，因此结果为 [1]。第 2 次执行时，previousValue 为 [1]，currentValue 为 1，此时包含 1 ，因此结果返回 [1]，同样的，第 4 次执行完后，得到 [1, NaN]。 注意：如果你正在使用一个可以兼容 Set 和 Array.from() 的环境，你可以使用 Array.from(new Set(array)) 来获得一个去重的数组。 复制与填充方法ES6 新增了两个方法：批量复制方法 copyWithin()，以及填充数组方法 fill()。这两个方法的函数签名类似，都需要指定既有数组实例上的一个范围，包含开始索引，不包含结束索引。使用这个方法不会改变数组的大小。 fill()使用 fill()方法可以向一个已有的数组中插入全部或部分相同的值。开始索引用于指定开始填充的位置，它是可选的。如果不提供结束索引，则一直填充到数组末尾。负值索引从数组末尾开始计算。也可以将负索引想象成数组长度加上它得到的一个正索引： const zeroes = [0, 0, 0, 0, 0]; // 用5 填充整个数组 zeroes.fill(5); console.log(zeroes); // [5, 5, 5, 5, 5] zeroes.fill(0); // 重置 // 用6 填充索引大于等于3 的元素 zeroes.fill(6, 3); console.log(zeroes); // [0, 0, 0, 6, 6] zeroes.fill(0); // 重置 // 用7 填充索引大于等于1 且小于3 的元素 zeroes.fill(7, 1, 3); console.log(zeroes); // [0, 7, 7, 0, 0]; zeroes.fill(0); // 重置 // 用8 填充索引大于等于1 且小于4 的元素 // (-4 + zeroes.length = 1) // (-1 + zeroes.length = 4) zeroes.fill(8, -4, -1); console.log(zeroes); // [0, 8, 8, 8, 0]; fill()静默忽略超出数组边界、零长度及方向相反的索引范围： const zeroes = [0, 0, 0, 0, 0]; // 索引过低，忽略 zeroes.fill(1, -10, -6); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引过高，忽略 zeroes.fill(1, 10, 15); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引反向，忽略 zeroes.fill(2, 4, 2); console.log(zeroes); // [0, 0, 0, 0, 0] // 索引部分可用，填充可用部分 zeroes.fill(4, 3, 10); console.log(zeroes); // [0, 0, 0, 4, 4] cpoyWithin()copyWithin()会按照指定范围浅复制数组中的部分内容，然后将它们插入到指定索引开始的位置。开始索引和结束索引则与 fill()使用同样的计算方法： let ints, reset = () =&gt; (ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]); reset(); // 从ints 中复制索引0 开始的内容，插入到索引5 开始的位置 // 在源索引或目标索引到达数组边界时停止 ints.copyWithin(5); console.log(ints); // [0, 1, 2, 3, 4, 0, 1, 2, 3, 4] reset(); // 从ints 中复制索引5 开始的内容，插入到索引0 开始的位置 ints.copyWithin(0, 5); console.log(ints); // [5, 6, 7, 8, 9, 5, 6, 7, 8, 9] reset(); // 从ints 中复制索引0 开始到索引3 结束的内容 // 插入到索引4 开始的位置 ints.copyWithin(4, 0, 3); console.log(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9] reset(); // JavaScript 引擎在插值前会完整复制范围内的值 // 因此复制期间不存在重写的风险 ints.copyWithin(2, 0, 6); console.log(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9] reset(); // 支持负索引值，与fill()相对于数组末尾计算正向索引的过程是一样的 ints.copyWithin(-4, -7, -3); console.log(ints); // [0, 1, 2, 3, 4, 5, 3, 4, 5, 6] copyWithin(); 静默忽略超出数组边界、零长度及方向相反的索引范围 [同fill()] 转换方法所有对象都有 toLocaleString()、toString()和 valueOf()方法。其中，valueOf()返回的还是数组本身。而 toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其 toString()方法，以得到最终的字符串。来看下面的例子： let colors = ['red', 'blue', 'green']; // 创建一个包含3 个字符串的数组 console.log(colors.toString()); // red,blue,green console.log(colors.valueOf()); // [ 'red', 'blue', 'green' ] 显式调用的 toString()返回了数组的字符串表示，即将所有字符串组合起来，以逗号分隔。 toLocaleString()以及 toString()都返回数组值的逗号分隔的字符串。如果想使用不同的分隔符，则可以使用 join()方法。join()方法接收一个参数，即字符串分隔符，返回包含所有项的字符串。来看下面的例子： let colors = ['red', 'green', 'blue']; console.log(colors.join(',')); // red,green,blue console.log(colors.join('||')); // red||green||blue 这里在 colors 数组上调用了 join()方法，得到了与调用 toString()方法相同的结果。传入逗号， 结果就是逗号分隔的字符串。最后一行给 join() 传入了双竖线， 得到了字符串’red||green||blue’。如果不给 join()传入任何参数，或者传入 undefined，则仍然使用逗号作为分隔符。 注意 如果数组中某一项是 null 或 undefined，则在 join()、toLocaleString()、toString()和 valueOf()返回的结果中会以空字符串表示。 参考文献javascript-learning/06章：集合引用类型.md at main · young-trigold/javascript-learning (github.com)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"}]},{"title":"计网之TCP与UDP","slug":"计网之TCP与UDP","date":"2021-10-21T11:36:12.000Z","updated":"2021-10-22T05:21:32.557Z","comments":true,"path":"posts/27732848.html","link":"","permalink":"https://robertjeff2.github.io/posts/27732848.html","excerpt":"","text":"TCP与UDP专题一、前言1.1 计算机网络协议模型 其中TCP、UDP位于TCP/IP协议中的传输层： 传输层的主要任务是为两台主机进程之间的通信提供服务，处理数据包错误、数据包次序，以及其他一些关键传输问题 传输层向高层屏蔽了下层数据通信的细节。因此，它是计算机通信体系结构中关键的一层。 二、概念2.1 UDPUDP（User Datagram Protocol），用户数据包协议，是一个简单的面向数据报的通信协议，即对应用层交下来的报文，不合并，不拆分，只是在其上面加上首部后就交给了下面的网络层 也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个报文 而对接收方，接到后直接去除首部，交给上面的应用层就完成任务 UDP报头包括4个字段，每个字段占用2个字节（即16个二进制位），标题短，开销小 特点如下： UDP 不提供复杂的控制机制，利用 IP 提供面向无连接的通信服务 传输途中出现丢包，UDP 也不负责重发 当包的到达顺序出现乱序时，UDP没有纠正的功能。 并且它是将应用程序发来的数据在收到的那一刻，立即按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况，UDP 也无法进行流量控制等避免网络拥塞行为 2.2 TCPTCP（Transmission Control Protocol），传输控制协议，是一种可靠、面向字节流的通信协议，把上面应用层交下来的数据看成无结构的字节流来发送 可以想象成流水形式的，发送方TCP会将数据放入“蓄水池”（缓存区），等到可以发送的时候就发送，不能发送就等着，TCP会根据当前网络的拥塞状态来确定每个报文段的大小 TCP报文首部有20个字节，额外开销大 特点如下： TCP充分地实现了数据传输时各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在 UDP 中都没有。 此外，TCP 作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。 根据 TCP 的这些机制，在 IP 这种无连接的网络上也能够实现高可靠性的通信（ 主要通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现） 三、二者区别两者区别如下表所示： TCP UDP 可靠性 可靠 不可靠 连接性 面向连接 无连接 报文 面向字节流 面向报文 效率 传输效率低 传输效率高 双共性 全双工 一对一、一对多、多对一、多对多 流量控制 滑动窗口 无 拥塞控制 慢开始、拥塞避免、快重传、快恢复 无 传输效率 慢 快 TCP 是面向连接的协议，建立连接3次握手、断开连接四次挥手，UDP是面向无连接，数据传输前后不连接连接，发送端只负责将数据发送到网络，接收端从消息队列读取 TCP 提供可靠的服务，传输过程采用流量控制、编号与确认、计时器等手段确保数据无差错，不丢失。UDP 则尽可能传递数据，但不保证传递交付给对方 TCP 面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用 TCP 只能点对点全双工通信。UDP 支持一对一、一对多、多对一和多对多的交互通信 两者应用场景如下图： TCP应用场景： 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。 UDP应用场景： 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。 四、TCP三次握手与四次挥手4.1 三次握手 三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。 过程如下： 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)，此时客户端处于 SYN_SENT 状态 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1作为ACK的值，此时服务器处于 SYN_RCVD 的状态 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。 上述每一次握手的作用如下： 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常 通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了 为什么要三次握手呢？两次不行吗？ 为了确认双方的接收能力和发送能力都正常 如果是两次握手，发送端可以确定自己发送的信息能对方能收到，也能确定对方发的包自己能收到，但接收端只能确定对方发的包自己能收到 无法确定自己发的包对方能收到 并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源 4.2 四次挥手tcp终止一个连接，需要经过四次挥手 过程如下： 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态 那为什么需要四次挥手呢？服务端在收到客户端断开连接Fin报文后，并不会立即关闭连接，而是先发送一个ACK包先告诉客户端收到关闭连接的请求，只有当服务器的所有报文发送完毕之后，才发送FIN报文断开连接，因此需要四次挥手。 等待2MSL的意义，如果不等待会怎样？如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL? 1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端 1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达 这就是等待 2MSL 的意义。 2MSL是多久？规范里2MSL是四分钟。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://robertjeff2.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"CSS之两栏三栏布局","slug":"CSS之两栏三栏布局","date":"2021-10-20T09:39:30.000Z","updated":"2021-10-20T11:27:22.060Z","comments":true,"path":"posts/bfdfcbd4.html","link":"","permalink":"https://robertjeff2.github.io/posts/bfdfcbd4.html","excerpt":"","text":"两栏、三栏布局一、概念两栏布局两栏布局实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满， 比如 Ant Design 文档，蓝色区域为主要内容布局容器，侧边栏为次要内容布局容器 这里称宽度较小的列父元素为次要布局容器，宽度较大的列父元素为主要布局容器 这种布局适用于内容上具有明显主次关系的网页 三栏布局三栏布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之 最常见的就是github： 二、两栏布局双栏布局非常常见，往往是以一个定宽栏和一个自适应的栏并排展示存在 实现思路也非常的简单： 浮动实现 使用 float 左浮左边栏 右边模块使用 margin-left 撑出内容块做内容展示 为父级元素添加BFC，防止下方元素飞到上方内容 &lt;style&gt; .box{ overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt; } .left { float: left; width: 200px; background-color: gray; height: 400px; } .right { margin-left: 210px; background-color: lightgray; height: 200px; } &lt;/style&gt; &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;左边&lt;/div&gt; &lt;div class=\"right\"&gt;右边&lt;/div&gt; &lt;/div&gt; flex弹性布局&lt;style&gt; .box{ display: flex; } .left { width: 100px; } .right { flex: 1; } &lt;/style&gt; &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;左边&lt;/div&gt; &lt;div class=\"right\"&gt;右边&lt;/div&gt; &lt;/div&gt; flex可以说是最好的方案了，代码少，使用简单 注意的是，flex容器的一个默认属性值:align-items: stretch; 这个属性导致了列等高的效果。 为了让两个盒子高度自动，需要设置: align-items: flex-start 三、三栏布局实现三栏布局中间自适应的布局方式有： 两边使用 float，中间使用 margin 两边使用 absolute，中间使用 margin display: table 实 flex实现 grid网格布局 两边使用 float，中间使用 margin需要将中间的内容放在html结构最后，否则右侧会臣在中间内容的下方 实现代码如下： &lt;style&gt; .wrap { background: #eee; overflow: hidden; &lt;!-- 生成BFC，计算高度时考虑浮动的元素 --&gt; padding: 20px; height: 200px; } .left { width: 200px; height: 200px; float: left; background: coral; } .right { width: 120px; height: 200px; float: right; background: lightblue; } .middle { margin-left: 220px; height: 200px; background: lightpink; margin-right: 140px; } &lt;/style&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;左侧&lt;/div&gt; &lt;div class=\"right\"&gt;右侧&lt;/div&gt; &lt;div class=\"middle\"&gt;中间&lt;/div&gt; &lt;/div&gt; 原理如下： 两边固定宽度，中间宽度自适应。 利用中间元素的margin值控制两边的间距 宽度小于左右部分宽度之和时，右侧部分会被挤下去 这种实现方式存在缺陷： 主体内容是最后加载的。 右边在主体内容之前，如果是响应式设计，不能简单的换行展示 两边使用 absolute，中间使用 margin基于绝对定位的三栏布局：注意绝对定位的元素脱离文档流，相对于最近的已经定位的祖先元素进行定位。无需考虑HTML中结构的顺序 &lt;style&gt; .container { position: relative; } .left, .right, .main { height: 200px; line-height: 200px; text-align: center; } .left { position: absolute; top: 0; left: 0; width: 100px; background: green; } .right { position: absolute; top: 0; right: 0; width: 100px; background: green; } .main { margin: 0 110px; background: black; color: white; } &lt;/style&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;左边固定宽度&lt;/div&gt; &lt;div class=\"right\"&gt;右边固定宽度&lt;/div&gt; &lt;div class=\"main\"&gt;中间自适应&lt;/div&gt; &lt;/div&gt; 实现流程： 左右两边使用绝对定位，固定在两侧。 中间占满一行，但通过 margin和左右两边留出10px的间隔 使用 display: table 实现&lt;style&gt; .container { height: 200px; line-height: 200px; text-align: center; display: table; table-layout: fixed; width: 100%; } .left, .right, .main { display: table-cell; } .left, .right { width: 100px; background: green; } .main { background: black; color: white; width: 100%; } &lt;/style&gt; &lt;div class=\"container\"&gt; &lt;div class=\"left\"&gt;左边固定宽度&lt;/div&gt; &lt;div class=\"main\"&gt;中间自适应&lt;/div&gt; &lt;div class=\"right\"&gt;右边固定宽度&lt;/div&gt; &lt;/div&gt;实现原理： 外层通过 display: table设置为表格，设置 table-layout: fixed表示列宽自身宽度决定，而不是自动计算。 内层的左中右通过 display: table-cell设置为表格单元。 左右设置固定宽度，中间设置 width: 100% 填充剩下的宽度 使用flex实现&lt;style type=\"text/css\"&gt; .wrap { display: flex; justify-content: space-between;&lt;--定义了子元素在主轴(横轴)上的对齐方式 } .left, .right, .middle { height: 100px; } .left { width: 200px; background: coral; } .right { width: 120px; background: lightblue; } .middle { background: #555; width: 100%; margin: 0 20px; } &lt;/style&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;左侧&lt;/div&gt; &lt;div class=\"middle\"&gt;中间&lt;/div&gt; &lt;div class=\"right\"&gt;右侧&lt;/div&gt; &lt;/div&gt;实现过程： 仅需将容器设置为display:flex;， 盒内元素两端对其，将中间元素设置为100%宽度，或者设为flex:1，即可填充空白 盒内元素的高度撑开容器的高度 优点： 结构简单直观 可以结合 flex的其他功能实现更多效果，例如使用 order属性调整显示顺序，让主体内容优先加载，但展示在中间 grid网格布局&lt;style&gt; .wrap { display: grid; width: 100%; grid-template-columns: 300px auto 300px; } .left, .right, .middle { height: 100px; } .left { background: coral; } .right { width: 300px; background: lightblue; } .middle { background: #555; } &lt;/style&gt; &lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt;左侧&lt;/div&gt; &lt;div class=\"middle\"&gt;中间&lt;/div&gt; &lt;div class=\"right\"&gt;右侧&lt;/div&gt; &lt;/div&gt; 标签用于展示行列数据，不适合用于布局。但是可以使用 display: table 来实现布局的效果","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://robertjeff2.github.io/tags/CSS/"}]},{"title":"CSS之盒子模型与BFC","slug":"CSS之盒子模型","date":"2021-10-20T09:13:21.000Z","updated":"2021-10-20T11:27:04.161Z","comments":true,"path":"posts/404ade06.html","link":"","permalink":"https://robertjeff2.github.io/posts/404ade06.html","excerpt":"","text":"盒子模型一、盒子模型是什么？就是用来装页面上的元素的矩形区域。CSS 中的盒子模型包括IE 盒子模型和标准的W3C 盒子模型。 box-sizing(有3 个值哦)：border-box,padding-box,content-box. 一个盒子由四个部分组成：content、padding、border、margin content，即实际内容，显示文本和图像 boreder，即边框，围绕元素内容的内边距的一条或多条线，由粗细、样式、颜色三部分组成 padding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的background属性影响 margin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域 二、IE盒子模型（怪异盒子模型） 从上图可以看到： 盒子总宽度 = width + margin; 盒子总高度 = height + margin; 也就是，width/height 包含了 padding和 border值 三、标准盒子模型（W3C）标准盒子模型，是浏览器默认的盒子模型 下面看看标准盒子模型的模型图： 从上图可以看到： 盒子总宽度 = width + padding + border + margin; 盒子总高度 = height + padding + border + margin 也就是，width/height 只是内容高度，不包含 padding 和 border值 浏览器默认为w3c标准模型 四、Box-sizingCSS 中的 box-sizing 属性定义了引擎应该如何计算一个元素的总宽度和总高度. 语法： box-sizing: content-box|border-box|inherit: content-box 默认值，元素的 width/height 不包含padding，border，与标准盒子模型表现一致 border-box 元素的 width/height 包含 padding，border，与怪异盒子模型表现一致 inherit 指定 box-sizing 属性的值，应该从父元素继承 五、区别：从图中我们可以看出，这两种盒子模型最主要的区别就是width 的包含范围，在 标准的盒子模型中，width 指content 部分的宽度，在IE 盒子模型中，width 表示 content+padding+border 这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差 异：标准盒子模型的盒子宽度：左右border+左右padding+width IE 盒子模型的盒子宽度：width 在CSS3 中引入了box-sizing 属性，box-sizing:content-box; 表示的是w3c 标准盒子模型， box-sizing:border-box表示IE的盒子模型 最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右 padding+width。 六、盒模型的边距重叠主要分三种重叠， 重叠规则：一大一小取最大,一正一负取和 相邻元素之间的重叠 父子嵌套的重叠 空的块级元素 1.相邻元素之间 // css * { margin:0; padding:0; border:0; } #d1 { width:100px; height:100px; margin-top:20px; margin-bottom:20px; background-color:red; } #d2 { width:100px; height:100px; margin-top:10px; background-color:blue; } // html &lt;div id=\"d1\"&gt; &lt;/div&gt; &lt;div id=\"d2\"&gt; &lt;/div&gt; 2.父子嵌套重叠 // css * { margin:0; padding:0; border:0; } #outer { width:300px; height:300px; background-color:red; margin-top:20px; } #inner { width:50px; height:50px; background-color:blue; margin-top:10px; } // html &lt;div id=\"outer\"&gt; &lt;div id=\"inner\"&gt; &lt;/div&gt; &lt;/div&gt; 3.空的块级元素 BFC一、概念什么是BFC 块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 渲染规则： 内部的盒子会在垂直方向上一个接一个的放置 对于同一个BFC的俩个相邻的盒子的margin会发生重叠，与方向无关。 每个元素的左外边距与包含块的左边界相接触（从左到右），即使浮动元素也是如此 BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然 BFC目的是形成一个相对于外界完全独立的空间，让内部的子元素不会影响到外部的元素 二、触发条件触发BFC的条件包含不限于： 根元素，即HTML元素 浮动元素：float值为left、right overflow值不为 visible，为 auto、scroll、hidden display的值为inline-block、inltable-cell、table-caption、table、inline-table、flex、inline-flex、grid、inline-grid position的值为absolute或fixed 三、应用场景防止margin重叠（塌陷）&lt;style&gt; p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; } &lt;/style&gt; &lt;body&gt; &lt;p&gt;Haha&lt;/p &gt; &lt;p&gt;Hehe&lt;/p &gt; &lt;/body&gt; 页面显示如下 两个p元素之间的距离为100px，发生了margin重叠（塌陷），以最大的为准，如果第一个P的margin为80的话，两个P之间的距离还是100，以最大的为准。 前面讲到，同一个BFC的俩个相邻的盒子的margin会发生重叠 可以在p外面包裹一层容器，并触发这个容器生成一个BFC，那么两个p就不属于同一个BFC，则不会出现margin重叠 &lt;style&gt; .wrap { overflow: hidden;// 新的BFC } p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; } &lt;/style&gt; &lt;body&gt; &lt;p&gt;Haha&lt;/p &gt; &lt;div class=\"wrap\"&gt; &lt;p&gt;Hehe&lt;/p &gt; &lt;/div&gt; &lt;/body&gt; 此时，margin便不会发生重叠： 清除内部浮动例子代码如下： &lt;style&gt; .par { border: 5px solid #fcc; width: 300px; } .child { border: 5px solid #f66; width:100px; height: 100px; float: left; } &lt;/style&gt; &lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 页面显示如图： 而BFC在计算高度时，浮动元素也会参与，所以我们可以触发.par元素产生BFC，则内部浮动元素计算高度时候也会计算 .par { overflow: hidden; } 最终实现了清除浮动的效果： 自适应多栏布局例子代码： &lt;style&gt; body { width: 300px; position: relative; } .aside { width: 100px; height: 150px; float: left; background: #f66; } .main { height: 200px; background: #fcc; } &lt;/style&gt; &lt;body&gt; &lt;div class=\"aside\"&gt;&lt;/div&gt; &lt;div class=\"main\"&gt;&lt;/div&gt; &lt;/body&gt; 页面显示如图所示： 前面讲到，每个元素的左外边距与包含块的左边界相接触 因此，虽然.aslide为浮动元素，但是main的左边依然会与包含块的左边相接触 而BFC的区域不会与浮动盒子重叠 所以我们可以通过触发main生成BFC，以此适应两栏布局 .main { overflow: hidden; } 这时候，新的BFC不会与浮动的.aside元素重叠。因此会根据包含块的宽度，和.aside的宽度，自动变窄 效果如下：","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://robertjeff2.github.io/tags/CSS/"}]},{"title":"JavaScript中的this","slug":"JavaScript中的this","date":"2021-10-18T12:51:42.000Z","updated":"2021-10-26T12:47:58.298Z","comments":true,"path":"posts/a5ceba90.html","link":"","permalink":"https://robertjeff2.github.io/posts/a5ceba90.html","excerpt":"","text":"问：如何判断this的指向？ 在全局环境中调用就指向 window。 作为对象的方法调用就指向该对象。 作为构造函数调用就指向这个新创建的对象。 可以使用 apply,call,bind 改变 this 指向。 箭头函数中的 this 与定义时所处的上下文绑定，且不能被改变， 箭头函数 this 指向取决于它外层找到的离它最近的第一个非箭头函数的 this。 绑定方式优先级的先后顺序： 箭头函数 -&gt; new绑定 -&gt; 显示绑定call/bind/apply -&gt; 隐式绑定 -&gt; 默认绑定 一、定义函数的 this 关键字在 JavaScript 中的表现略有不同，此外，在严格模式和非严格模式之间也会有一些差别 无论是否在严格模式下，在全局执行环境中(任何函数体外部)this都指向全局对象 在绝大多数情况下，函数的调用方式决定了 this 的值（运行时绑定） this 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象 example： function baz() { // 当前调用栈是：baz // 因此，当前调用位置是全局作用域 console.log( \"baz\" ); bar(); // &lt;-- bar的调用位置 } function bar() { // 当前调用栈是：baz --&gt; bar // 因此，当前调用位置在baz中 console.log( \"bar\" ); foo(); // &lt;-- foo的调用位置 } function foo() { // 当前调用栈是：baz --&gt; bar --&gt; foo // 因此，当前调用位置在bar中 console.log( \"foo\" ); } baz(); // &lt;-- baz的调用位置 this 在函数执行过程中，this 一旦被确定了，就不可以再更改 var a = 10; var obj = { a: 20 } function fn() { this = obj; // 修改this，运行后会报错 console.log(this.a); } fn(); this在类中this在类中的表现与在函数中类似，因为类本质上也是函数。 在类的构造函数中，this 是一个常规对象。类中所有非静态的方法都会被添加到 this 的原型中： class Example { constructor() { const proto = Object.getPrototypeOf(this); console.log(Object.getOwnPropertyNames(proto)); } first(){} second(){} static third(){} } new Example(); // ['constructor', 'first', 'second'] 二、具体情况分析apply、call方法在非严格模式下使用call和apply时，如果用做this值不是对象，则会被尝试转换为对象。 null和 undefined会被转换为全局对象 function bar() { console.log(Object.prototype.toString.call(this)); } bar.call(7); // [object Number] bar.call('foo'); // [object String] bar.call(undefined); // [object global] bind方法ECMAScript 5 引入了 Function.prototype.bind()。调用 f.bind(someObject) 会创建一个与 f 具有相同函数体和作用域的函数，但是在这个新函数中，this 将永久地被绑定到了 bind 的第一个参数，无论这个函数是如何被调用的。 function f(){ return this.a; } var g = f.bind({a:\"azerty\"}); console.log(g()); // azerty var h = g.bind({a:'yoo'}); // bind只生效一次！ console.log(h()); // azerty var o = {a:37, f:f, g:g, h:h}; console.log(o.a, o.f(), o.g(), o.h()); // 37, 37, azerty, azerty 箭头函数在箭头函数中，this 与封闭词法环境的 this 保持一致。在全局代码中，它将被设置为全局对象： 注意：如果将 this 传递给 call、bind、或者 apply 来调用箭头函数，它将被忽略。不过你仍然可以为调用添加参数，不过第一个参数（thisArg）应该设置为 null。 // 创建一个含有bar方法的obj对象， // bar返回一个函数， // 这个函数返回this， // 这个返回的函数是以箭头函数创建的， // 所以它的this被永久绑定到了它外层函数的this。 // bar的值可以在调用中设置，这反过来又设置了返回函数的值。 var obj = { bar: function() { var x = (() =&gt; this); return x; } }; // 作为obj对象的一个方法来调用bar，把它的this绑定到obj。 // 将返回的函数的引用赋值给fn。 var fn = obj.bar(); // 直接调用fn而不设置this， // 通常(即不使用箭头函数的情况)默认为全局对象 // 若在严格模式则为undefined console.log(fn() === obj); // true // 但是注意，如果你只是引用obj的方法， // 而没有调用它 var fn2 = obj.bar; // 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。 console.log(fn2()() == window); // true 在上面的例子中，一个赋值给了 obj.bar 的函数（称为匿名函数 A），返回了另一个箭头函数（称为匿名函数 B）。因此，在 A 调用时，函数 B 的 this 被永久设置为 obj.bar（函数 A）的 this。当返回的函数（函数 B）被调用时，它 this 始终是最初设置的。在上面的代码示例中，函数 B 的 this 被设置为函数 A 的 this，即 obj，所以即使被调用的方式通常将其设置为 undefined 或全局对象（或者如前面示例中的其他全局执行环境中的方法），它的 this 也仍然是 obj 。 作为对象的方法当函数作为对象里的方法被调用时，this 被设置为调用该函数的对象。 下面的例子中，当 o.f() 被调用时，函数内的 this 将绑定到 o 对象。 var o = { prop: 37, f: function() { return this.prop; } }; console.log(o.f()); // 37 //可以理解为 o.f().call(o) 原型链中的this对于在对象原型链上某处定义的方法，同样的概念也适用。如果该方法存在于一个对象的原型链上，那么 this 指向的是调用这个方法的对象，就像该方法就在这个对象上一样。 var o = { f: function() { return this.a + this.b; } }; var p = Object.create(o); p.a = 1; p.b = 4; console.log(p.f()); // 5 在这个例子中，对象 p 没有属于它自己的 f 属性，它的 f 属性继承自它的原型。虽然最终是在 o 中找到 f 属性的，这并没有关系；查找过程首先从 p.f 的引用开始，所以函数中的 this 指向 p。也就是说，因为 f 是作为 p 的方法调用的，所以它的 this 指向了 p。这是 JavaScript 的原型继承中的一个有趣的特性。 构造函数中当一个函数用作构造函数时（使用 new关键字），它的 this 被绑定到正在构造的新对象。 虽然构造函数返回的默认值是 this 所指的那个对象，但它仍可以手动返回其他的对象（如果返回值不是一个对象，则返回 this 对象）。 /* * 构造函数这样工作: * * function MyConstructor(){ * // 函数实体写在这里 * // 根据需要在this上创建属性，然后赋值给它们，比如： * this.fum = \"nom\"; * // 等等... * * // 如果函数具有返回对象的return语句， * // 则该对象将是 new 表达式的结果。 * // 否则，表达式的结果是当前绑定到 this 的对象。 * //（即通常看到的常见情况）。 * } */ function C(){ this.a = 37; } var o = new C(); console.log(o.a); // logs 37 function C2(){ this.a = 37; return {a:38}; } o = new C2(); console.log(o.a); // logs 38 在刚刚的例子中（C2），因为在调用构造函数的过程中，手动的设置了返回对象，与 this 绑定的默认对象被丢弃了。（这基本上使得语句 “this.a = 37;” 成了 “僵尸” 代码，实际上并不是真正的 “僵尸”，这条语句执行了，但是对于外部没有任何影响，因此完全可以忽略它）。 DOM事件处理函数当函数被用作事件处理函数时，它的 this 指向触发事件的元素（一些浏览器在使用非 addEventListener 的函数动态地添加监听函数时不遵守这个约定）。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"}]},{"title":"elementplus踩坑","slug":"elementplus踩坑","date":"2021-09-20T07:29:24.000Z","updated":"2021-10-18T12:52:24.936Z","comments":true,"path":"posts/753e8c51.html","link":"","permalink":"https://robertjeff2.github.io/posts/753e8c51.html","excerpt":"","text":"坑一：elememt-plus 版本问题在引入element-plus插件时的坑 视频版本是1.0.2beta64 此时通过npm安装的最新版本为1.1.0beta12 然而组件库在1.1.0版本做了一次breaking changes 修改了引入的方式 通过查阅文档后修复 Breaking changes made in 1.1.0-beta.1 · Discussion #3020 · element-plus/element-plus (github.com) 坑二 还是element-plus问题没安装之前一切正常 安装好element-plus后 npm run serve 直接报错 vue项目引入ElementUI-plus运行npm run serve后出现报错，网页内容无法显示： “export ‘createElementBlock‘ (imported as ‘_createElementBlock‘) was not found in ‘vue‘ 进度98% 大概跟导包方式有关系 解决方案：升级vue版本 升级vue 到最新版本 执行 npm install vue@3.2.4 –force 升级后报错消失 网页正常显示 这个element-plus 更新太快了 让我看一个月前的课程看起来像是一年前的一样hhhh","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"https://robertjeff2.github.io/tags/vue3/"}]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://robertjeff2.github.io/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"https://robertjeff2.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://robertjeff2.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://robertjeff2.github.io/tags/LeetCode/"},{"name":"CSS","slug":"CSS","permalink":"https://robertjeff2.github.io/tags/CSS/"},{"name":"vue3","slug":"vue3","permalink":"https://robertjeff2.github.io/tags/vue3/"}]}