[{"id":0,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! 🎁","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"设计模式","content":"#\n\n设计模式是软件开发中常见问题的典型解决方案。每个模式都像一个蓝图，可以通过自定义来解决代码中的特定设计问题。在前端开发中，设计模式帮助我们编写更加可维护、可扩展\n的代码。\n\n\n设计模式的重要性#\n\n在前端面试中，设计模式是一个重要的考察点，主要关注以下几个方面：\n\n 1. 代码复用性和可维护性：通过合适的设计模式，可以提高代码的复用性，降低维护成本\n 2. 解耦和扩展性：好的设计模式可以实现模块间的解耦，使系统更容易扩展\n 3. 团队协作：设计模式提供了一种通用的解决方案，有助于团队成员之间的沟通\n 4. 性能优化：某些设计模式（如单例、享元模式）可以帮助优化应用性能\n\n\n选择设计模式的原则#\n\n在实际开发中，选择合适的设计模式需要考虑以下因素：\n\n 1. 场景适用性：不同的设计模式适用于不同的问题场景\n 2. 复杂度权衡：避免过度设计，在简单性和扩展性之间找到平衡\n 3. 团队水平：考虑团队对设计模式的理解和接受程度\n 4. 维护成本：评估采用某种设计模式后的长期维护成本\n\n\n设计模式分类#\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n前端开发中的最佳实践#\n\n 1. 组件设计\n    \n    * 使用工厂模式创建可配置的组件\n    * 使用装饰器模式增强组件功能\n    * 使用组合模式构建组件树\n\n 2. 状态管理\n    \n    * 使用单例模式实现全局状态\n    * 使用观察者模式处理状态变化\n    * 使用代理模式实现响应式\n\n 3. 数据处理\n    \n    * 使用适配器模式处理 API 数据\n    * 使用策略模式处理表单验证\n    * 使用命令模式处理用户操作","routePath":"/notes/design-pattern/","lang":"","toc":[{"text":"设计模式的重要性","id":"设计模式的重要性","depth":2,"charIndex":90},{"text":"选择设计模式的原则","id":"选择设计模式的原则","depth":2,"charIndex":292},{"text":"设计模式分类","id":"设计模式分类","depth":2,"charIndex":448},{"text":"创建型模式","id":"创建型模式","depth":3,"charIndex":458},{"text":"结构型模式","id":"结构型模式","depth":3,"charIndex":616},{"text":"行为型模式","id":"行为型模式","depth":3,"charIndex":820},{"text":"创建型模式","id":"创建型模式-1","depth":3,"charIndex":1012},{"text":"结构型模式","id":"结构型模式-1","depth":3,"charIndex":1170},{"text":"行为型模式","id":"行为型模式-1","depth":3,"charIndex":1374},{"text":"前端开发中的最佳实践","id":"前端开发中的最佳实践","depth":2,"charIndex":1566}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"发布订阅模式","content":"#\n\n\n简介#\n\n发布-订阅模式（Pub-Sub）是一种设计模式，用于在对象之间实现松耦合的通信。它允许一个对象（发布者）向多个对象（订阅者）发送消息，而发布者和订阅者之间不需要\n直接知道对方的存在。订阅者可以订阅感兴趣的事件，发布者可以在事件发生时通知所有订阅者。\n\n\n适用场景#\n\n这种模式在前端开发中非常常见，比如：\n\n事件驱动编程：DOM 事件（如 click、input）就是典型的发布-订阅模式。\n\n状态管理：在 Vue 或 React 中，全局状态管理工具（如 Vuex、Redux）的核心思想就是基于发布-订阅模式。\n\n组件通信：父子组件、兄弟组件之间的通信可以通过自定义事件（如 Vue 的 $emit 和 $on）实现。\n\n异步任务管理：比如消息队列、WebSocket 消息推送等。\n\n\n手写代码实现#\n\n\n\n * events 对象：用于存储事件名称和对应的回调函数列表。\n * subscribe 方法：允许订阅者订阅某个事件，并将回调函数添加到事件列表中。\n * publish 方法：当事件被触发时，遍历并执行所有订阅该事件的回调函数。\n * unsubscribe 方法：允许订阅者取消订阅，移除指定的回调函数。\n\n\n举例说明#\n\n可以用它来实现一个简单的消息通知系统\n\n\n\n\n扩展点#\n\n * 性能优化：如果事件列表很大，如何优化回调函数的执行效率？\n   \n   > 可以通过限制回调函数的数量、使用异步执行（如 setTimeout 或 Promise）来避免阻塞主线程。\n\n * 一次性订阅：如何实现只触发一次的事件订阅？\n   \n   > 可以在 subscribe 方法中添加一个标志位，执行一次后自动取消订阅。\n\n * 错误处理：如何处理回调函数中的错误？\n   \n   > 可以在 publish 方法中添加 try-catch，确保一个回调函数的错误不会影响其他回调函数的执行。\n\n\n总结#\n\n发布-订阅模式的优点是实现了对象之间的解耦，让代码更易于维护和扩展，特别适合处理复杂的异步通信场景。","routePath":"/notes/design-pattern/pubSub","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"适用场景","id":"适用场景","depth":2,"charIndex":135},{"text":"手写代码实现","id":"手写代码实现","depth":2,"charIndex":354},{"text":"举例说明","id":"举例说明","depth":2,"charIndex":524},{"text":"扩展点","id":"扩展点","depth":2,"charIndex":554},{"text":"总结","id":"总结","depth":2,"charIndex":816}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"面试常见手写代码","content":"#\n\n这个分类主要记录前端开发中常见的手写代码实现，包括但不限于：\n\n * 防抖节流\n * 深浅拷贝\n * Promise 实现\n * 数组方法实现\n * 对象方法实现\n * 函数柯里化\n * 事件总线\n * 观察者模式\n\n这些代码实现不仅是面试中的高频考点，也是加深对 JavaScript 理解的重要方式。每个实现都会包含详细的代码注释和实现思路说明，帮助更好地理解其中的原理。","routePath":"/notes/handwriting/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"手写防抖节流","content":"#\n\n> 首先，防抖和节流都是用来优化高频触发的事件，比如滚动、输入或者窗口调整，防止这些事件处理函数被频繁调用，影响性能。不过它们的实现方式和应用场景不同，我得先搞\n> 清楚两者的区别。防抖（Debounce）的话，我记得是当事件被触发后，一定时间内的多次触发只会执行最后一次，或者只在开始时执行一次。比如搜索框输入，用户停止\n> 输入一段时间后才发送请求，避免每次按键都请求。而节流（Throttle）则是每隔一定时间执行一次，不管事件触发有多频繁，比如滚动事件，每隔 200ms\n> 执行一次处理函数。\n\n\n回答步骤#\n\n 1. 解释防抖和节流的定义和区别。\n\n 2. 写出基本的实现代码，并解释每一步的作用。\n\n 3. 比较不同实现方式的差异。\n\n 4. 举例说明应用场景。\n\n\n1. 防抖（Debounce）#\n\n定义：高频事件触发后，在指定时间内只执行最后一次。若在等待期内再次触发，则重新计时。\n\n应用场景：搜索框输入联想、窗口大小调整（resize）。\n\n实现思路：\n\n * 利用定时器，每次触发时重置定时。\n * 支持立即执行（首次触发立即执行，后续需等待停止触发）。\n\n代码示例：\n\n\n\n关键点：\n\n * 使用闭包保存 timeout。\n * 立即执行逻辑：首次触发且未在等待期内时执行。\n * clearTimeout 确保每次触发重置计时。\n\n--------------------------------------------------------------------------------\n\n\n2. 节流（Throttle）#\n\n定义：高频事件触发时，每隔指定时间执行一次，稀释执行频率。\n\n应用场景：滚动加载（scroll）、高频点击（如抢购按钮）。\n\n实现思路：\n\n * 时间戳版：记录上次执行时间，若间隔超过阈值则执行。\n * 定时器版：延迟执行，执行后重置定时器。\n * 结合版（推荐）：首次立即执行，最后一次触发延迟执行。\n\n代码示例（结合版）：\n\n\n\n关键点：\n\n * remaining 计算剩余等待时间。\n * 首次触发立即执行，最后一次触发在剩余时间后执行。\n * 定时器与时间戳结合，确保首尾触发均被执行。\n\n--------------------------------------------------------------------------------\n\n\n3. 对比与总结#\n\n特性     防抖（DEBOUNCE）    节流（THROTTLE）\n执行时机   最后一次触发后等待结束执行   固定间隔执行\n应用场景   搜索联想、resize     滚动事件、高频点击\n核心逻辑   重置定时器           时间间隔控制\n\n--------------------------------------------------------------------------------\n\n回答技巧：\n\n 1. 先解释概念：明确防抖和节流的定义及区别。\n 2. 手写代码：逐步写出代码并解释关键步骤（如闭包、定时器、this 绑定）。\n 3. 举例场景：结合具体场景说明为何选择防抖或节流。\n 4. 扩展优化：提及取消功能（如 debounced.cancel()）或参数配置（如 leading 和 trailing）。\n\n通过清晰的结构和代码示例，展示对性能优化问题的深入理解。","routePath":"/notes/handwriting/throttle","lang":"","toc":[{"text":"回答步骤","id":"回答步骤","depth":2,"charIndex":256},{"text":"**1. 防抖（Debounce）**","id":"1-防抖debounce","depth":3,"charIndex":-1},{"text":"**2. 节流（Throttle）**","id":"2-节流throttle","depth":3,"charIndex":-1},{"text":"**3. 对比与总结**","id":"3-对比与总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"学习笔记","content":"#\n\n欢迎来到我的博客！这里记录了我在学习过程中的心得体会和技术积累。\n\n\n关于这些笔记#\n\n这些笔记是我在学习过程中的总结和思考。我会不断更新和完善这些内容，希望能够帮助到同样在学习的你。如果你发现任何问题或有任何建议，欢迎与我交流。","routePath":"/notes/","lang":"","toc":[{"text":"关于这些笔记","id":"关于这些笔记","depth":2,"charIndex":37}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"前端面试准备","content":"#\n\n\n一、技术基础强化（核心必考）#\n\n1. JavaScript 底层原理#\n\n * 闭包/作用域链：手写闭包场景，解释内存泄漏风险。\n * 原型链与继承：实现寄生组合继承，对比 ES6 class 差异。\n * Event Loop：结合宏任务/微任务分析代码执行顺序，解释 Promise、async/await 的底层逻辑。\n * 手写高频 API：实现 Promise.all、深拷贝、防抖/节流、柯里化函数 等。\n\n2. 框架核心原理#\n\n * React：\n   * 虚拟 DOM Diff 算法优化逻辑。\n   * Hooks 原理（如 useState 如何绑定到 Fiber 节点）。\n   * 性能优化手段（React.memo、useMemo 使用场景）。\n * Vue：\n   * 响应式原理（Vue2 的 Object.defineProperty 与 Vue3 的 Proxy 对比）。\n   * 模板编译流程（AST 转换到 render 函数）。\n   * 手写简易版 Vue 响应式系统。\n\n3. 浏览器与网络#\n\n * 渲染机制：从输入 URL 到页面渲染的完整流程，关键优化点（如 CRP 优化）。\n * 缓存策略：强缓存与协商缓存的 Header 字段，Service Worker 应用场景。\n * 跨域解决方案：CORS 预检请求细节，JSONP 安全性问题。\n\n4. 前端工程化#\n\n * Webpack：\n   * 打包流程（Loader 与 Plugin 的区别）。\n   * 优化配置（Tree Shaking 原理、Code Splitting 策略）。\n * 性能监控：\n   * 使用 Lighthouse 分析性能指标（FCP、LCP、CLS）。\n   * 实现前端错误监控（SourceMap 还原线上错误）。\n\n--------------------------------------------------------------------------------\n\n\n二、项目经验深挖（高频追问点）#\n\n1. 项目难点与解决方案#\n\n * 典型问题：\n   * “介绍一个你主导的复杂项目，如何设计技术方案？”\n   * “遇到过哪些性能瓶颈？如何定位并解决？”\n * 回答策略：\n   * 使用 STAR 法则（背景、任务、行动、结果）。\n   * 量化成果：如“首屏加载时间从 3s 优化至 1.2s”。\n\n2. 技术选型与权衡#\n\n * 准备问题：\n   * “为什么选择 React 而不是 Vue？”\n   * “微前端方案（如 qiankun）的落地挑战是什么？”\n * 加分回答：\n   * 结合业务场景（如团队协作成本、生态支持度）分析。\n\n3. 协作与流程优化#\n\n * 举例说明：\n   * 如何推动团队落地代码规范（ESLint + Git Hooks）。\n   * 设计前端埋点系统或 CI/CD 自动化流程。\n\n--------------------------------------------------------------------------------\n\n\n三、算法与数据结构（大厂必考）#\n\n1. 刷题重点#\n\n * 高频题型：数组/字符串操作、链表、二叉树、DFS/BFS、动态规划。\n * 前端相关题：DOM 树遍历（递归/迭代）、模板解析（栈结构应用）。\n\n2. 刷题策略#\n\n * LeetCode 精选：优先刷 Hot 100 和前端厂题库（如字节、阿里）。\n * 手写代码规范：注重边界条件处理，代码可读性（命名、注释）。\n\n--------------------------------------------------------------------------------\n\n\n四、系统设计能力（高阶岗位重点）#\n\n1. 前端架构设计#\n\n * 场景题：\n   * “设计一个高并发场景下的前端缓存方案。”\n   * “如何实现跨团队组件库的灰度发布？”\n * 考察点：模块拆分、状态管理、异常兜底方案。\n\n2. 全栈能力验证#\n\n * 准备方向：\n   * 实现一个 SSR（服务端渲染）方案。\n   * 设计一个短链生成系统的前后端架构。\n\n--------------------------------------------------------------------------------\n\n\n五、行为面试与软技能#\n\n1. 常见问题#\n\n * “为什么离开上一家公司？”\n * “如何推动技术方案在团队中落地？”\n * “与产品经理发生分歧时如何处理？”\n\n2. 回答技巧#\n\n * 避坑指南：避免抱怨前公司，聚焦个人成长诉求。\n * 展示潜力：强调自主学习（如“通过研究 WebAssembly 优化项目性能”）。\n\n--------------------------------------------------------------------------------\n\n\n六、简历优化与面试模拟#\n\n1. 简历打磨#\n\n * 突出亮点：使用关键词如“性能优化 40%”“主导组件库重构”。\n * 数据支撑：如“日均 PV 1000 万+的系统稳定性保障”。\n\n2. 模拟面试#\n\n * 技术模拟：找同行模拟框架原理追问（如“React Fiber 如何中断/恢复任务”）。\n * 压力测试：练习在白板上手写代码并解释思路。\n\n--------------------------------------------------------------------------------\n\n\n七、资源推荐#\n\n * 书籍：《JavaScript 高级程序设计》《前端架构设计》\n * 学习平台：极客时间（前端进阶课）、Frontend Masters\n * 工具：CodeSandbox 在线编码练习、Chrome DevTools 性能分析实战\n\n--------------------------------------------------------------------------------\n\n\n八、面试后复盘#\n\n * 记录问题：整理被问倒的技术点，针对性补漏。\n * 横向对比：分析不同公司对“3 年经验前端”的能力侧重（如大厂重算法，创业公司重落地速度）。","routePath":"/notes/interview/","lang":"","toc":[{"text":"**一、技术基础强化（核心必考）**","id":"一技术基础强化核心必考","depth":3,"charIndex":-1},{"text":"**1. JavaScript 底层原理**","id":"1-javascript-底层原理","depth":4,"charIndex":-1},{"text":"**2. 框架核心原理**","id":"2-框架核心原理","depth":4,"charIndex":-1},{"text":"**3. 浏览器与网络**","id":"3-浏览器与网络","depth":4,"charIndex":-1},{"text":"**4. 前端工程化**","id":"4-前端工程化","depth":4,"charIndex":-1},{"text":"**二、项目经验深挖（高频追问点）**","id":"二项目经验深挖高频追问点","depth":3,"charIndex":-1},{"text":"**1. 项目难点与解决方案**","id":"1-项目难点与解决方案","depth":4,"charIndex":-1},{"text":"**2. 技术选型与权衡**","id":"2-技术选型与权衡","depth":4,"charIndex":-1},{"text":"**3. 协作与流程优化**","id":"3-协作与流程优化","depth":4,"charIndex":-1},{"text":"**三、算法与数据结构（大厂必考）**","id":"三算法与数据结构大厂必考","depth":3,"charIndex":-1},{"text":"**1. 刷题重点**","id":"1-刷题重点","depth":4,"charIndex":-1},{"text":"**2. 刷题策略**","id":"2-刷题策略","depth":4,"charIndex":-1},{"text":"**四、系统设计能力（高阶岗位重点）**","id":"四系统设计能力高阶岗位重点","depth":3,"charIndex":-1},{"text":"**1. 前端架构设计**","id":"1-前端架构设计","depth":4,"charIndex":-1},{"text":"**2. 全栈能力验证**","id":"2-全栈能力验证","depth":4,"charIndex":-1},{"text":"**五、行为面试与软技能**","id":"五行为面试与软技能","depth":3,"charIndex":-1},{"text":"**1. 常见问题**","id":"1-常见问题","depth":4,"charIndex":-1},{"text":"**2. 回答技巧**","id":"2-回答技巧","depth":4,"charIndex":-1},{"text":"**六、简历优化与面试模拟**","id":"六简历优化与面试模拟","depth":3,"charIndex":-1},{"text":"**1. 简历打磨**","id":"1-简历打磨","depth":4,"charIndex":-1},{"text":"**2. 模拟面试**","id":"2-模拟面试","depth":4,"charIndex":-1},{"text":"**七、资源推荐**","id":"七资源推荐","depth":3,"charIndex":-1},{"text":"**八、面试后复盘**","id":"八面试后复盘","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"问题整理","content":"#\n\n\n项目中遇到的最大挑战是什么,后来如何解决的#","routePath":"/notes/interview/review","lang":"","toc":[{"text":"项目中遇到的最大挑战是什么,后来如何解决的","id":"项目中遇到的最大挑战是什么后来如何解决的","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"React 基础","content":"#\n\n\n认识语法#\n\n\nJSX 语法#\n\n * JSX 是 JavaScript 的语法扩展，允许在 JavaScript 中编写类似 HTML 的代码\n * JSX 会被编译为 React.createElement() 调用\n * JSX 中使用大括号 {} 嵌入 JavaScript 表达式\n\n\n\n\n组件基础#\n\n * 函数组件：使用函数声明的简单组件\n * 类组件：使用 class 关键字声明，继承自 React.Component\n * 组件名称必须以大写字母开头\n\n\n\n\nProps 和 State#\n\nProps#\n\n * Props 是只读的，用于组件间数据传递\n * Props 可以传递任意类型的数据，包括函数和 JSX\n\n\n\nState#\n\n * State 用于管理组件内部状态\n * 使用 useState Hook 或 class 组件中的 setState 更新状态\n * State 更新可能是异步的\n\n\n\n\n生命周期#\n\n函数组件（Hooks）#\n\n * useEffect：处理副作用\n * useLayoutEffect：同步执行副作用\n * 自定义 Hooks：复用状态逻辑\n\n\n\n类组件#\n\n * 挂载阶段：constructor -> render -> componentDidMount\n * 更新阶段：render -> componentDidUpdate\n * 卸载阶段：componentWillUnmount\n\n\n\n\n事件处理#\n\n * React 事件使用驼峰命名\n * 事件处理器接收合成事件对象（SyntheticEvent）\n * 注意绑定 this 的问题（箭头函数或 bind）\n\n\n\n\n条件渲染#\n\n * 使用 if 语句或三元运算符\n * 使用逻辑运算符 &&\n * 防止组件返回 null 导致的问题\n\n\n\n\n列表渲染#\n\n * 使用 map 方法渲染列表\n * key 属性的重要性和正确使用\n * 避免使用索引作为 key\n\n","routePath":"/notes/react/react","lang":"","toc":[{"text":"认识语法","id":"认识语法","depth":2,"charIndex":3},{"text":"JSX 语法","id":"jsx-语法","depth":3,"charIndex":11},{"text":"组件基础","id":"组件基础","depth":3,"charIndex":153},{"text":"Props 和 State","id":"props-和-state","depth":3,"charIndex":243},{"text":"Props","id":"props","depth":4,"charIndex":259},{"text":"State","id":"state","depth":4,"charIndex":325},{"text":"生命周期","id":"生命周期","depth":3,"charIndex":422},{"text":"函数组件（Hooks）","id":"函数组件hooks","depth":4,"charIndex":429},{"text":"类组件","id":"类组件","depth":4,"charIndex":512},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":639},{"text":"条件渲染","id":"条件渲染","depth":3,"charIndex":730},{"text":"列表渲染","id":"列表渲染","depth":3,"charIndex":794}],"domain":"","frontmatter":{},"version":""}]