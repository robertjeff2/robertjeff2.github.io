[{"id":0,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! 🎁","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"设计模式","content":"#\n\n设计模式是软件开发中常见问题的典型解决方案。每个模式都像一个蓝图，可以通过自定义来解决代码中的特定设计问题。在前端开发中，设计模式帮助我们编写更加可维护、可扩展\n的代码。\n\n\n设计模式的重要性#\n\n在前端面试中，设计模式是一个重要的考察点，主要关注以下几个方面：\n\n 1. 代码复用性和可维护性：通过合适的设计模式，可以提高代码的复用性，降低维护成本\n 2. 解耦和扩展性：好的设计模式可以实现模块间的解耦，使系统更容易扩展\n 3. 团队协作：设计模式提供了一种通用的解决方案，有助于团队成员之间的沟通\n 4. 性能优化：某些设计模式（如单例、享元模式）可以帮助优化应用性能\n\n\n选择设计模式的原则#\n\n在实际开发中，选择合适的设计模式需要考虑以下因素：\n\n 1. 场景适用性：不同的设计模式适用于不同的问题场景\n 2. 复杂度权衡：避免过度设计，在简单性和扩展性之间找到平衡\n 3. 团队水平：考虑团队对设计模式的理解和接受程度\n 4. 维护成本：评估采用某种设计模式后的长期维护成本\n\n\n设计模式分类#\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n前端开发中的最佳实践#\n\n 1. 组件设计\n    \n    * 使用工厂模式创建可配置的组件\n    * 使用装饰器模式增强组件功能\n    * 使用组合模式构建组件树\n\n 2. 状态管理\n    \n    * 使用单例模式实现全局状态\n    * 使用观察者模式处理状态变化\n    * 使用代理模式实现响应式\n\n 3. 数据处理\n    \n    * 使用适配器模式处理 API 数据\n    * 使用策略模式处理表单验证\n    * 使用命令模式处理用户操作","routePath":"/notes/design-pattern/","lang":"","toc":[{"text":"设计模式的重要性","id":"设计模式的重要性","depth":2,"charIndex":90},{"text":"选择设计模式的原则","id":"选择设计模式的原则","depth":2,"charIndex":292},{"text":"设计模式分类","id":"设计模式分类","depth":2,"charIndex":448},{"text":"创建型模式","id":"创建型模式","depth":3,"charIndex":458},{"text":"结构型模式","id":"结构型模式","depth":3,"charIndex":616},{"text":"行为型模式","id":"行为型模式","depth":3,"charIndex":820},{"text":"创建型模式","id":"创建型模式-1","depth":3,"charIndex":1012},{"text":"结构型模式","id":"结构型模式-1","depth":3,"charIndex":1170},{"text":"行为型模式","id":"行为型模式-1","depth":3,"charIndex":1374},{"text":"前端开发中的最佳实践","id":"前端开发中的最佳实践","depth":2,"charIndex":1566}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"发布订阅模式","content":"#\n\n\n简介#\n\n发布-订阅模式（Pub-Sub）是一种设计模式，用于在对象之间实现松耦合的通信。它允许一个对象（发布者）向多个对象（订阅者）发送消息，而发布者和订阅者之间不需要\n直接知道对方的存在。订阅者可以订阅感兴趣的事件，发布者可以在事件发生时通知所有订阅者。\n\n\n适用场景#\n\n这种模式在前端开发中非常常见，比如：\n\n事件驱动编程：DOM 事件（如 click、input）就是典型的发布-订阅模式。\n\n状态管理：在 Vue 或 React 中，全局状态管理工具（如 Vuex、Redux）的核心思想就是基于发布-订阅模式。\n\n组件通信：父子组件、兄弟组件之间的通信可以通过自定义事件（如 Vue 的 $emit 和 $on）实现。\n\n异步任务管理：比如消息队列、WebSocket 消息推送等。\n\n\n手写代码实现#\n\n\n\n * events 对象：用于存储事件名称和对应的回调函数列表。\n * subscribe 方法：允许订阅者订阅某个事件，并将回调函数添加到事件列表中。\n * publish 方法：当事件被触发时，遍历并执行所有订阅该事件的回调函数。\n * unsubscribe 方法：允许订阅者取消订阅，移除指定的回调函数。\n\n\n举例说明#\n\n可以用它来实现一个简单的消息通知系统\n\n\n\n\n扩展点#\n\n * 性能优化：如果事件列表很大，如何优化回调函数的执行效率？\n   \n   > 可以通过限制回调函数的数量、使用异步执行（如 setTimeout 或 Promise）来避免阻塞主线程。\n\n * 一次性订阅：如何实现只触发一次的事件订阅？\n   \n   > 可以在 subscribe 方法中添加一个标志位，执行一次后自动取消订阅。\n\n * 错误处理：如何处理回调函数中的错误？\n   \n   > 可以在 publish 方法中添加 try-catch，确保一个回调函数的错误不会影响其他回调函数的执行。\n\n\n总结#\n\n发布-订阅模式的优点是实现了对象之间的解耦，让代码更易于维护和扩展，特别适合处理复杂的异步通信场景。","routePath":"/notes/design-pattern/pubSub","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"适用场景","id":"适用场景","depth":2,"charIndex":135},{"text":"手写代码实现","id":"手写代码实现","depth":2,"charIndex":354},{"text":"举例说明","id":"举例说明","depth":2,"charIndex":524},{"text":"扩展点","id":"扩展点","depth":2,"charIndex":554},{"text":"总结","id":"总结","depth":2,"charIndex":816}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"面试常见手写代码","content":"#\n\n这个分类主要记录前端开发中常见的手写代码实现，包括但不限于：\n\n * 防抖节流\n * 深浅拷贝\n * Promise 实现\n * 数组方法实现\n * 对象方法实现\n * 函数柯里化\n * 事件总线\n * 观察者模式\n\n这些代码实现不仅是面试中的高频考点，也是加深对 JavaScript 理解的重要方式。每个实现都会包含详细的代码注释和实现思路说明，帮助更好地理解其中的原理。","routePath":"/notes/handwriting/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"手写防抖节流","content":"#\n\n> 首先，防抖和节流都是用来优化高频触发的事件，比如滚动、输入或者窗口调整，防止这些事件处理函数被频繁调用，影响性能。不过它们的实现方式和应用场景不同，我得先搞\n> 清楚两者的区别。防抖（Debounce）的话，我记得是当事件被触发后，一定时间内的多次触发只会执行最后一次，或者只在开始时执行一次。比如搜索框输入，用户停止\n> 输入一段时间后才发送请求，避免每次按键都请求。而节流（Throttle）则是每隔一定时间执行一次，不管事件触发有多频繁，比如滚动事件，每隔 200ms\n> 执行一次处理函数。\n\n\n回答步骤#\n\n 1. 解释防抖和节流的定义和区别。\n\n 2. 写出基本的实现代码，并解释每一步的作用。\n\n 3. 比较不同实现方式的差异。\n\n 4. 举例说明应用场景。\n\n\n1. 防抖（Debounce）#\n\n定义：高频事件触发后，在指定时间内只执行最后一次。若在等待期内再次触发，则重新计时。\n\n应用场景：搜索框输入联想、窗口大小调整（resize）。\n\n实现思路：\n\n * 利用定时器，每次触发时重置定时。\n * 支持立即执行（首次触发立即执行，后续需等待停止触发）。\n\n代码示例：\n\n\n\n关键点：\n\n * 使用闭包保存 timeout。\n * 立即执行逻辑：首次触发且未在等待期内时执行。\n * clearTimeout 确保每次触发重置计时。\n\n--------------------------------------------------------------------------------\n\n\n2. 节流（Throttle）#\n\n定义：高频事件触发时，每隔指定时间执行一次，稀释执行频率。\n\n应用场景：滚动加载（scroll）、高频点击（如抢购按钮）。\n\n实现思路：\n\n * 时间戳版：记录上次执行时间，若间隔超过阈值则执行。\n * 定时器版：延迟执行，执行后重置定时器。\n * 结合版（推荐）：首次立即执行，最后一次触发延迟执行。\n\n代码示例（结合版）：\n\n\n\n关键点：\n\n * remaining 计算剩余等待时间。\n * 首次触发立即执行，最后一次触发在剩余时间后执行。\n * 定时器与时间戳结合，确保首尾触发均被执行。\n\n--------------------------------------------------------------------------------\n\n\n3. 对比与总结#\n\n特性     防抖（DEBOUNCE）    节流（THROTTLE）\n执行时机   最后一次触发后等待结束执行   固定间隔执行\n应用场景   搜索联想、resize     滚动事件、高频点击\n核心逻辑   重置定时器           时间间隔控制\n\n--------------------------------------------------------------------------------\n\n回答技巧：\n\n 1. 先解释概念：明确防抖和节流的定义及区别。\n 2. 手写代码：逐步写出代码并解释关键步骤（如闭包、定时器、this 绑定）。\n 3. 举例场景：结合具体场景说明为何选择防抖或节流。\n 4. 扩展优化：提及取消功能（如 debounced.cancel()）或参数配置（如 leading 和 trailing）。\n\n通过清晰的结构和代码示例，展示对性能优化问题的深入理解。","routePath":"/notes/handwriting/throttle","lang":"","toc":[{"text":"回答步骤","id":"回答步骤","depth":2,"charIndex":256},{"text":"**1. 防抖（Debounce）**","id":"1-防抖debounce","depth":3,"charIndex":-1},{"text":"**2. 节流（Throttle）**","id":"2-节流throttle","depth":3,"charIndex":-1},{"text":"**3. 对比与总结**","id":"3-对比与总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"学习笔记","content":"#\n\n欢迎来到我的博客！这里记录了我在学习过程中的心得体会和技术积累。\n\n\n关于这些笔记#\n\n这些笔记是我在学习过程中的总结和思考。我会不断更新和完善这些内容，希望能够帮助到同样在学习的你。如果你发现任何问题或有任何建议，欢迎与我交流。","routePath":"/notes/","lang":"","toc":[{"text":"关于这些笔记","id":"关于这些笔记","depth":2,"charIndex":37}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"前端面试准备","content":"#\n\n\n一、技术基础强化（核心必考）#\n\n1. JavaScript 底层原理#\n\n * 闭包/作用域链：手写闭包场景，解释内存泄漏风险。\n * 原型链与继承：实现寄生组合继承，对比 ES6 class 差异。\n * Event Loop：结合宏任务/微任务分析代码执行顺序，解释 Promise、async/await 的底层逻辑。\n * 手写高频 API：实现 Promise.all、深拷贝、防抖/节流、柯里化函数 等。\n\n2. 框架核心原理#\n\n * React：\n   * 虚拟 DOM Diff 算法优化逻辑。\n   * Hooks 原理（如 useState 如何绑定到 Fiber 节点）。\n   * 性能优化手段（React.memo、useMemo 使用场景）。\n * Vue：\n   * 响应式原理（Vue2 的 Object.defineProperty 与 Vue3 的 Proxy 对比）。\n   * 模板编译流程（AST 转换到 render 函数）。\n   * 手写简易版 Vue 响应式系统。\n\n3. 浏览器与网络#\n\n * 渲染机制：从输入 URL 到页面渲染的完整流程，关键优化点（如 CRP 优化）。\n * 缓存策略：强缓存与协商缓存的 Header 字段，Service Worker 应用场景。\n * 跨域解决方案：CORS 预检请求细节，JSONP 安全性问题。\n\n4. 前端工程化#\n\n * Webpack：\n   * 打包流程（Loader 与 Plugin 的区别）。\n   * 优化配置（Tree Shaking 原理、Code Splitting 策略）。\n * 性能监控：\n   * 使用 Lighthouse 分析性能指标（FCP、LCP、CLS）。\n   * 实现前端错误监控（SourceMap 还原线上错误）。\n\n--------------------------------------------------------------------------------\n\n\n二、项目经验深挖（高频追问点）#\n\n1. 项目难点与解决方案#\n\n * 典型问题：\n   * “介绍一个你主导的复杂项目，如何设计技术方案？”\n   * “遇到过哪些性能瓶颈？如何定位并解决？”\n * 回答策略：\n   * 使用 STAR 法则（背景、任务、行动、结果）。\n   * 量化成果：如“首屏加载时间从 3s 优化至 1.2s”。\n\n2. 技术选型与权衡#\n\n * 准备问题：\n   * “为什么选择 React 而不是 Vue？”\n   * “微前端方案（如 qiankun）的落地挑战是什么？”\n * 加分回答：\n   * 结合业务场景（如团队协作成本、生态支持度）分析。\n\n3. 协作与流程优化#\n\n * 举例说明：\n   * 如何推动团队落地代码规范（ESLint + Git Hooks）。\n   * 设计前端埋点系统或 CI/CD 自动化流程。\n\n--------------------------------------------------------------------------------\n\n\n三、算法与数据结构（大厂必考）#\n\n1. 刷题重点#\n\n * 高频题型：数组/字符串操作、链表、二叉树、DFS/BFS、动态规划。\n * 前端相关题：DOM 树遍历（递归/迭代）、模板解析（栈结构应用）。\n\n2. 刷题策略#\n\n * LeetCode 精选：优先刷 Hot 100 和前端厂题库（如字节、阿里）。\n * 手写代码规范：注重边界条件处理，代码可读性（命名、注释）。\n\n--------------------------------------------------------------------------------\n\n\n四、系统设计能力（高阶岗位重点）#\n\n1. 前端架构设计#\n\n * 场景题：\n   * “设计一个高并发场景下的前端缓存方案。”\n   * “如何实现跨团队组件库的灰度发布？”\n * 考察点：模块拆分、状态管理、异常兜底方案。\n\n2. 全栈能力验证#\n\n * 准备方向：\n   * 实现一个 SSR（服务端渲染）方案。\n   * 设计一个短链生成系统的前后端架构。\n\n--------------------------------------------------------------------------------\n\n\n五、行为面试与软技能#\n\n1. 常见问题#\n\n * “为什么离开上一家公司？”\n * “如何推动技术方案在团队中落地？”\n * “与产品经理发生分歧时如何处理？”\n\n2. 回答技巧#\n\n * 避坑指南：避免抱怨前公司，聚焦个人成长诉求。\n * 展示潜力：强调自主学习（如“通过研究 WebAssembly 优化项目性能”）。\n\n--------------------------------------------------------------------------------\n\n\n六、简历优化与面试模拟#\n\n1. 简历打磨#\n\n * 突出亮点：使用关键词如“性能优化 40%”“主导组件库重构”。\n * 数据支撑：如“日均 PV 1000 万+的系统稳定性保障”。\n\n2. 模拟面试#\n\n * 技术模拟：找同行模拟框架原理追问（如“React Fiber 如何中断/恢复任务”）。\n * 压力测试：练习在白板上手写代码并解释思路。\n\n--------------------------------------------------------------------------------\n\n\n七、资源推荐#\n\n * 书籍：《JavaScript 高级程序设计》《前端架构设计》\n * 学习平台：极客时间（前端进阶课）、Frontend Masters\n * 工具：CodeSandbox 在线编码练习、Chrome DevTools 性能分析实战\n\n--------------------------------------------------------------------------------\n\n\n八、面试后复盘#\n\n * 记录问题：整理被问倒的技术点，针对性补漏。\n * 横向对比：分析不同公司对“3 年经验前端”的能力侧重（如大厂重算法，创业公司重落地速度）。","routePath":"/notes/interview/","lang":"","toc":[{"text":"**一、技术基础强化（核心必考）**","id":"一技术基础强化核心必考","depth":3,"charIndex":-1},{"text":"**1. JavaScript 底层原理**","id":"1-javascript-底层原理","depth":4,"charIndex":-1},{"text":"**2. 框架核心原理**","id":"2-框架核心原理","depth":4,"charIndex":-1},{"text":"**3. 浏览器与网络**","id":"3-浏览器与网络","depth":4,"charIndex":-1},{"text":"**4. 前端工程化**","id":"4-前端工程化","depth":4,"charIndex":-1},{"text":"**二、项目经验深挖（高频追问点）**","id":"二项目经验深挖高频追问点","depth":3,"charIndex":-1},{"text":"**1. 项目难点与解决方案**","id":"1-项目难点与解决方案","depth":4,"charIndex":-1},{"text":"**2. 技术选型与权衡**","id":"2-技术选型与权衡","depth":4,"charIndex":-1},{"text":"**3. 协作与流程优化**","id":"3-协作与流程优化","depth":4,"charIndex":-1},{"text":"**三、算法与数据结构（大厂必考）**","id":"三算法与数据结构大厂必考","depth":3,"charIndex":-1},{"text":"**1. 刷题重点**","id":"1-刷题重点","depth":4,"charIndex":-1},{"text":"**2. 刷题策略**","id":"2-刷题策略","depth":4,"charIndex":-1},{"text":"**四、系统设计能力（高阶岗位重点）**","id":"四系统设计能力高阶岗位重点","depth":3,"charIndex":-1},{"text":"**1. 前端架构设计**","id":"1-前端架构设计","depth":4,"charIndex":-1},{"text":"**2. 全栈能力验证**","id":"2-全栈能力验证","depth":4,"charIndex":-1},{"text":"**五、行为面试与软技能**","id":"五行为面试与软技能","depth":3,"charIndex":-1},{"text":"**1. 常见问题**","id":"1-常见问题","depth":4,"charIndex":-1},{"text":"**2. 回答技巧**","id":"2-回答技巧","depth":4,"charIndex":-1},{"text":"**六、简历优化与面试模拟**","id":"六简历优化与面试模拟","depth":3,"charIndex":-1},{"text":"**1. 简历打磨**","id":"1-简历打磨","depth":4,"charIndex":-1},{"text":"**2. 模拟面试**","id":"2-模拟面试","depth":4,"charIndex":-1},{"text":"**七、资源推荐**","id":"七资源推荐","depth":3,"charIndex":-1},{"text":"**八、面试后复盘**","id":"八面试后复盘","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"面试问题复盘","content":"#\n\n\n项目中遇到的最大挑战是什么,后来如何解决的#\n\n高分回答要点:\n\n * 真实性：选择真实、有技术深度的案例，避免虚构。\n * 结构化：用 STAR 法则清晰表达，避免冗长。\n * 技术细节：提及工具（Webpack/Lighthouse）、方法（代码分割/缓存策略），展示专业度。\n * 软技能：体现沟通、领导力（如协调团队）和复盘能力。\n * 数据化结果：用百分比、时间等量化指标增强说服力。 示例: 在开发某电商平台时，我负责解决首屏加载过慢的问题（5 秒+）。通过 Lighthouse\n   分析，发现图片体积和接口响应是瓶颈。我主导将图片转换为 WebP 格式并接入 CDN，推动后端为商品接口添加 Redis\n   缓存，同时用虚拟滚动优化长列表渲染。最终首屏时间降至 1.3 秒，跳出率降低\n   25%。这次经历让我学会用数据驱动跨团队协作，并在后续项目中提前设定性能预算以避免类似问题。\n   \n   > 要避免的陷阱包括：不要抱怨之前的团队或同事，不要选择因为自己疏忽导致的错误作为挑战（比如因为自己代码写错导致的\n   > bug），而应该选外部因素或技术难点。同时，要展示积极的态度和解决问题的能力。\n   > 比如，好的例子可能是处理高并发下的系统崩溃，通过水平扩展和负载均衡解决；或者在前端项目中实现复杂的交互需求，通过研究新技术或第三方库来解决。\n   > 再检查一下是否有遗漏的要点，比如是否展示了分析问题、解决问题、团队合作、学习能力等。可能还需要量化结果，比如性能提升了多少百分比，用户满意度提高，或者\n   > 项目按时交付等数据，这样更有说服力。\n\n\ntoken 放在 cookie 还是 localStorage#\n\n在前端开发中，将 Token 存储在 Cookie 还是 LocalStorage 是一个常见的安全与设计权衡问题。以下是两者的核心对比及最佳实践建议：\n\n一、核心对比\n\n特性        COOKIE                           LOCALSTORAGE\n安全性       ✅ 支持 HttpOnly 防止 XSS 读取          ❌ JavaScript 可直接访问，易受 XSS 攻击\n自动携带      ✅ 请求自动携带在 Cookie 头中              ❌ 需手动添加到请求头（如 Authorization）\n存储容量      4KB 左右                           5MB+\n跨域支持      需配置 SameSite 和 CORS              无限制，但需手动处理跨域请求头\nCSRF 风险   ❌ 需额外防护（如 CSRF Token、SameSite）   ✅ 无自动携带，CSRF 风险低\n服务端控制     ✅ 可设置过期时间、Secure、HttpOnly 等属性    ❌ 完全由前端控制\n\n二、安全性深度分析\n\n1. Cookie 的防护机制\n\n * HttpOnly：禁止 JavaScript 读取 Cookie，有效防御 XSS 窃取 Token。\n * Secure：仅通过 HTTPS 传输，防止中间人攻击。\n * SameSite=Strict/Lax：阻止跨站请求伪造（CSRF），现代浏览器默认 Lax。\n * 示例配置（服务端）：\n   \n   \n   \n   2. LocalStorage 的风险\n * XSS 攻击：一旦存在 XSS 漏洞，Token 会被直接窃取。\n * 无自动过期：需手动清理或依赖前端逻辑，易长期滞留。 三、适用场景建议 1. 优先选择 Cookie 的场景\n * 需要防御 XSS 窃取 Token：通过 HttpOnly 和 Secure 提升安全性。\n * 依赖自动携带 Token：简化前端代码，无需手动管理请求头。\n * 需要服务端控制会话：如设置过期时间、强制注销等。 2. 选择 LocalStorage 的场景\n * 需存储较大数据：如复杂的用户配置信息。\n * 跨域分离的前后端架构：如 JWT 需手动添加到 Authorization 头。\n * 对 CSRF 有独立防护：如已使用 CSRF Token 或加密请求参数。\n\n四、最佳实践\n\n 1. 使用 Cookie 的推荐方案：\n    \n    * 服务端设置 Cookie 时启用 HttpOnly、Secure 和 SameSite=Lax。\n    * 配合 CSRF Token（双重提交验证）或加密的请求参数。\n    * 示例流程：\n\n\n\n 2. 使用 LocalStorage 的防护措施：\n    \n    * 避免存储敏感信息，仅存 Token。\n    * 所有接口请求手动添加 Token 到 Authorization 头。\n    * 严格过滤输入输出，防御 XSS。\n    * 示例代码：\n\n\n\n五、面试回答模板\n\n“项目中如何选择 Token 存储方式？”\n\n> 我们优先选择 Cookie 存储 Token，并配置 HttpOnly、Secure 和 SameSite=Lax 防御 XSS 和\n> CSRF。对于需要更高灵活性的场景（如跨域分离架构），则用 LocalStorage 手动管理 Token，但会严格防御 XSS，如输入过滤、CSP\n> 策略。同时，无论哪种方式，都会确保 HTTPS 加密传输，并设置合理的 Token 过期时间。”\n\n通过结合安全需求和架构特点选择存储方式，并明确防御措施，可体现对安全与工程实践的深入理解。\n\n\n浏览器从输入 URL 到页面展示的整个过程#\n\n浏览器从输入 URL 到页面渲染的整个过程可以分为以下几个关键步骤：\n\n 1. URL 解析与输入处理\n    \n    * 浏览器解析用户输入，判断是 URL 还是搜索内容。如果是搜索词，使用默认搜索引擎进行搜索；否则，处理 URL。\n\n 2. DNS 解析\n    \n    * 将域名转换为 IP 地址：\n      1. 检查浏览器缓存 → 操作系统缓存 → 本地 Hosts 文件 → 递归查询 DNS 服务器（如未命中缓存）。\n\n 3. 建立 TCP 连接\n    \n    * 通过三次握手与服务器建立 TCP 连接：\n      \n      SYN → SYN-ACK → ACK。\n    * 若为 HTTPS，还需 TLS 握手（交换证书、协商加密算法、生成会话密钥）。\n\n 4. 发送 HTTP 请求\n    \n    * 浏览器发送 HTTP 请求，包含请求方法（如 GET）、请求头（User-Agent、Accept 等）。\n    * 若存在重定向（如 301/302），重新开始流程。\n\n 5. 服务器处理请求并返回响应\n    \n    * 服务器处理请求，返回 HTTP 响应（状态码、响应头、HTML 等资源）。\n\n 6. 浏览器解析与渲染\n    \n    * 构建 DOM 树：解析 HTML 生成 DOM 树，遇到","routePath":"/notes/interview/review","lang":"","toc":[{"text":"项目中遇到的最大挑战是什么,后来如何解决的","id":"项目中遇到的最大挑战是什么后来如何解决的","depth":3,"charIndex":3},{"text":"token 放在 cookie 还是 localStorage","id":"token-放在-cookie-还是-localstorage","depth":3,"charIndex":699},{"text":"浏览器从输入 URL 到页面展示的整个过程","id":"浏览器从输入-url-到页面展示的整个过程","depth":3,"charIndex":2348}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"React 基础","content":"#\n\n\n认识语法#\n\n\nJSX 语法#\n\n * JSX 是 JavaScript 的语法扩展，允许在 JavaScript 中编写类似 HTML 的代码\n * JSX 会被编译为 React.createElement() 调用\n * JSX 中使用大括号 {} 嵌入 JavaScript 表达式\n\n\n\n\n组件基础#\n\n * 函数组件：使用函数声明的简单组件\n * 类组件：使用 class 关键字声明，继承自 React.Component\n * 组件名称必须以大写字母开头\n\n\n\n\nProps 和 State#\n\nProps#\n\n * Props 是只读的，用于组件间数据传递\n * Props 可以传递任意类型的数据，包括函数和 JSX\n\n\n\nState#\n\n * State 用于管理组件内部状态\n * 使用 useState Hook 或 class 组件中的 setState 更新状态\n * State 更新可能是异步的\n\n\n\n\n生命周期#\n\n函数组件（Hooks）#\n\n * useEffect：处理副作用\n * useLayoutEffect：同步执行副作用\n * 自定义 Hooks：复用状态逻辑\n\n\n\n类组件#\n\n * 挂载阶段：constructor -> render -> componentDidMount\n * 更新阶段：render -> componentDidUpdate\n * 卸载阶段：componentWillUnmount\n\n\n\n\n事件处理#\n\n * React 事件使用驼峰命名\n * 事件处理器接收合成事件对象（SyntheticEvent）\n * 注意绑定 this 的问题（箭头函数或 bind）\n\n\n\n\n条件渲染#\n\n * 使用 if 语句或三元运算符\n * 使用逻辑运算符 &&\n * 防止组件返回 null 导致的问题\n\n\n\n\n列表渲染#\n\n * 使用 map 方法渲染列表\n * key 属性的重要性和正确使用\n * 避免使用索引作为 key\n\n","routePath":"/notes/react/react","lang":"","toc":[{"text":"认识语法","id":"认识语法","depth":2,"charIndex":3},{"text":"JSX 语法","id":"jsx-语法","depth":3,"charIndex":11},{"text":"组件基础","id":"组件基础","depth":3,"charIndex":153},{"text":"Props 和 State","id":"props-和-state","depth":3,"charIndex":243},{"text":"Props","id":"props","depth":4,"charIndex":259},{"text":"State","id":"state","depth":4,"charIndex":325},{"text":"生命周期","id":"生命周期","depth":3,"charIndex":422},{"text":"函数组件（Hooks）","id":"函数组件hooks","depth":4,"charIndex":429},{"text":"类组件","id":"类组件","depth":4,"charIndex":512},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":639},{"text":"条件渲染","id":"条件渲染","depth":3,"charIndex":730},{"text":"列表渲染","id":"列表渲染","depth":3,"charIndex":794}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"Vue in One Page","content":"#\n\n\nVue 实例属性和方法#\n\n * $data: 获取数据对象\n * $props: 获取传入的 props\n * $el: 获取根 DOM 元素\n * $refs: 获取注册过 ref 的所有 DOM 元素或组件实例\n * $watch: 观察数据变化\n\n\n生命周期#\n\n\nVue2 生命周期钩子#\n\n 1. 创建阶段\n    \n    * beforeCreate: 实例初始化之后，数据观测和事件配置之前调用\n    * created: 实例创建完成后调用，此时可以访问数据\n\n 2. 挂载阶段\n    \n    * beforeMount: 挂载开始之前调用\n    * mounted: 挂载完成后调用，可以访问 DOM\n\n 3. 更新阶段\n    \n    * beforeUpdate: 数据更新时调用，发生在虚拟 DOM 打补丁之前\n    * updated: 由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用\n\n 4. 销毁阶段\n    \n    * beforeDestroy: 实例销毁之前调用\n    * destroyed: 实例销毁后调用\n\n\nVue3 生命周期钩子#\n\n 1. 创建阶段\n    \n    * setup: 开始创建组件之前执行，在 beforeCreate 和 created 之前执行\n\n 2. 挂载阶段\n    \n    * onBeforeMount: 挂载开始之前调用\n    * onMounted: 挂载完成后调用\n\n 3. 更新阶段\n    \n    * onBeforeUpdate: 数据更新时调用，发生在虚拟 DOM 打补丁之前\n    * onUpdated: 数据更新后调用\n\n 4. 销毁阶段\n    \n    * onBeforeUnmount: 实例销毁之前调用（替代 beforeDestroy）\n    * onUnmounted: 实例销毁后调用（替代 destroyed）\n\n\n生命周期图示#\n\n\n\n\n模板语法#\n\n\n插值#\n\n * 文本插值：{{ message }}\n * HTML：v-html=\"rawHtml\"\n * 属性：v-bind:id=\"dynamicId\" 或简写 :id=\"dynamicId\"\n\n\n指令#\n\n 1. 条件渲染\n    \n    \n\n 2. 列表渲染\n    \n    \n\n 3. 事件处理\n    \n    \n\n 4. 表单输入绑定\n    \n    \n\n\n计算属性与侦听器#\n\n\n计算属性#\n\n\n\n\n侦听器#\n\n\n\n\nClass 与 Style 绑定#\n\n\nClass 绑定#\n\n\n\n\nStyle 绑定#\n\n\n\n\n组件系统#\n\n\n组件注册与使用#\n\n\n\n\nProps 与 Events#\n\n\n\n\n响应式原理#\n\n\nVue2 响应式原理#\n\n * 使用 Object.defineProperty 实现数据劫持\n   \n   \n\n * 主要特点：\n   * 对象属性必须提前声明\n   * 不能检测数组长度变化\n   * 不能检测对象属性的添加和删除\n   * 需要遍历对象所有属性\n * 解决方案：\n   * 使用 Vue.set() 或 this.$set() 添加响应式属性\n   * 使用 Vue.delete() 或 this.$delete() 删除属性\n   * 使用数组方法：push、pop、shift、unshift、splice、sort、reverse\n * 源码实现关键点：\n   * Observer：将数据对象的所有属性转换为 getter/setter\n   * Dep：依赖收集器，存储所有依赖（Watcher）\n   * Watcher：订阅者，负责触发视图更新\n\n\nVue3 响应式原理#\n\n * 使用 Proxy 实现响应式系统\n   \n   \n\n * 主要特点：\n   * 可以监听动态添加的属性\n   * 可以监听数组的索引和长度变化\n   * 可以监听删除的属性\n   * 不需要遍历对象所有属性\n   * 支持 Map、Set、WeakMap、WeakSet\n * 性能优势：\n   * 初始化性能更好，不需要递归遍历\n   * 内存占用更少\n   * 可以懒处理嵌套对象\n * 响应式 API：\n   * reactive：深层响应式代理\n   * ref：处理基本类型的响应式\n   * readonly：创建只读代理\n   * shallowReactive：浅层响应式\n   * shallowRef：浅层 ref\n\n\n常见面试题解答#\n\n 1. Vue2 和 Vue3 响应式的区别？\n    \n    * 实现原理不同：Vue2 使用 Object.defineProperty，Vue3 使用 Proxy\n    * 性能差异：Vue3 初始化更快，内存占用更少\n    * 功能限制：Vue2 无法监听属性添加/删除，Vue3 可以\n    * 数组处理：Vue2 需要特殊处理数组方法，Vue3 可以直接监听\n\n 2. 为什么 Vue2 不能检测数组长度变化？\n    \n    * Object.defineProperty 不能监听数组长度的变化\n    * Vue2 通过重写数组方法来实现响应式\n    * 直接通过索引修改数组不会触发更新\n\n 3. Vue3 为什么使用 Proxy？\n    \n    * 可以直接监听对象而非属性\n    * 可以监听动态添加的属性\n    * 可以监听数组的变化\n    * 可以监听对象的删除操作\n\n 4. Vue.set 的实现原理？\n    \n    \n\n 5. Vue3 ref 和 reactive 的区别？\n    \n    * ref 用于基本类型，reactive 用于对象\n    * ref 需要.value 访问，reactive 直接访问\n    * ref 可以用于模板，不需要.value\n    * reactive 不能用于基本类型\n\n\n高频面试题#\n\n\n组件通信#\n\n 1. 父子组件通信\n    \n    * Props / $emit\n    * $refs / $parent\n    * v-model / .sync (Vue2)\n    * provide / inject\n\n 2. 兄弟组件通信\n    \n    * EventBus\n    * Vuex / Pinia\n    * 通过共同的父组件\n\n 3. 跨层级组件通信\n    \n    * Vuex / Pinia\n    * provide / inject\n    * EventBus\n\n\n组件复用#\n\n 1. Vue2 复用方式\n    \n    \n\n 2. Vue3 复用方式\n    \n    \n\n\n核心概念对比#\n\n 1. 选项式 API vs 组合式 API\n    \n    * 选项式 API：\n      * 按 options 组织代码\n      * 适合简单组件\n      * 学习成本低\n    * 组合式 API：\n      * 按功能组织代码\n      * 更好的代码复用\n      * TypeScript 支持更好\n\n 2. 响应式系统\n    \n    * Vue2：Object.defineProperty\n      * 需要遍历对象属性\n      * 不能监听数组长度变化\n      * 不能监听对象属性添加/删除\n    * Vue3：Proxy\n      * 可以监听整个对象\n      * 可以监听数组变化\n      * 可以监听属性添加/删除\n\n\n性能优化建议#\n\n 1. Vue2 优化\n    \n    * 使用 Object.freeze() 冻结不需要响应式的数据\n    * 使用 v-show 代替频繁切换的 v-if\n    * 合理使用 computed 缓存\n    * 避免深度监听大数据\n    * 使用函数式组件\n    * 路由懒加载\n    * 第三方库按需引入\n\n 2. Vue3 优化\n    \n    * 使用 shallowRef 和 shallowReactive 处理大数据\n    * 使用 markRaw 标记不需要响应式的数据\n    * 合理使用 computed 和 watchEffect\n    * 使用 v-memo 缓存模板\n    * 使用 Suspense 和异步组件\n    * 动态导入组件\n    * Tree-shaking 优化\n\n\n虚拟 DOM#\n\n * 虚拟 DOM 树的构建\n   \n   * 用 JavaScript 对象描述 DOM 结构\n   * 通过 render 函数生成虚拟 DOM 树\n   * 数据变化时生成新的虚拟 DOM 树\n\n * Diff 算法实现\n   \n   1. Vue2 双端比较算法\n      \n      * 同时从新旧节点的两端开始比较\n      * 四个指针：新头、新尾、旧头、旧尾\n      * 比较策略：\n        \n        \n      \n      * 如果四种比较都未命中，则按 key 比较\n   \n   2. Vue3 快速 Diff 算法\n      \n      * 借鉴了 ivi 和 inferno 的算法\n      * 相同的前置和后置节点的预处理\n      * 最长递增子序列算法优化节点移动\n      \n      \n\n * 性能优化策略\n   \n   * 使用唯一 key 进行节点复用\n   * 避免无谓的节点更新\n   * 采用异步更新\n\n\n虚拟 DOM#\n\n * 虚拟 DOM 树的构建\n   \n   * 用 JavaScript 对象描述 DOM 结构\n   * 通过 render 函数生成虚拟 DOM 树\n   * 数据变化时生成新的虚拟 DOM 树\n\n * Diff 算法实现\n   \n   1. Vue2 双端比较算法\n      \n      * 同时从新旧节点的两端开始比较\n      * 四个指针：新头、新尾、旧头、旧尾\n      * 比较策略：\n        \n        \n      \n      * 如果四种比较都未命中，则按 key 比较\n   \n   2. Vue3 快速 Diff 算法\n      \n      * 借鉴了 ivi 和 inferno 的算法\n      * 相同的前置和后置节点的预处理\n      * 最长递增子序列算法优化节点移动\n      \n      \n\n * 性能优化策略\n   \n   * 使用唯一 key 进行节点复用\n   * 避免无谓的节点更新\n   * 采用异步更新","routePath":"/notes/vue/","lang":"","toc":[{"text":"Vue 实例属性和方法","id":"vue-实例属性和方法","depth":3,"charIndex":3},{"text":"生命周期","id":"生命周期","depth":2,"charIndex":132},{"text":"Vue2 生命周期钩子","id":"vue2-生命周期钩子","depth":3,"charIndex":140},{"text":"Vue3 生命周期钩子","id":"vue3-生命周期钩子","depth":3,"charIndex":494},{"text":"生命周期图示","id":"生命周期图示","depth":3,"charIndex":840},{"text":"模板语法","id":"模板语法","depth":2,"charIndex":852},{"text":"插值","id":"插值","depth":3,"charIndex":860},{"text":"指令","id":"指令","depth":3,"charIndex":962},{"text":"计算属性与侦听器","id":"计算属性与侦听器","depth":2,"charIndex":1050},{"text":"计算属性","id":"计算属性","depth":3,"charIndex":1062},{"text":"侦听器","id":"侦听器","depth":3,"charIndex":1072},{"text":"Class 与 Style 绑定","id":"class-与-style-绑定","depth":2,"charIndex":1081},{"text":"Class 绑定","id":"class-绑定","depth":3,"charIndex":1101},{"text":"Style 绑定","id":"style-绑定","depth":3,"charIndex":1115},{"text":"组件系统","id":"组件系统","depth":2,"charIndex":1129},{"text":"组件注册与使用","id":"组件注册与使用","depth":3,"charIndex":1137},{"text":"Props 与 Events","id":"props-与-events","depth":3,"charIndex":1150},{"text":"响应式原理","id":"响应式原理","depth":2,"charIndex":1170},{"text":"Vue2 响应式原理","id":"vue2-响应式原理","depth":3,"charIndex":1179},{"text":"Vue3 响应式原理","id":"vue3-响应式原理","depth":3,"charIndex":1573},{"text":"常见面试题解答","id":"常见面试题解答","depth":3,"charIndex":1909},{"text":"高频面试题","id":"高频面试题","depth":2,"charIndex":2513},{"text":"组件通信","id":"组件通信","depth":3,"charIndex":2522},{"text":"组件复用","id":"组件复用","depth":3,"charIndex":2782},{"text":"核心概念对比","id":"核心概念对比","depth":3,"charIndex":2840},{"text":"性能优化建议","id":"性能优化建议","depth":3,"charIndex":3195},{"text":"虚拟 DOM","id":"虚拟-dom","depth":3,"charIndex":3574},{"text":"虚拟 DOM","id":"虚拟-dom-1","depth":3,"charIndex":4031}],"domain":"","frontmatter":{},"version":""}]