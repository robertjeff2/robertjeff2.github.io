[{"id":0,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! 🎁","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"设计模式","content":"#\n\n设计模式是软件开发中常见问题的典型解决方案。每个模式都像一个蓝图，可以通过自定义来解决代码中的特定设计问题。在前端开发中，设计模式帮助我们编写更加可维护、可扩展\n的代码。\n\n\n设计模式的重要性#\n\n在前端面试中，设计模式是一个重要的考察点，主要关注以下几个方面：\n\n 1. 代码复用性和可维护性：通过合适的设计模式，可以提高代码的复用性，降低维护成本\n 2. 解耦和扩展性：好的设计模式可以实现模块间的解耦，使系统更容易扩展\n 3. 团队协作：设计模式提供了一种通用的解决方案，有助于团队成员之间的沟通\n 4. 性能优化：某些设计模式（如单例、享元模式）可以帮助优化应用性能\n\n\n选择设计模式的原则#\n\n在实际开发中，选择合适的设计模式需要考虑以下因素：\n\n 1. 场景适用性：不同的设计模式适用于不同的问题场景\n 2. 复杂度权衡：避免过度设计，在简单性和扩展性之间找到平衡\n 3. 团队水平：考虑团队对设计模式的理解和接受程度\n 4. 维护成本：评估采用某种设计模式后的长期维护成本\n\n\n设计模式分类#\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n前端开发中的最佳实践#\n\n 1. 组件设计\n    \n    * 使用工厂模式创建可配置的组件\n    * 使用装饰器模式增强组件功能\n    * 使用组合模式构建组件树\n\n 2. 状态管理\n    \n    * 使用单例模式实现全局状态\n    * 使用观察者模式处理状态变化\n    * 使用代理模式实现响应式\n\n 3. 数据处理\n    \n    * 使用适配器模式处理 API 数据\n    * 使用策略模式处理表单验证\n    * 使用命令模式处理用户操作","routePath":"/notes/design-pattern/","lang":"","toc":[{"text":"设计模式的重要性","id":"设计模式的重要性","depth":2,"charIndex":90},{"text":"选择设计模式的原则","id":"选择设计模式的原则","depth":2,"charIndex":292},{"text":"设计模式分类","id":"设计模式分类","depth":2,"charIndex":448},{"text":"创建型模式","id":"创建型模式","depth":3,"charIndex":458},{"text":"结构型模式","id":"结构型模式","depth":3,"charIndex":616},{"text":"行为型模式","id":"行为型模式","depth":3,"charIndex":820},{"text":"创建型模式","id":"创建型模式-1","depth":3,"charIndex":1012},{"text":"结构型模式","id":"结构型模式-1","depth":3,"charIndex":1170},{"text":"行为型模式","id":"行为型模式-1","depth":3,"charIndex":1374},{"text":"前端开发中的最佳实践","id":"前端开发中的最佳实践","depth":2,"charIndex":1566}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"发布订阅模式","content":"#\n\n\n简介#\n\n发布-订阅模式（Pub-Sub）是一种设计模式，用于在对象之间实现松耦合的通信。它允许一个对象（发布者）向多个对象（订阅者）发送消息，而发布者和订阅者之间不需要\n直接知道对方的存在。订阅者可以订阅感兴趣的事件，发布者可以在事件发生时通知所有订阅者。\n\n\n适用场景#\n\n这种模式在前端开发中非常常见，比如：\n\n事件驱动编程：DOM 事件（如 click、input）就是典型的发布-订阅模式。\n\n状态管理：在 Vue 或 React 中，全局状态管理工具（如 Vuex、Redux）的核心思想就是基于发布-订阅模式。\n\n组件通信：父子组件、兄弟组件之间的通信可以通过自定义事件（如 Vue 的 $emit 和 $on）实现。\n\n异步任务管理：比如消息队列、WebSocket 消息推送等。\n\n\n手写代码实现#\n\n\n\n * events 对象：用于存储事件名称和对应的回调函数列表。\n * subscribe 方法：允许订阅者订阅某个事件，并将回调函数添加到事件列表中。\n * publish 方法：当事件被触发时，遍历并执行所有订阅该事件的回调函数。\n * unsubscribe 方法：允许订阅者取消订阅，移除指定的回调函数。\n\n\n举例说明#\n\n可以用它来实现一个简单的消息通知系统\n\n\n\n\n扩展点#\n\n * 性能优化：如果事件列表很大，如何优化回调函数的执行效率？\n   \n   > 可以通过限制回调函数的数量、使用异步执行（如 setTimeout 或 Promise）来避免阻塞主线程。\n\n * 一次性订阅：如何实现只触发一次的事件订阅？\n   \n   > 可以在 subscribe 方法中添加一个标志位，执行一次后自动取消订阅。\n\n * 错误处理：如何处理回调函数中的错误？\n   \n   > 可以在 publish 方法中添加 try-catch，确保一个回调函数的错误不会影响其他回调函数的执行。\n\n\n总结#\n\n发布-订阅模式的优点是实现了对象之间的解耦，让代码更易于维护和扩展，特别适合处理复杂的异步通信场景。","routePath":"/notes/design-pattern/pubSub","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"适用场景","id":"适用场景","depth":2,"charIndex":135},{"text":"手写代码实现","id":"手写代码实现","depth":2,"charIndex":354},{"text":"举例说明","id":"举例说明","depth":2,"charIndex":524},{"text":"扩展点","id":"扩展点","depth":2,"charIndex":554},{"text":"总结","id":"总结","depth":2,"charIndex":816}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"面试常见手写代码","content":"#\n\n这个分类主要记录前端开发中常见的手写代码实现，包括但不限于：\n\n * 防抖节流\n * 深浅拷贝\n * Promise 实现\n * 数组方法实现\n * 对象方法实现\n * 函数柯里化\n * 事件总线\n * 观察者模式\n\n这些代码实现不仅是面试中的高频考点，也是加深对 JavaScript 理解的重要方式。每个实现都会包含详细的代码注释和实现思路说明，帮助更好地理解其中的原理。","routePath":"/notes/handwriting/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"手写防抖节流","content":"#\n\n> 首先，防抖和节流都是用来优化高频触发的事件，比如滚动、输入或者窗口调整，防止这些事件处理函数被频繁调用，影响性能。不过它们的实现方式和应用场景不同，我得先搞\n> 清楚两者的区别。防抖（Debounce）的话，我记得是当事件被触发后，一定时间内的多次触发只会执行最后一次，或者只在开始时执行一次。比如搜索框输入，用户停止\n> 输入一段时间后才发送请求，避免每次按键都请求。而节流（Throttle）则是每隔一定时间执行一次，不管事件触发有多频繁，比如滚动事件，每隔 200ms\n> 执行一次处理函数。\n\n\n回答步骤#\n\n 1. 解释防抖和节流的定义和区别。\n\n 2. 写出基本的实现代码，并解释每一步的作用。\n\n 3. 比较不同实现方式的差异。\n\n 4. 举例说明应用场景。\n\n\n1. 防抖（Debounce）#\n\n定义：高频事件触发后，在指定时间内只执行最后一次。若在等待期内再次触发，则重新计时。\n\n应用场景：搜索框输入联想、窗口大小调整（resize）。\n\n实现思路：\n\n * 利用定时器，每次触发时重置定时。\n * 支持立即执行（首次触发立即执行，后续需等待停止触发）。\n\n代码示例：\n\n\n\n关键点：\n\n * 使用闭包保存 timeout。\n * 立即执行逻辑：首次触发且未在等待期内时执行。\n * clearTimeout 确保每次触发重置计时。\n\n--------------------------------------------------------------------------------\n\n\n2. 节流（Throttle）#\n\n定义：高频事件触发时，每隔指定时间执行一次，稀释执行频率。\n\n应用场景：滚动加载（scroll）、高频点击（如抢购按钮）。\n\n实现思路：\n\n * 时间戳版：记录上次执行时间，若间隔超过阈值则执行。\n * 定时器版：延迟执行，执行后重置定时器。\n * 结合版（推荐）：首次立即执行，最后一次触发延迟执行。\n\n代码示例（结合版）：\n\n\n\n关键点：\n\n * remaining 计算剩余等待时间。\n * 首次触发立即执行，最后一次触发在剩余时间后执行。\n * 定时器与时间戳结合，确保首尾触发均被执行。\n\n--------------------------------------------------------------------------------\n\n\n3. 对比与总结#\n\n特性     防抖（DEBOUNCE）    节流（THROTTLE）\n执行时机   最后一次触发后等待结束执行   固定间隔执行\n应用场景   搜索联想、resize     滚动事件、高频点击\n核心逻辑   重置定时器           时间间隔控制\n\n--------------------------------------------------------------------------------\n\n回答技巧：\n\n 1. 先解释概念：明确防抖和节流的定义及区别。\n 2. 手写代码：逐步写出代码并解释关键步骤（如闭包、定时器、this 绑定）。\n 3. 举例场景：结合具体场景说明为何选择防抖或节流。\n 4. 扩展优化：提及取消功能（如 debounced.cancel()）或参数配置（如 leading 和 trailing）。\n\n通过清晰的结构和代码示例，展示对性能优化问题的深入理解。","routePath":"/notes/handwriting/throttle","lang":"","toc":[{"text":"回答步骤","id":"回答步骤","depth":2,"charIndex":256},{"text":"**1. 防抖（Debounce）**","id":"1-防抖debounce","depth":3,"charIndex":-1},{"text":"**2. 节流（Throttle）**","id":"2-节流throttle","depth":3,"charIndex":-1},{"text":"**3. 对比与总结**","id":"3-对比与总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"学习笔记","content":"#\n\n欢迎来到我的博客！这里记录了我在学习过程中的心得体会和技术积累。\n\n\n关于这些笔记#\n\n这些笔记是我在学习过程中的总结和思考。我会不断更新和完善这些内容，希望能够帮助到同样在学习的你。如果你发现任何问题或有任何建议，欢迎与我交流。","routePath":"/notes/","lang":"","toc":[{"text":"关于这些笔记","id":"关于这些笔记","depth":2,"charIndex":37}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"React 基础","content":"#\n\n\n认识语法#\n\n\nJSX 语法#\n\n * JSX 是 JavaScript 的语法扩展，允许在 JavaScript 中编写类似 HTML 的代码\n * JSX 会被编译为 React.createElement() 调用\n * JSX 中使用大括号 {} 嵌入 JavaScript 表达式\n\n\n\n\n组件基础#\n\n * 函数组件：使用函数声明的简单组件\n * 类组件：使用 class 关键字声明，继承自 React.Component\n * 组件名称必须以大写字母开头\n\n\n\n\nProps 和 State#\n\nProps#\n\n * Props 是只读的，用于组件间数据传递\n * Props 可以传递任意类型的数据，包括函数和 JSX\n\n\n\nState#\n\n * State 用于管理组件内部状态\n * 使用 useState Hook 或 class 组件中的 setState 更新状态\n * State 更新可能是异步的\n\n\n\n\n生命周期#\n\n函数组件（Hooks）#\n\n * useEffect：处理副作用\n * useLayoutEffect：同步执行副作用\n * 自定义 Hooks：复用状态逻辑\n\n\n\n类组件#\n\n * 挂载阶段：constructor -> render -> componentDidMount\n * 更新阶段：render -> componentDidUpdate\n * 卸载阶段：componentWillUnmount\n\n\n\n\n事件处理#\n\n * React 事件使用驼峰命名\n * 事件处理器接收合成事件对象（SyntheticEvent）\n * 注意绑定 this 的问题（箭头函数或 bind）\n\n\n\n\n条件渲染#\n\n * 使用 if 语句或三元运算符\n * 使用逻辑运算符 &&\n * 防止组件返回 null 导致的问题\n\n\n\n\n列表渲染#\n\n * 使用 map 方法渲染列表\n * key 属性的重要性和正确使用\n * 避免使用索引作为 key\n\n","routePath":"/notes/react/react","lang":"","toc":[{"text":"认识语法","id":"认识语法","depth":2,"charIndex":3},{"text":"JSX 语法","id":"jsx-语法","depth":3,"charIndex":11},{"text":"组件基础","id":"组件基础","depth":3,"charIndex":153},{"text":"Props 和 State","id":"props-和-state","depth":3,"charIndex":243},{"text":"Props","id":"props","depth":4,"charIndex":259},{"text":"State","id":"state","depth":4,"charIndex":325},{"text":"生命周期","id":"生命周期","depth":3,"charIndex":422},{"text":"函数组件（Hooks）","id":"函数组件hooks","depth":4,"charIndex":429},{"text":"类组件","id":"类组件","depth":4,"charIndex":512},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":639},{"text":"条件渲染","id":"条件渲染","depth":3,"charIndex":730},{"text":"列表渲染","id":"列表渲染","depth":3,"charIndex":794}],"domain":"","frontmatter":{},"version":""}]