[{"id":0,"title":"面试是一场对自己的检验","content":"#\n\n如何成为一名优秀前端?\n\n1.总结 2.输出 3.理解 4.扎实学习","routePath":"/experience/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"3.9 面试","content":"#\n\nEcharts 性能调优,举例说明#\n\n首屏加载速度#\n\n按需引入 ECharts 懒加载图表组件 预加载关键资源 数据分片加载:先加载核心数据,在加载完整数据\n\n3.权限系统:后端菜单怎么转前端路由: 前端写死 和动态加载#\n\n组件懒加载 ：使用 () => import() 语法实现组件懒加载 动态路由 ：通过 router.addRoute 动态添加路由 路径处理\n：确保前后端路径格式一致 权限控制 ：在路由守卫中完成菜单获取和路由添加\n这种方案可以实现前后端权限的统一管理，后端只需要维护菜单结构，前端负责动态生成路由和菜单\n\n4.浏览器事件循环#\n\n为什么需要事件循环, 同步代码 > 微任务 > 渲染 > 宏任务\n\n5.回流跟重绘#\n\n回流(Reflow) ：当元素的尺寸、位置或内容发生变化，导致浏览器需要重新计算元素几何属性并重新构建渲染树的过程。 重绘(Repaint)\n：当元素的外观样式改变（如颜色、背景色等），但不影响布局时，浏览器只需要重新绘制受影响区域的过程。\n\n * 回流代价更高 ：回流必定引起重绘，但重绘不一定引起回流\n * 现代浏览器优化 ：浏览器会批量处理回流操作（队列机制）\n * CSS 属性影响 ：不同 CSS 属性触发的渲染阶段不同\n * 最佳实践 ：\n * 避免频繁读取会触发回流的属性（如 offsetWidth）\n * 使用 requestAnimationFrame 安排动画\n * 对复杂动画使用 position: absolute/fixed 脱离文档流\n * 使用 CSS3 硬件加速（transform/opacity 等）\n\n6.一次性在页面上加载很多元素#\n\n虚拟滚动技术 (核心方案) 分块加载 (时间切片) 使用文档片段批量插入\n\n 1. 优先使用虚拟滚动 ：适合列表/表格等线性布局\n 2. 复杂布局使用分块加载 ：配合 requestIdleCallback\n 3. 减少 DOM 复杂度 ：简化节点结构和样式\n 4. 避免同步布局抖动 ：不要在循环中读取布局属性\n 5. 使用 CSS containment ：限制重绘范围\n 6. 大数据处理在 Worker 中完成 ：保持主线程流畅 这些方法可以单独或组合使用，根据具体场景选择最适合的方案。虚拟滚动是处理超长列表最有效的解决方案。\n\n7.JS 判断是一个对象是空对象#\n\n\n\n8.一个数组,需要依次用里面的 id 去调用接口获得用户信息,返回一个用户信息数组,编写代码#\n\n\n\n\n\n9.forEach 跳出循环#\n\n使用 for...of 代替 使用异常跳出\n\n10.精度问题#\n\ntoFixed(2) 四舍五入不准确 第三方数据库 BigInt 原理\n\n11.diff 算法#\n\nvue2/vue3\n\n12.uniapp 跟原生小程序的区别","routePath":"/experience/interview/first","lang":"","toc":[{"text":"Echarts 性能调优,举例说明","id":"echarts-性能调优举例说明","depth":4,"charIndex":2},{"text":"首屏加载速度","id":"首屏加载速度","depth":4,"charIndex":22},{"text":"3.权限系统:后端菜单怎么转前端路由: 前端写死 和动态加载","id":"3权限系统后端菜单怎么转前端路由-前端写死-和动态加载","depth":4,"charIndex":84},{"text":"4.浏览器事件循环","id":"4浏览器事件循环","depth":4,"charIndex":272},{"text":"5.回流跟重绘","id":"5回流跟重绘","depth":4,"charIndex":318},{"text":"6.一次性在页面上加载很多元素","id":"6一次性在页面上加载很多元素","depth":4,"charIndex":700},{"text":"7.JS 判断是一个对象是空对象","id":"7js-判断是一个对象是空对象","depth":4,"charIndex":988},{"text":"8.一个数组,需要依次用里面的 id 去调用接口获得用户信息,返回一个用户信息数组,编写代码","id":"8一个数组需要依次用里面的-id-去调用接口获得用户信息返回一个用户信息数组编写代码","depth":4,"charIndex":1009},{"text":"9.forEach 跳出循环","id":"9foreach-跳出循环","depth":4,"charIndex":1062},{"text":"10.精度问题","id":"10精度问题","depth":4,"charIndex":1102},{"text":"11.diff 算法","id":"11diff-算法","depth":4,"charIndex":1149}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"3.7 面试","content":"#\n\n * 1.事件循环,宏任务微任务\n * 2.vue router\n * 3.pinia vuex\n * 4.内存快照\n * 5.组件间传值 父子兄弟传值方式\n * 6.promise 原理\n * 7.权限控制,分角色\n * 8.keep-alive 原理属性\n   \n   > keep-alive 是一个内置组件,用来在多个组件间动态切换时缓存被移除的组件实例 定制行为 include exclude prop 来定制行为\n   > 传入 max prop 来限制可被缓存的最大组件实例数 指定 max 后内部执行类 LRU 算法: 如果缓存的实例数量即将超过指定的\n   > max,则最久没有访问的缓存实例被销毁 底层原理 set? 生命周期勾子 onActivated 和 onDeacticated\n   > 注册两个状态的生命周期勾子","routePath":"/experience/interview/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! 🎁","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"设计模式","content":"#\n\n设计模式是软件开发中常见问题的典型解决方案。每个模式都像一个蓝图，可以通过自定义来解决代码中的特定设计问题。在前端开发中，设计模式帮助我们编写更加可维护、可扩展\n的代码。\n\n\n设计模式的重要性#\n\n在前端面试中，设计模式是一个重要的考察点，主要关注以下几个方面：\n\n 1. 代码复用性和可维护性：通过合适的设计模式，可以提高代码的复用性，降低维护成本\n 2. 解耦和扩展性：好的设计模式可以实现模块间的解耦，使系统更容易扩展\n 3. 团队协作：设计模式提供了一种通用的解决方案，有助于团队成员之间的沟通\n 4. 性能优化：某些设计模式（如单例、享元模式）可以帮助优化应用性能\n\n\n选择设计模式的原则#\n\n在实际开发中，选择合适的设计模式需要考虑以下因素：\n\n 1. 场景适用性：不同的设计模式适用于不同的问题场景\n 2. 复杂度权衡：避免过度设计，在简单性和扩展性之间找到平衡\n 3. 团队水平：考虑团队对设计模式的理解和接受程度\n 4. 维护成本：评估采用某种设计模式后的长期维护成本\n\n\n设计模式分类#\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n前端开发中的最佳实践#\n\n 1. 组件设计\n    \n    * 使用工厂模式创建可配置的组件\n    * 使用装饰器模式增强组件功能\n    * 使用组合模式构建组件树\n\n 2. 状态管理\n    \n    * 使用单例模式实现全局状态\n    * 使用观察者模式处理状态变化\n    * 使用代理模式实现响应式\n\n 3. 数据处理\n    \n    * 使用适配器模式处理 API 数据\n    * 使用策略模式处理表单验证\n    * 使用命令模式处理用户操作","routePath":"/notes/design-pattern/","lang":"","toc":[{"text":"设计模式的重要性","id":"设计模式的重要性","depth":2,"charIndex":90},{"text":"选择设计模式的原则","id":"选择设计模式的原则","depth":2,"charIndex":292},{"text":"设计模式分类","id":"设计模式分类","depth":2,"charIndex":448},{"text":"创建型模式","id":"创建型模式","depth":3,"charIndex":458},{"text":"结构型模式","id":"结构型模式","depth":3,"charIndex":616},{"text":"行为型模式","id":"行为型模式","depth":3,"charIndex":820},{"text":"创建型模式","id":"创建型模式-1","depth":3,"charIndex":1012},{"text":"结构型模式","id":"结构型模式-1","depth":3,"charIndex":1170},{"text":"行为型模式","id":"行为型模式-1","depth":3,"charIndex":1374},{"text":"前端开发中的最佳实践","id":"前端开发中的最佳实践","depth":2,"charIndex":1566}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"发布订阅模式","content":"#\n\n\n简介#\n\n发布-订阅模式（Pub-Sub）是一种设计模式，用于在对象之间实现松耦合的通信。它允许一个对象（发布者）向多个对象（订阅者）发送消息，而发布者和订阅者之间不需要\n直接知道对方的存在。订阅者可以订阅感兴趣的事件，发布者可以在事件发生时通知所有订阅者。\n\n\n适用场景#\n\n这种模式在前端开发中非常常见，比如：\n\n事件驱动编程：DOM 事件（如 click、input）就是典型的发布-订阅模式。\n\n状态管理：在 Vue 或 React 中，全局状态管理工具（如 Vuex、Redux）的核心思想就是基于发布-订阅模式。\n\n组件通信：父子组件、兄弟组件之间的通信可以通过自定义事件（如 Vue 的 $emit 和 $on）实现。\n\n异步任务管理：比如消息队列、WebSocket 消息推送等。\n\n\n手写代码实现#\n\n\n\n * events 对象：用于存储事件名称和对应的回调函数列表。\n * subscribe 方法：允许订阅者订阅某个事件，并将回调函数添加到事件列表中。\n * publish 方法：当事件被触发时，遍历并执行所有订阅该事件的回调函数。\n * unsubscribe 方法：允许订阅者取消订阅，移除指定的回调函数。\n\n\n举例说明#\n\n可以用它来实现一个简单的消息通知系统\n\n\n\n\n扩展点#\n\n * 性能优化：如果事件列表很大，如何优化回调函数的执行效率？\n   \n   > 可以通过限制回调函数的数量、使用异步执行（如 setTimeout 或 Promise）来避免阻塞主线程。\n\n * 一次性订阅：如何实现只触发一次的事件订阅？\n   \n   > 可以在 subscribe 方法中添加一个标志位，执行一次后自动取消订阅。\n\n * 错误处理：如何处理回调函数中的错误？\n   \n   > 可以在 publish 方法中添加 try-catch，确保一个回调函数的错误不会影响其他回调函数的执行。\n\n\n总结#\n\n发布-订阅模式的优点是实现了对象之间的解耦，让代码更易于维护和扩展，特别适合处理复杂的异步通信场景。","routePath":"/notes/design-pattern/pubSub","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"适用场景","id":"适用场景","depth":2,"charIndex":135},{"text":"手写代码实现","id":"手写代码实现","depth":2,"charIndex":354},{"text":"举例说明","id":"举例说明","depth":2,"charIndex":524},{"text":"扩展点","id":"扩展点","depth":2,"charIndex":554},{"text":"总结","id":"总结","depth":2,"charIndex":816}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"面试常见手写代码","content":"#","routePath":"/notes/handwriting/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"手写防抖节流","content":"#\n\n> 首先，防抖和节流都是用来优化高频触发的事件，比如滚动、输入或者窗口调整，防止这些事件处理函数被频繁调用，影响性能。不过它们的实现方式和应用场景不同，我得先搞\n> 清楚两者的区别。防抖（Debounce）的话，我记得是当事件被触发后，一定时间内的多次触发只会执行最后一次，或者只在开始时执行一次。比如搜索框输入，用户停止\n> 输入一段时间后才发送请求，避免每次按键都请求。而节流（Throttle）则是每隔一定时间执行一次，不管事件触发有多频繁，比如滚动事件，每隔 200ms\n> 执行一次处理函数。\n\n\n回答步骤#\n\n 1. 解释防抖和节流的定义和区别。\n\n 2. 写出基本的实现代码，并解释每一步的作用。\n\n 3. 比较不同实现方式的差异。\n\n 4. 举例说明应用场景。\n\n\n1. 防抖（Debounce）#\n\n定义：高频事件触发后，在指定时间内只执行最后一次。若在等待期内再次触发，则重新计时。\n\n应用场景：搜索框输入联想、窗口大小调整（resize）。\n\n实现思路：\n\n * 利用定时器，每次触发时重置定时。\n * 支持立即执行（首次触发立即执行，后续需等待停止触发）。\n\n代码示例：\n\n\n\n关键点：\n\n * 使用闭包保存 timeout。\n * 立即执行逻辑：首次触发且未在等待期内时执行。\n * clearTimeout 确保每次触发重置计时。\n\n--------------------------------------------------------------------------------\n\n\n2. 节流（Throttle）#\n\n定义：高频事件触发时，每隔指定时间执行一次，稀释执行频率。\n\n应用场景：滚动加载（scroll）、高频点击（如抢购按钮）。\n\n实现思路：\n\n * 时间戳版：记录上次执行时间，若间隔超过阈值则执行。\n * 定时器版：延迟执行，执行后重置定时器。\n * 结合版（推荐）：首次立即执行，最后一次触发延迟执行。\n\n代码示例（结合版）：\n\n\n\n关键点：\n\n * remaining 计算剩余等待时间。\n * 首次触发立即执行，最后一次触发在剩余时间后执行。\n * 定时器与时间戳结合，确保首尾触发均被执行。\n\n--------------------------------------------------------------------------------\n\n\n3. 对比与总结#\n\n特性     防抖（DEBOUNCE）    节流（THROTTLE）\n执行时机   最后一次触发后等待结束执行   固定间隔执行\n应用场景   搜索联想、resize     滚动事件、高频点击\n核心逻辑   重置定时器           时间间隔控制\n\n--------------------------------------------------------------------------------\n\n回答技巧：\n\n 1. 先解释概念：明确防抖和节流的定义及区别。\n 2. 手写代码：逐步写出代码并解释关键步骤（如闭包、定时器、this 绑定）。\n 3. 举例场景：结合具体场景说明为何选择防抖或节流。\n 4. 扩展优化：提及取消功能（如 debounced.cancel()）或参数配置（如 leading 和 trailing）。\n\n通过清晰的结构和代码示例，展示对性能优化问题的深入理解。","routePath":"/notes/handwriting/throttle","lang":"","toc":[{"text":"回答步骤","id":"回答步骤","depth":2,"charIndex":256},{"text":"**1. 防抖（Debounce）**","id":"1-防抖debounce","depth":3,"charIndex":-1},{"text":"**2. 节流（Throttle）**","id":"2-节流throttle","depth":3,"charIndex":-1},{"text":"**3. 对比与总结**","id":"3-对比与总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"学习笔记","content":"#\n\n欢迎来到我的博客！这里记录了我在学习过程中的心得体会和技术积累。\n\n\n关于这些笔记#\n\n这些笔记是我在学习过程中的总结和思考。我会不断更新和完善这些内容，希望能够帮助到同样在学习的你。如果你发现任何问题或有任何建议，欢迎与我交流。","routePath":"/notes/","lang":"","toc":[{"text":"关于这些笔记","id":"关于这些笔记","depth":2,"charIndex":37}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"简历涉及知识点准备","content":"#\n\n\n1. 性能优化的前因后果说清楚#\n\n我使用 F12 开发者工具进入 LightHouse\n工具分析了网站性能指标,指标包含了性能指标（Performance）、可访问性（Accessibility）、最佳实践（Best Practices）和\nSEO（Search Engine Optimization）。 FCP 时间比较场,所以这次的目的就是优化 FCP 时间。 FCP\n时间是指浏览器从开始加载页面到页面内容首次开始绘制的时间。 FCP 时间越短，用户体验越好。 FCP 时间过长，会导致用户等待时间过长，影响用户体验。\n使用的方式:\n\n * 使用图片懒加载：通过使用 JavaScript 或者在 HTML 属性中设置 onload 事件，当图片加载完成时再显示，这样可以减少初始化时的性能开销\n * 使用预加载：通过在页面加载时预先加载一些数据和资源，当用户访问时可以更快地渲染。\n * 优化列表和数组操作：使用现代前端框架提供的列表和数组操作方法，可以减少代码量，提高性能。\n * 使用 CDN：通过将静态资源部署到 CDN 服务器上，可以提高用户体验，减少网络传输时的时间开销。\n * 使用事件代理：将事件监听器添加到父元素上，可以减少事件监听器的数量，提高性能。\n * 优化 DOM 操作：在使用 JavaScript 操作 DOM 时，尽量减少操作的次数和复杂度，以提高性能。\n * 图片压缩：通过压缩图片的大小，可以减少网络传输时的时间开销。\n\n细说图片懒加载: 图片懒加载是一种优化技术，它的目的是在用户滚动页面时，只有当图片进入可视区域时才加载图片，从而减少页面加载时间和带宽消耗。\n图片懒加载的实现方式有很多种，其中比较常用的是使用 JavaScript 和 onload 事件。 具体实现步骤如下：\n\n 1. 在 HTML 中，将图片的 src 属性设置为一个占位图，例如：\n\n\n\n 2. 在 JavaScript 中，使用 onload 事件监听图片加载完成的事件，当图片加载完成时，将占位图的 src 属性替换为真实的图片地址，例如：\n\n\n\n\n2. 怎么去封装一个组件#\n\n首先先分析组件的功能和特点，确定组件的结构和样式。 然后根据组件的功能和特点，编写组件的代码。 最后将组件的代码封装成一个独立的模块，方便在其他项目中使用。\n单一职责原则：每个组件只做一件事，便于维护和复用。 可扩展性：组件可以根据需要进行扩展和修改，便于维护和升级。 通过 props 传递数据和配置，通过事件（如\nonChange 、 onSubmit ）向父组件传递变化。 支持插槽/slot（Vue）或 children（React） 通过 v-model（Vue）或\nvalue/onChange（React）实现双向绑定。\n\n\n3. 在团队怎么去践行前端工程化#\n\n1.开发流程统一,构建统一的代码规范代码风格 制定并推行代码规范（如 ESLint、Prettier），统一团队编码风格。 采用 Git\nFlow、分支管理策略，规范代码提交（如 Commitlint、Husky 钩子）。\n\n * 推行代码评审（Code Review）制度，提升代码质量和团队协作。 2.模块化与组件化开发 推行组件化思想，封装高复用的 UI\n   组件和业务组件，沉淀组件库。 3.技术文档输出与知识沉淀 编写详细的技术文档、接口文档、开发手册，降低团队成员沟通成本。 4.团队协作与持续改进\n   定期技术分享、Code Review、技术沙龙，提升团队整体技术水平。\n\n\n4. git rebase 和 git merge 的区别#\n\ngit 工作流的搭建:\n\n 1. 首先创建一个新的分支，用于开发新的功能或修复 bug。\n 2. 在新分支上进行开发和测试。\n 3. 当开发完成后，将新分支合并到主分支（通常是 master 分支）。\n 4. 合并过程中，需要进行代码审查和测试，确保代码质量和稳定性。\n 5. 合并完成后，将新分支删除，保持主分支的整洁和清晰。\n 6. 定期进行代码合并和部署，确保主分支的稳定性和可靠性。\n\ngit rebase 和 git merge 的区别:\n\n * git merge ：将两个分支的最新内容合并，保留两条分支的历史，产生一个新的合并提交（merge commit），历史记录呈现分叉和合并的树状结构。\n * git rebase ：将当前分支的提交“迁移”到目标分支的最新提交之后，重写提交历史，使历史记录更加线性。 差异:\n * merge 会保留分支的分叉和合并点，历史更真实，但可能更复杂。\n * rebase 会让提交历史变得线性，便于查看和回溯，但会改变提交的哈希值。 场景:\n * merge 适合保留完整的分支开发历史，适合团队协作。\n * rebase 适合整理提交历史，保持主干分支整洁，适合个人开发或合并前整理。 冲突\n * merge 过程中如有冲突，只需解决一次。\n * rebase 过程中每次“迁移”一个提交都可能产生冲突，需要多次解决。\n\n\n5. 在前端层面怎么保障整个系统的稳定性#\n\n1.代码规范与审核 ○ code review ○ 编写代码层面的规范 2.错误处理与容错 ○ 让错误可控，组件内的错误不至于导致整个页面发生崩溃\n\n * 组件内部做好异常捕获，防止单个组件错误导致页面整体崩溃。\n * 全局异常捕获（如 window.onerror、Vue.config.errorHandler、React\n   ErrorBoundary），及时上报和处理异常。\n * 关键操作增加降级和兜底方案，保证核心功能可用。 3.性能优化\n * 合理使用懒加载、预加载、CDN、事件代理等手段，提升整体性能。\n * 监控线上性能指标，及时发现和优化性能瓶颈。 代码复用与模块化 ○ 减少代码冗余，提高代码复用率，便于维护 ○ 需求开发前编写技术文档\n\n\n6. 权限控制方案#\n\n：基于角色 and 基于用户，优劣点分别是什么 1.基于角色\n\n * 原理 ：为每个用户分配一个或多个角色，每个角色拥有不同的权限。前端根据用户角色决定页面展示内容、路由访问、按钮操作等。\n * 优点 ：结构清晰，易于管理，适合权限体系较为稳定的系统。\n * 登录后获取用户角色，前端根据角色动态生成路由和菜单。\n * 组件/按钮通过指令或高阶组件判断当前用户角色是否有权限显示。 2.基于用户\n * 原理 ：为每个用户单独分配权限，前端根据用户的具体权限控制页面元素的显示与操作。\n * 优点 ：灵活，能满足个性化需求。\n * 缺点 ：管理复杂，维护成本高，适合权限变化频繁或个性化需求强的场景。 实现方式举例 ：\n * 登录后获取用户权限列表，前端根据权限列表渲染页面和功能。\n * 通过权限码（如\"CAN_EDIT_USER\"）控制按钮、菜单、路由等的显示。\n\n常用技术实现\n\n * 路由守卫（如 Vue Router、React Router 的 beforeEach/beforeEnter）\n * 权限指令/高阶组件（如 v-permission、withPermission）\n * 动态菜单/按钮渲染\n * 权限码/权限点管理\n\n 7. RSA 和浏览器指纹风控分别是什么 RSA\n    是一种非对称加密算法（Rivest–Shamir–Adleman），在前端主要用于数据加密和安全传输。其核心思想是使用一对公钥和私钥：公钥用于加密数据，\n    私钥用于解密数据。常见应用场景包括：\n\n * 前端登录时对敏感信息（如密码）进行加密，防止明文传输被窃取。\n * 与后端进行安全通信，防止中间人攻击和数据篡改。\n\nfingerprintjs\n\n * 浏览器类型和版本\n\n * 操作系统类型和版本\n\n * 屏幕分辨率、颜色深度\n\n * 安装的字体、插件、语言设置 用途：\n\n * 主要用于风控、反作弊、用户唯一性识别等场景。\n\n * 可以辅助判断同一用户是否多次访问、是否存在异常行为等。\n\n 8. keep-alive 的原理是什么 用于缓存被包裹的动态组件，避免重复渲染和销毁，提高性能和用户体验。 keep-alive\n    通过内部维护一个缓存对象（通常是基于 LRU 策略的 Map），以组件的唯一标识（如 name 或 key）为 key，组件的实例为\n    value。当组件被切换出去时，不会销毁，而是将其实例存入缓存。 第一次渲染时正常挂载 切换的时候会触发 deactivated 钩子函数\n    再次切换回来的时候会触发 activated 钩子函数\n\n * 在 Vue 的 patch 过程中，keep-alive 会拦截对被包裹组件的卸载操作，将其转为缓存操作，并在需要时复用缓存中的 VNode 实例。\n * include/exclude 控制 通过 include/exclude 属性，keep-alive 会根据组件的 name 或 key\n   判断是否需要缓存，动态决定哪些组件参与缓存。\n * 缓存淘汰 当缓存数量超过 max 属性时，keep-alive 会按照 LRU（最近最少使用）策略淘汰最久未使用的组件实例，释放内存。\n\n\n9. 对于多数据节点，模型会发生卡顿的问题，有没有做什么优化#\n\n虚拟列表（Virtual List）/虚拟滚动（Virtual Scrolling） 只渲染可视区域内的数据节点，未显示的数据不渲染，极大减少 DOM\n数量，提升渲染性能。常见库有 react-window、vue-virtual-scroller 等。 检测元素进入可用区域 使用 Intersection\nObserver API 监听元素进入和离开可视区域，只渲染进入的元素，避免大量 DOM 渲染。 使用懒加载（Lazy Loading）\n对于图片、视频等资源，只在元素进入可视区域时加载，避免一次性加载大量资源。 渲染节奏用 requestAnimationFrame\n\n * 优化滚动时的渲染节奏，避免频繁操作 DOM，提升性能\n\n 10. Websocket 的心跳机制 WebSocket 的心跳机制是指客户端和服务端定期发送“心跳包”（通常是特殊格式的数据包，如 ping/pong\n     或自定义消息），以检测连接是否存活、防止中间网络设备断开长时间无数据传输的连接。 在 onmessage 周期监听消息 ws 失败重连机制\n\n * 监听 onclose 和 onerror ，在断开时自动重连\n * 使用定时器控制重连频率，避免频繁重连\n * 可设置最大重连次数或指数退避\n * 重连后恢复心跳和消息监听\n\n\n11. Websocket 和 http 的区别#\n\n * HTTP 通信是“请求-响应”模式，客户端主动发起请求，服务端响应。\n\n * WebSocket 支持双向通信，服务端可以主动推送消息给客户端，实时性强。\n\n * HTTP 每次通信都需要携带完整的请求和响应头，数据包体积较大。\n\n * WebSocket 握手后，数据帧头部很小，通信开销低，适合高频率、实时性强的场景。\n\n * HTTP 默认端口为 80（HTTPS 为 443）。\n\n * WebSocket 默认端口为 80（ws）和 443（wss），但协议不同。 HTTP 适合请求-响应式的传统数据交互，WebSocket\n   适合需要实时、双向通信的高交互场景。\n\n\n12. 垃圾回收机制#\n\na. 引用计数\n\n * 原理 ：跟踪记录每个值被引用的次数\n * 优点 ：发现垃圾时立即回收\n * 缺点 ：无法解决循环引用问题 b. 标记清除\n * 原理 ：从根对象开始遍历所有引用，标记活动对象，未被标记的进行清除\n * 步骤 ：\n\n 1. 标记阶段：从根对象开始遍历\n 2. 清除阶段：清除未被标记的对象\n\nc.分代回收（Generational Collection）\n\n * 新生代 ：存活时间短的对象\n   * 使用 Scavenge 算法\n   * 空间分为 From 和 To 两部分\n   * 存活对象复制到 To 空间\n * 老生代 ：存活时间长的对象\n   * 使用标记清除和标记整理\n   * 减少碎片化\n * 优点 ：能解决循环引用问题\n * 缺点 ：会产生内存碎片\n\n\n13.内存泄露一般怎么排查#\n\n * 意外的全局变量\n * 未清理的定时器\n * 闭包引用\n * DOM 引用未清理\n * 事件监听器未移除 从这几个方面去排查, F12 开发工具中可以看到内存快照\n\n 14. 一般怎么进行技术选型呢 ○ 社区活跃度 ○ 同类型的技术对比\n 15. 实时获取怎么做的 ws 通信\n 16. 状态管理库 Vuex 的原理 ,vue 和 pinia 的区别\n\n * Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式\n * 采用集中式存储管理应用的所有组件的状态\n * 以相应的规则保证状态以一种可预测的方式发生变化 数据流向清晰 ：组件通过 dispatch 分发 action，action\n   可以包含异步操作，action 再通过 commit 提交 mutation，mutation 是唯一能修改 state\n   的地方，并且必须是同步的。这样保证了状态变更的可追踪和可预测。 Getter ：类似于 Vue 的计算属性，对 state 进行二次处理，结果会被缓存。\n\n区别\n\n * Vuex 采用传统的模块化、mutation、action、getter 设计，API 较为繁琐。\n\n * Pinia 更加轻量、现代，API 设计更贴近 Composition API，使用 setup 语法糖，书写更简洁。 模块化 ：\n\n * Vuex 需要手动注册模块，模块嵌套复杂。\n\n * Pinia 每个 store 独立，天然模块化，按需引入，易于拆分和维护。 数据修改方式\n\n * Vuex 必须通过 mutation 修改 state，mutation 必须同步，action 负责异步。\n\n * Pinia 可以直接在 action 或外部直接修改 state，无需 mutation，简化了数据流。 总结 ：Pinia\n   更轻量、易用、类型友好，推荐在 Vue3 项目中优先使用；Vuex 适合老项目或对 mutation/action 传统模式有依赖的场景。\n\n\n17. Vue 中组件进行通信方案#\n\n 1. props / $emit\n\n 2. vue2 自定义事件总线（EventBus）vue3 不推荐使用\n\n 3. provide / inject 适合祖孙组件通信，适合深层嵌套场景。\n\n 4. ref / $parent /$children 通过 ref 获取子组件实例，或通过 $parent、$children\n    访问父/子组件实例。适合简单场景，不推荐频繁使用。\n\n 5. 全局状态管理\n\n 6. attrs / listeners 通过 $attrs 和 $listeners 实现属性和事件的透传，适合多层组件嵌套时的通信。\n\n\n18 为什么 eventBus 在 vue3 中不推荐#\n\n响应式系统升级 ：Vue3 的响应式系统基于 Proxy 实现，事件总线这种通过全局实例传递事件的方式，容易绕开响应式数据流，导致状态不可追踪、不透明，违背了\nVue3 推崇的“明确的数据流向” 类型安全与可维护性差 ：EventBus\n事件名和参数没有类型约束，容易出现拼写错误、参数不一致等问题，难以维护和重构，尤其是在大型项目中。 更好的替代方案 ：Vue3 推荐使用\nprovide/inject、props/$emit、全局状态管理（如 Pinia）等更清晰、类型友好、易于维护的通信方式。这些方式更符合 Vue3\n的设计理念和现代前端开发需求。\n\n\n18. hash 路由和 history 的区别#\n\n\n\n * hash 模式 ：通过监听 window 的 hashchange 事件，URL 的 # 后面的内容变化时，vue-router 会解析 hash\n   并匹配路由。\n * history 模式 ：利用 HTML5 History\n   API（pushState/replaceState/popstate），监听浏览器的前进、后退等操作，URL 变化时同样进行路由匹配。\n   vue-router 会在 组件处动态渲染当前匹配到的路由组件。每当路由变化时， 会自动切换显示对应的组件。 vue-router\n   提供了全局、路由独享、组件内的导航守卫（如 beforeEach、beforeEnter、beforeRouteEnter\n   等），可以在路由跳转前后进行权限校验、数据预处理等操作。\n   \n   区别\n   \n   * hash 路由：利用 URL 的 #（hash）部分，监听 window 的 hashchange 事件来实现路由切换。hash\n     变化不会导致页面重新加载，# 后面的内容不会被服务器解析。\n * history 路由：利用 HTML5 的 History API（pushState、replaceState、popstate），直接改变浏览器的\n   URL 路径，实现无刷新路由切换，URL 更加美观。\n * hash 模式 ：URL 中带有 # 符号，不支持 SEO，不美观。\n * history 模式 ：URL 中没有 # 符号，支持 SEO，美观。 兼容性 hash 模式 ：IE9 及以下不支持。 history 模式\n   ：需要服务器配置支持。\n * hash 路由：# 后面的内容不会被服务器处理，不需要额外配置。\n * history 路由：需要后端支持，所有路由都要返回 index.html，否则刷新页面会 404。\n\n总结 ： hash 路由实现简单、兼容性好、无需后端配合，但不利于 SEO；history 路由 URL 更美观、利于\nSEO，但需要服务器支持。实际开发中根据项目需求选择合适的路由模式。","routePath":"/notes/interview/deepresume","lang":"","toc":[{"text":"1. 性能优化的前因后果说清楚","id":"1-性能优化的前因后果说清楚","depth":2,"charIndex":3},{"text":"2. 怎么去封装一个组件","id":"2-怎么去封装一个组件","depth":2,"charIndex":892},{"text":"3. 在团队怎么去践行前端工程化","id":"3-在团队怎么去践行前端工程化","depth":2,"charIndex":1177},{"text":"4. git rebase 和 git merge 的区别","id":"4-git-rebase-和-git-merge-的区别","depth":2,"charIndex":1494},{"text":"5. 在前端层面怎么保障整个系统的稳定性","id":"5-在前端层面怎么保障整个系统的稳定性","depth":2,"charIndex":2117},{"text":"6. 权限控制方案","id":"6-权限控制方案","depth":2,"charIndex":2474},{"text":"9. 对于多数据节点，模型会发生卡顿的问题，有没有做什么优化","id":"9-对于多数据节点模型会发生卡顿的问题有没有做什么优化","depth":2,"charIndex":3835},{"text":"11. Websocket 和 http 的区别","id":"11-websocket-和-http-的区别","depth":2,"charIndex":4437},{"text":"12. 垃圾回收机制","id":"12-垃圾回收机制","depth":2,"charIndex":4760},{"text":"13.内存泄露一般怎么排查","id":"13内存泄露一般怎么排查","depth":2,"charIndex":5122},{"text":"17. Vue 中组件进行通信方案","id":"17-vue-中组件进行通信方案","depth":2,"charIndex":5989},{"text":"18 为什么 eventBus 在 vue3 中不推荐","id":"18-为什么-eventbus-在-vue3-中不推荐","depth":2,"charIndex":6288},{"text":"18. hash 路由和 history 的区别","id":"18-hash-路由和-history-的区别","depth":2,"charIndex":6599}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"前端面试准备","content":"#\n\n\n一、技术基础强化（核心必考）#\n\n1. JavaScript 底层原理#\n\n * 闭包/作用域链：手写闭包场景，解释内存泄漏风险。\n * 原型链与继承：实现寄生组合继承，对比 ES6 class 差异。\n * Event Loop：结合宏任务/微任务分析代码执行顺序，解释 Promise、async/await 的底层逻辑。\n * 手写高频 API：实现 Promise.all、深拷贝、防抖/节流、柯里化函数 等。\n\n2. 框架核心原理#\n\n * React：\n   * 虚拟 DOM Diff 算法优化逻辑。\n   * Hooks 原理（如 useState 如何绑定到 Fiber 节点）。\n   * 性能优化手段（React.memo、useMemo 使用场景）。\n * Vue：\n   * 响应式原理（Vue2 的 Object.defineProperty 与 Vue3 的 Proxy 对比）。\n   * 模板编译流程（AST 转换到 render 函数）。\n   * 手写简易版 Vue 响应式系统。\n\n3. 浏览器与网络#\n\n * 渲染机制：从输入 URL 到页面渲染的完整流程，关键优化点（如 CRP 优化）。\n * 缓存策略：强缓存与协商缓存的 Header 字段，Service Worker 应用场景。\n * 跨域解决方案：CORS 预检请求细节，JSONP 安全性问题。\n\n4. 前端工程化#\n\n * Webpack：\n   * 打包流程（Loader 与 Plugin 的区别）。\n   * 优化配置（Tree Shaking 原理、Code Splitting 策略）。\n * 性能监控：\n   * 使用 Lighthouse 分析性能指标（FCP、LCP、CLS）。\n   * 实现前端错误监控（SourceMap 还原线上错误）。\n\n--------------------------------------------------------------------------------\n\n\n二、项目经验深挖（高频追问点）#\n\n1. 项目难点与解决方案#\n\n * 典型问题：\n   * “介绍一个你主导的复杂项目，如何设计技术方案？”\n   * “遇到过哪些性能瓶颈？如何定位并解决？”\n * 回答策略：\n   * 使用 STAR 法则（背景、任务、行动、结果）。\n   * 量化成果：如“首屏加载时间从 3s 优化至 1.2s”。\n\n2. 技术选型与权衡#\n\n * 准备问题：\n   * “为什么选择 React 而不是 Vue？”\n   * “微前端方案（如 qiankun）的落地挑战是什么？”\n * 加分回答：\n   * 结合业务场景（如团队协作成本、生态支持度）分析。\n\n3. 协作与流程优化#\n\n * 举例说明：\n   * 如何推动团队落地代码规范（ESLint + Git Hooks）。\n   * 设计前端埋点系统或 CI/CD 自动化流程。\n\n--------------------------------------------------------------------------------\n\n\n三、算法与数据结构（大厂必考）#\n\n1. 刷题重点#\n\n * 高频题型：数组/字符串操作、链表、二叉树、DFS/BFS、动态规划。\n * 前端相关题：DOM 树遍历（递归/迭代）、模板解析（栈结构应用）。\n\n2. 刷题策略#\n\n * LeetCode 精选：优先刷 Hot 100 和前端厂题库（如字节、阿里）。\n * 手写代码规范：注重边界条件处理，代码可读性（命名、注释）。\n\n--------------------------------------------------------------------------------\n\n\n四、系统设计能力（高阶岗位重点）#\n\n1. 前端架构设计#\n\n * 场景题：\n   * “设计一个高并发场景下的前端缓存方案。”\n   * “如何实现跨团队组件库的灰度发布？”\n * 考察点：模块拆分、状态管理、异常兜底方案。\n\n2. 全栈能力验证#\n\n * 准备方向：\n   * 实现一个 SSR（服务端渲染）方案。\n   * 设计一个短链生成系统的前后端架构。\n\n--------------------------------------------------------------------------------\n\n\n五、行为面试与软技能#\n\n1. 常见问题#\n\n * “为什么离开上一家公司？”\n * “如何推动技术方案在团队中落地？”\n * “与产品经理发生分歧时如何处理？”\n\n2. 回答技巧#\n\n * 避坑指南：避免抱怨前公司，聚焦个人成长诉求。\n * 展示潜力：强调自主学习（如“通过研究 WebAssembly 优化项目性能”）。\n\n--------------------------------------------------------------------------------\n\n\n六、简历优化与面试模拟#\n\n1. 简历打磨#\n\n * 突出亮点：使用关键词如“性能优化 40%”“主导组件库重构”。\n * 数据支撑：如“日均 PV 1000 万+的系统稳定性保障”。\n\n2. 模拟面试#\n\n * 技术模拟：找同行模拟框架原理追问（如“React Fiber 如何中断/恢复任务”）。\n * 压力测试：练习在白板上手写代码并解释思路。\n\n--------------------------------------------------------------------------------\n\n\n七、资源推荐#\n\n * 书籍：《JavaScript 高级程序设计》《前端架构设计》\n * 学习平台：极客时间（前端进阶课）、Frontend Masters\n * 工具：CodeSandbox 在线编码练习、Chrome DevTools 性能分析实战\n\n--------------------------------------------------------------------------------\n\n\n八、面试后复盘#\n\n * 记录问题：整理被问倒的技术点，针对性补漏。\n * 横向对比：分析不同公司对“3 年经验前端”的能力侧重（如大厂重算法，创业公司重落地速度）。\n\n\nJS 基础(一)#\n\n\n基础类型#\n\n原始类型\n\nboolean null undefined number string symbol\n\ntypeof null会输出object 属于 js 遗留 bug\n\n对象类型\n\n对象类型存储的是地址 原始类型存储的是值\n\nObject function array 等\n\n> typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？\n\ntypeof对于原始类型来说，除了null都可以显示正确的类型\n\n\n\n对于对象来说 除了 function 都是 Object 所以不准确\n\ninstanceof 是用来判断对象的类型 内部机制是通过原型链来判断的\n\ninstanceof 支持自定义 , Symbol.hasInstance\n\n\nthis#\n\n\n\n * 对于直接调用foo来说，不管foo函数被放在了什么地方，this一定是window\n * 对于obj.foo()来说，我们只需要记住，谁调用了函数，谁就是this，所以在这个场景下foo函数中的this就是obj对象\n * 对于new的方式来说，this被永远绑定在了c上面，不会被任何方式改变this\n\n箭头函数中的 this 取决的是外层作用域的 this 如果没有,就往上层作用域查找 this\n\nnew的方式优先级最高，接下来是bind这些函数，然后是obj.foo()这种调用方式，最后是foo这种调用方式，同时，箭头函数的this一旦被绑定，就不会再被\n任何方式所改变。\n\n\nJS 基础(二)#\n\n> == 和 === 有什么区别？\n\n==来说，如果对比双方的类型不一样的话，就会进行类型转换，这也就用到了我们上一章节讲的内容。\n\n=== 是值和类型都相等\n\n闭包#\n\n涉及面试题：什么是闭包？\n\n闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。\n\n> 循环中使用闭包解决 var 定义函数的问题\n\n\n\n可以使用闭包解决\n\n\n\n在上述代码中，我们首先使用了立即执行函数将i传入函数内部，这个时候值就被固定在了参数j上面不会改变，当下次执行timer这个闭包的时候，就可以使用外部函数的变量\nj，从而达到目的。\n\n深浅拷贝#\n\n浅拷贝#\n\n1.浅拷贝通过Object.assign 实现,\nObject.assign只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。\n\n2.通过展开运算符实现...\n\n浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话,就需要用深拷贝实现\n\n深拷贝#\n\n 1. JSON.parse(JSON.stringify(object))\n\n局限性:\n\n * 会忽略undefined\n * 会忽略symbol\n * 不能序列化函数\n * 不能解决循环引用的对象\n\n 1. 不包含函数的 可以使用 MessageChannel\n 2. 自己实现深拷贝\n\n通过判断类型,递归实现\n\n\n\n原型#\n\n> 面试题: 如何理解原型？如何理解原型链？\n\n每一个对象上的内置属性 prototype\n\n对象原型__proto__\n\n函数原型prototype\n\n直接读取存在兼容性问题 Object.getPrototypeOf 方法获取(生产环境)\n\n原型之间相互引用形成了链条,即一个指向一个最顶层为null\n\n> 补充：new 操作符做的事情\n\n> 1.创建一个新对象\n\n> 2.将函数的 this 绑定到这个对象上\n\n> 3.将函数的 prottyp 复制给新对象的[prototype]属性\n\n> 4.默认返回这个新对象\n\n总结:\n\n * Object是所有对象的爸爸，所有对象都可以通过__proto__找到它\n * Function是所有函数的爸爸，所有函数都可以通过__proto__找到它\n * 函数的prototype是一个对象\n * 对象的__proto__属性指向原型，__proto__将对象和原型连接起来组成了原型链\n\n\nES6#\n\nvar let const#\n\n> 涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？\n\nvar : 使用var声明的变量会被提升到作用域的顶部\n\nlet、const因为暂时性死区的原因，不能在声明前使用\n\nvar在全局作用域下声明变量会导致变量挂载在window上，其他两者不会\n\nclass 继承#\n\n在 js 中并不存在类, class 是语法糖本质还是函数\n\n原型继承\n\n\n\n通过Parent.call(this)继承父类的属性，然后改变子类的原型为new Parent()来继承父类的函数\n\n继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了\n不需要的父类属性，存在内存上的浪费。\n\nclass 继承\n\n\n\nclass实现继承的核心在于使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super，因为这段代码可以看成Parent.call(this,\nvalue)\n\n模块化#\n\n> 面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？\n\ncommonJs\n\n在 Webpack 中经常可以见到 ,在打包后的 js 文件里\n\n支持动态导入,使用require()\n\nEs module\n\n原生实现的模块化方案\n\n\n\n * CommonJS 支持动态导入，也就是require(${path}/xx.js)，后者目前不支持，但是已有提案\n * CommonJS\n   是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很\n   大影响\n * CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module\n   采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化\n * ES Module 会编译成require/exports来执行的\n\nProxy#\n\nvue3 的响应式实现原理\n\n\n\n需要我们在get中收集依赖，在set派发更新，之所以 Vue3.0 要使用Proxy替换原本的 API\n原因在于Proxy无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是Proxy可以完美监听到任何方\n式的数据改变，缺陷可能就是浏览器的兼容性不好了。\n\n数组方法 map,filter,reduce#\n\nmap作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。\n\n\n\n另外map的回调函数接受三个参数，分别是当前索引元素，索引，原数组\n\n> 经典 map 代码题\n\n\n\n * 第一轮遍历 parseInt('1', 0) -> 1\n * 第二轮遍历 parseInt('2', 1) -> NaN\n * 第三轮遍历 parseInt('3', 2) -> NaN\n\nfilter的作用也是生成一个新数组，在遍历数组的时候将返回值为true的元素放入新数组，我们可以利用这个函数删除一些不需要的元素\n\nreduce可以将数组中的元素通过回调函数最终转换为一个值。\n\n\n\n\nJS 异步编程题#\n\nPromise#\n\n三个状态\n\nPending Fulfilled Rejected\n\n在构造Promise的时候，构造函数内部的代码是立即执行的\n\n\n\nPromise实现了链式调用，也就是说每次调用then之后返回的都是一个Promise，并且是一个全新的Promise，原因也是因为状态不可变。如果你在then\n中 使用了return，那么return的值会被Promise.resolve()包装\n\n主要解决了回调地狱的问题\n\nPromise/A+ 规范 手写\n\n\n面试专项题#\n\n1.AJAX fetch axios#\n\najax 是一个技术统称 asynchronous javascript and xml\n\nfetch 是一个浏览器原生 API, 支持 promise\n\naxios 是第三方库 发起网络请求 内部 XMLHttpRequest 和 fetch 来实现\n\n2.防抖节流什么区别#\n\n1.两者区别,2.使用场景 ?\n\n防抖: 防止抖动,等不抖了 在执行下一步.\n\n输入框一直输入等输入停止后再去搜索,按钮多次点击\n\n\n\n3.px % em rem vw/vh 区别#\n\npx 基本单位(绝对单位)\n\n% 相对于父元素的比例\n\nem 相对于当前元素\n\nrem 相对于根节点\n\nvw 屏幕宽度 1% vh 屏幕高度 1% vmin 最小值 vmax 最大值\n\n4.什么时候不能使用箭头函数#\n\n箭头函数有什么缺点? 没有 arguments 获取不到\n\n不适合原型方法 构造方法\n\nvue 组件本质上是一个 JS 对象 react (非 hooks)本质上是 es6class\n\n5.TCP 三次握手和四次挥手#\n\n建立 TCP 连接 ⇒ 在传输内容\n\n连接是 TCP 协议 传输内容是 http 协议\n\n1.客户端发送 syn\n\n2.服务端 syn+1 ack\n\n3.客户端回 ack+1\n\n表示建立了连接\n\n1.客户端发送 FIN 说要断开了\n\n2.服务端回复 ACK 知道要要断开了(还有没有传输完成的数据继续传输)\n\n3.服务端发送 FIN 数据传输完毕可以关闭\n\n4.客户端回应 ACK 断开连接\n\n6.for..in 和 for ..of#\n\n使用于不同的数据类型\n\nfor of 不能遍历对象 可以遍历 MAP SET 构造器\n\n主要是去访问可迭代对象 symbol.iterator next()\n\nfor in 用来访问可枚举数据 enmumerable:true 表示支持枚举 比如对象,数组等\n\n7.for await of 异步迭代循环#\n\nfor await (let res of list ){\n\n代替 promise.all 在循环中拿到结果\n\n}\n\n允许以同步的方式编写异步代码，极大地简化了异步编程。它消除了手动处理 Promise\n和回调函数的需要，使得代码更加简洁和易于理解。此外，它还提供了错误处理机制：如果在迭代过程中发生错误，循环会立即终止，并将错误抛出，你可以使用try...cat\nch语句来捕获和处理这些错误。\n\n8.虚拟列表实现#\n\n● 定高的实现方式\n\n 1. 根据元素个数 * 高度定义一个外部容器\n 2. 根据视口高度 / 元素高度得到当前能展示的元素个数，并在此基础上加上前方和后方用来做缓冲的虚拟区域元素个数\n 3. 监听 scroll 事件，获取当前 scrollTop 值，根据 scrollTop 值 /\n    元素高度获得展示的第一个元素的索引值，根据这个索引值，计算需要渲染的第一个元素和最后一个元素，即加上虚拟区和展示区的元素\n 4. 此时每一个元素都是绝对定位的，高度为每一个元素的高度 * 之前元素的个数\n\n● 不定高的实现方式\n\n 1. 难点：首先外部容器的总长不确定，其次无法通过 scrollTop / 元素高度获得初识索引值\n 2. 针对难点\n    1，可以初始假定一个足够元素长度，因为精确地计算出容器总高度的意义不是很大，之后在每次滚动时，累加计算已经滚动过的元素高度，加上剩余元素的假定高度，实时\n    更新容器的最终高度，但是 pc 端会出现拖拽滑轮滚动比不一致情况\n 3. 针对难点 2，根据视口高度累加展示的元素高度和，如果滑动到的高度高于已经累加过的元素高度和，则再进行累加，直到满足高度。但是需要一个 map\n    用来存储已经滑动过的元素高度信息，包括元素自身的高度和它之前的总高度 => 双链表+哈希\n\nflex:1 代表什么#\n\nflex:1 等价于 flex-grow:1; flex-shrink:1; flex-basis:0%;\n\n * 其中，flex-grow:1 表示该元素可以按比例分配父容器剩余空间；\n * flex-shrink:1 表示当空间不足时可以缩小；\n * flex-basis:0% 表示初始主轴空间为 0，所有空间都由 flex-grow 分配。 flex:1\n   让元素在弹性布局中“自适应填充剩余空间”，常用于响应式布局 如果有多个都是 flex:1 的元素，它们会按照它们的 flex-grow\n   属性值的比例来分配剩余空间。","routePath":"/notes/interview/","lang":"","toc":[{"text":"**一、技术基础强化（核心必考）**","id":"一技术基础强化核心必考","depth":3,"charIndex":-1},{"text":"**1. JavaScript 底层原理**","id":"1-javascript-底层原理","depth":4,"charIndex":-1},{"text":"**2. 框架核心原理**","id":"2-框架核心原理","depth":4,"charIndex":-1},{"text":"**3. 浏览器与网络**","id":"3-浏览器与网络","depth":4,"charIndex":-1},{"text":"**4. 前端工程化**","id":"4-前端工程化","depth":4,"charIndex":-1},{"text":"**二、项目经验深挖（高频追问点）**","id":"二项目经验深挖高频追问点","depth":3,"charIndex":-1},{"text":"**1. 项目难点与解决方案**","id":"1-项目难点与解决方案","depth":4,"charIndex":-1},{"text":"**2. 技术选型与权衡**","id":"2-技术选型与权衡","depth":4,"charIndex":-1},{"text":"**3. 协作与流程优化**","id":"3-协作与流程优化","depth":4,"charIndex":-1},{"text":"**三、算法与数据结构（大厂必考）**","id":"三算法与数据结构大厂必考","depth":3,"charIndex":-1},{"text":"**1. 刷题重点**","id":"1-刷题重点","depth":4,"charIndex":-1},{"text":"**2. 刷题策略**","id":"2-刷题策略","depth":4,"charIndex":-1},{"text":"**四、系统设计能力（高阶岗位重点）**","id":"四系统设计能力高阶岗位重点","depth":3,"charIndex":-1},{"text":"**1. 前端架构设计**","id":"1-前端架构设计","depth":4,"charIndex":-1},{"text":"**2. 全栈能力验证**","id":"2-全栈能力验证","depth":4,"charIndex":-1},{"text":"**五、行为面试与软技能**","id":"五行为面试与软技能","depth":3,"charIndex":-1},{"text":"**1. 常见问题**","id":"1-常见问题","depth":4,"charIndex":-1},{"text":"**2. 回答技巧**","id":"2-回答技巧","depth":4,"charIndex":-1},{"text":"**六、简历优化与面试模拟**","id":"六简历优化与面试模拟","depth":3,"charIndex":-1},{"text":"**1. 简历打磨**","id":"1-简历打磨","depth":4,"charIndex":-1},{"text":"**2. 模拟面试**","id":"2-模拟面试","depth":4,"charIndex":-1},{"text":"**七、资源推荐**","id":"七资源推荐","depth":3,"charIndex":-1},{"text":"**八、面试后复盘**","id":"八面试后复盘","depth":3,"charIndex":-1},{"text":"JS 基础(一)","id":"js-基础一","depth":3,"charIndex":2686},{"text":"基础类型","id":"基础类型","depth":3,"charIndex":2698},{"text":"this","id":"this","depth":3,"charIndex":3039},{"text":"JS 基础(二)","id":"js-基础二","depth":3,"charIndex":3345},{"text":"闭包","id":"闭包","depth":4,"charIndex":3437},{"text":"深浅拷贝","id":"深浅拷贝","depth":4,"charIndex":3647},{"text":"浅拷贝","id":"浅拷贝","depth":4,"charIndex":3654},{"text":"深拷贝","id":"深拷贝","depth":4,"charIndex":3800},{"text":"原型","id":"原型","depth":4,"charIndex":3967},{"text":"ES6","id":"es6","depth":3,"charIndex":4393},{"text":"var let const","id":"var-let-const","depth":4,"charIndex":4399},{"text":"class 继承","id":"class-继承","depth":4,"charIndex":4556},{"text":"模块化","id":"模块化","depth":4,"charIndex":4867},{"text":"Proxy","id":"proxy","depth":4,"charIndex":5315},{"text":"数组方法 map,filter,reduce","id":"数组方法-mapfilterreduce","depth":4,"charIndex":5499},{"text":"JS 异步编程题","id":"js-异步编程题","depth":3,"charIndex":5823},{"text":"Promise","id":"promise","depth":4,"charIndex":5834},{"text":"面试专项题","id":"面试专项题","depth":3,"charIndex":6070},{"text":"1.AJAX fetch axios","id":"1ajax-fetch-axios","depth":4,"charIndex":6078},{"text":"2.防抖节流什么区别","id":"2防抖节流什么区别","depth":4,"charIndex":6227},{"text":"3.px % em rem vw/vh 区别","id":"3px--em-rem-vwvh-区别","depth":4,"charIndex":6308},{"text":"4.什么时候不能使用箭头函数","id":"4什么时候不能使用箭头函数","depth":4,"charIndex":6426},{"text":"5.TCP 三次握手和四次挥手","id":"5tcp-三次握手和四次挥手","depth":4,"charIndex":6536},{"text":"6.for..in 和 for ..of","id":"6forin-和-for-of","depth":4,"charIndex":6751},{"text":"7.for await of 异步迭代循环","id":"7for-await-of-异步迭代循环","depth":4,"charIndex":6905},{"text":"8.虚拟列表实现","id":"8虚拟列表实现","depth":4,"charIndex":7129},{"text":"flex:1 代表什么","id":"flex1-代表什么","depth":4,"charIndex":7706}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"面试问题复盘","content":"#\n\n\n项目中遇到的最大挑战是什么,后来如何解决的#\n\n高分回答要点:\n\n * 真实性：选择真实、有技术深度的案例，避免虚构。\n * 结构化：用 STAR 法则清晰表达，避免冗长。\n * 技术细节：提及工具（Webpack/Lighthouse）、方法（代码分割/缓存策略），展示专业度。\n * 软技能：体现沟通、领导力（如协调团队）和复盘能力。\n * 数据化结果：用百分比、时间等量化指标增强说服力。 示例: 在开发某电商平台时，我负责解决首屏加载过慢的问题（5 秒+）。通过 Lighthouse\n   分析，发现图片体积和接口响应是瓶颈。我主导将图片转换为 WebP 格式并接入 CDN，推动后端为商品接口添加 Redis\n   缓存，同时用虚拟滚动优化长列表渲染。最终首屏时间降至 1.3 秒，跳出率降低\n   25%。这次经历让我学会用数据驱动跨团队协作，并在后续项目中提前设定性能预算以避免类似问题。\n   \n   > 要避免的陷阱包括：不要抱怨之前的团队或同事，不要选择因为自己疏忽导致的错误作为挑战（比如因为自己代码写错导致的\n   > bug），而应该选外部因素或技术难点。同时，要展示积极的态度和解决问题的能力。\n   > 比如，好的例子可能是处理高并发下的系统崩溃，通过水平扩展和负载均衡解决；或者在前端项目中实现复杂的交互需求，通过研究新技术或第三方库来解决。\n   > 再检查一下是否有遗漏的要点，比如是否展示了分析问题、解决问题、团队合作、学习能力等。可能还需要量化结果，比如性能提升了多少百分比，用户满意度提高，或者\n   > 项目按时交付等数据，这样更有说服力。\n\n\ntoken 放在 cookie 还是 localStorage#\n\n在前端开发中，将 Token 存储在 Cookie 还是 LocalStorage 是一个常见的安全与设计权衡问题。以下是两者的核心对比及最佳实践建议：\n\n一、核心对比\n\n特性        COOKIE                           LOCALSTORAGE\n安全性       ✅ 支持 HttpOnly 防止 XSS 读取          ❌ JavaScript 可直接访问，易受 XSS 攻击\n自动携带      ✅ 请求自动携带在 Cookie 头中              ❌ 需手动添加到请求头（如 Authorization）\n存储容量      4KB 左右                           5MB+\n跨域支持      需配置 SameSite 和 CORS              无限制，但需手动处理跨域请求头\nCSRF 风险   ❌ 需额外防护（如 CSRF Token、SameSite）   ✅ 无自动携带，CSRF 风险低\n服务端控制     ✅ 可设置过期时间、Secure、HttpOnly 等属性    ❌ 完全由前端控制\n\n二、安全性深度分析\n\n1. Cookie 的防护机制\n\n * HttpOnly：禁止 JavaScript 读取 Cookie，有效防御 XSS 窃取 Token。\n * Secure：仅通过 HTTPS 传输，防止中间人攻击。\n * SameSite=Strict/Lax：阻止跨站请求伪造（CSRF），现代浏览器默认 Lax。\n * 示例配置（服务端）：\n   \n   \n   \n   2. LocalStorage 的风险\n * XSS 攻击：一旦存在 XSS 漏洞，Token 会被直接窃取。\n * 无自动过期：需手动清理或依赖前端逻辑，易长期滞留。 三、适用场景建议 1. 优先选择 Cookie 的场景\n * 需要防御 XSS 窃取 Token：通过 HttpOnly 和 Secure 提升安全性。\n * 依赖自动携带 Token：简化前端代码，无需手动管理请求头。\n * 需要服务端控制会话：如设置过期时间、强制注销等。 2. 选择 LocalStorage 的场景\n * 需存储较大数据：如复杂的用户配置信息。\n * 跨域分离的前后端架构：如 JWT 需手动添加到 Authorization 头。\n * 对 CSRF 有独立防护：如已使用 CSRF Token 或加密请求参数。\n\n四、最佳实践\n\n 1. 使用 Cookie 的推荐方案：\n    \n    * 服务端设置 Cookie 时启用 HttpOnly、Secure 和 SameSite=Lax。\n    * 配合 CSRF Token（双重提交验证）或加密的请求参数。\n    * 示例流程：\n\n\n\n 2. 使用 LocalStorage 的防护措施：\n    \n    * 避免存储敏感信息，仅存 Token。\n    * 所有接口请求手动添加 Token 到 Authorization 头。\n    * 严格过滤输入输出，防御 XSS。\n    * 示例代码：\n\n\n\n五、面试回答模板\n\n“项目中如何选择 Token 存储方式？”\n\n> 我们优先选择 Cookie 存储 Token，并配置 HttpOnly、Secure 和 SameSite=Lax 防御 XSS 和\n> CSRF。对于需要更高灵活性的场景（如跨域分离架构），则用 LocalStorage 手动管理 Token，但会严格防御 XSS，如输入过滤、CSP\n> 策略。同时，无论哪种方式，都会确保 HTTPS 加密传输，并设置合理的 Token 过期时间。”\n\n通过结合安全需求和架构特点选择存储方式，并明确防御措施，可体现对安全与工程实践的深入理解。\n\n\n浏览器从输入 URL 到页面展示的整个过程#\n\n浏览器从输入 URL 到页面渲染的整个过程可以分为以下几个关键步骤：\n\n 1. URL 解析与输入处理\n    \n    * 浏览器解析用户输入，判断是 URL 还是搜索内容。如果是搜索词，使用默认搜索引擎进行搜索；否则，处理 URL。\n\n 2. DNS 解析\n    \n    * 将域名转换为 IP 地址：\n      1. 检查浏览器缓存 → 操作系统缓存 → 本地 Hosts 文件 → 递归查询 DNS 服务器（如未命中缓存）。\n\n 3. 建立 TCP 连接\n    \n    * 通过三次握手与服务器建立 TCP 连接：\n      \n      SYN → SYN-ACK → ACK。\n    * 若为 HTTPS，还需 TLS 握手（交换证书、协商加密算法、生成会话密钥）。\n\n 4. 发送 HTTP 请求\n    \n    * 浏览器发送 HTTP 请求，包含请求方法（如 GET）、请求头（User-Agent、Accept 等）。\n    * 若存在重定向（如 301/302），重新开始流程。\n\n 5. 服务器处理请求并返回响应\n    \n    * 服务器处理请求，返回 HTTP 响应（状态码、响应头、HTML 等资源）。\n\n 6. 浏览器解析与渲染\n    \n    * 构建 DOM 树：解析 HTML 生成 DOM 树，遇到","routePath":"/notes/interview/review","lang":"","toc":[{"text":"项目中遇到的最大挑战是什么,后来如何解决的","id":"项目中遇到的最大挑战是什么后来如何解决的","depth":3,"charIndex":3},{"text":"token 放在 cookie 还是 localStorage","id":"token-放在-cookie-还是-localstorage","depth":3,"charIndex":699},{"text":"浏览器从输入 URL 到页面展示的整个过程","id":"浏览器从输入-url-到页面展示的整个过程","depth":3,"charIndex":2348},{"text":"3.7 某医科技面试","id":"37-某医科技面试","depth":3,"charIndex":-1},{"text":"promise 状态吸收","id":"promise-状态吸收","depth":3,"charIndex":-1},{"text":"3.31 面试复盘","id":"331-面试复盘","depth":3,"charIndex":-1},{"text":"Echarts 性能调优,举例说明","id":"echarts-性能调优举例说明","depth":4,"charIndex":-1},{"text":"首屏加载速度","id":"首屏加载速度","depth":4,"charIndex":-1},{"text":"3.权限系统:后端菜单怎么转前端路由: 前端写死 和动态加载","id":"3权限系统后端菜单怎么转前端路由-前端写死-和动态加载","depth":4,"charIndex":-1},{"text":"4.浏览器事件循环","id":"4浏览器事件循环","depth":4,"charIndex":-1},{"text":"5.回流跟重绘","id":"5回流跟重绘","depth":4,"charIndex":-1},{"text":"6.一次性在页面上加载很多元素","id":"6一次性在页面上加载很多元素","depth":4,"charIndex":-1},{"text":"7.JS 判断是一个对象是空对象","id":"7js-判断是一个对象是空对象","depth":4,"charIndex":-1},{"text":"8.一个数组,需要依次用里面的 id 去调用接口获得用户信息,返回一个用户信息数组,编写代码","id":"8一个数组需要依次用里面的-id-去调用接口获得用户信息返回一个用户信息数组编写代码","depth":4,"charIndex":-1},{"text":"9.forEach 跳出循环","id":"9foreach-跳出循环","depth":4,"charIndex":-1},{"text":"10.精度问题","id":"10精度问题","depth":4,"charIndex":-1},{"text":"11.diff 算法","id":"11diff-算法","depth":4,"charIndex":-1},{"text":"4.16 面试复盘","id":"416-面试复盘","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":13,"title":"leetcode","content":"#\n\n\n刷题顺序#\n\n代码随想录 数组-> 链表-> 哈希表->字符串->栈与队列->树->回溯->贪心->动态规划->图论->高级数据结构\n\n\n数组#\n\n\n704. 二分查找#\n\n思路:双指针做二分查找,注意边界条件,不断收缩区间,直到找到目标值或者区间为空,更新的时候如果是 l 则更新 mid 位 l+1,如果是 r 则更新 mid 位\nr-1\n\n","routePath":"/notes/leetcode/","lang":"","toc":[{"text":"刷题顺序","id":"刷题顺序","depth":2,"charIndex":3},{"text":"数组","id":"数组","depth":2,"charIndex":72},{"text":"704. 二分查找","id":"704-二分查找","depth":3,"charIndex":78}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"React 基础","content":"#\n\n\n基础#\n\n\njsx 语法#\n\n必须存在根元素 用（）包裹\n\n不能插入 Object\n\n变量使用{}\n\nclass 在 jsx 中使用 className 防止 class 关键字冲突\n\nstyle 使用 style={{color:'red',fontSize:'12px'}} 把样式写成对象方式,不支持-连接\n\n\nreact 组件#\n\n数据构造 constructor this.state={}\n\n绑定方法 method=method.bind(this)\n\n分为函数组件和类组件\n\n类组件 class App extends React.component {}\n\n事件绑定：方法小驼峰命名，通过{}传入方法\n\n更新数据： this.setState({变量名:变量值})\n\nsetState 可能是同步也可能是异步的\n\n组件间数据传递 props 在组件中 使用 this.props.xx 读取\n\n传值: stuInfo={xxx} content=\"asdd\" num={112}\n\nprops.children 获取新建的内容\n\n使用 default 设置 props 的默认值\n\nHello.defalutProps={}\n\nreact 的状态提升 相当于父组件给子组件传递一个方法,在这个方法中改变父组件的值,相当于 vue 中的 emit\n\n早期类组件才能设置状态(现在有 hooks)\n\n受控组件\n\n原生: 获取 DOM 组件 拿到 value 值\n\nreact value 绑定到 state onChange 绑定输入方法\n\n表单控件完全受控于 state\n\n非受控组件:不绑定在 state\n\n在 react 中使用 React.createRef() //创建一个 ref 绑定到组件上,可以通过 ref 获取到组件\n\n表单数据用 ref 去 DOM 节点获取\n\n生命周期\n\n诞生到销毁经历了一系列过程就叫做生命周期\n\nrender componentDidMount 调用接口\n\ncomponentDidupdate\n\ncomponentDidUnmount 销毁计时器\n\n\nhook#\n\n常用的有 useState useEffect\n\n在没有编写 state 的情况下使用 state\n\nuseEffect\n\n * 纯函数:一个确切的参数在函数中运行后一定能得到一个确切的值\n * 如果一个函数存在副作用 则称该函数不是一个纯函数,副作用的结果就是不可控不可预期\n * 例子:发送请求,监听注册,取消注册,以前是使用生命周期勾子,现在使用 uesEffect\n * 是 React 中的一个 Hook，用于在函数组件中执行副作用操作。副作用操作包括数据获取、订阅、手动更改 DOM，以及在组件生命周期的特定阶段执行代码。\n\n使用场景\n\n * 数据获取 ：在组件挂载时获取数据。\n * 订阅 ：在组件挂载时订阅事件，并在卸载时取消订阅。\n * 手动 DOM 操作 ：在组件更新时手动操作 DOM。\n\nuseEffect 是 React 函数组件中处理副作用的主要工具，类似于类组件中的生命周期方法 componentDidMount 、\ncomponentDidUpdate 和 componentWillUnmount 。\n\n// 可选的清理函数\n\nreturn()=>{\n\n// 清理逻辑\n\nconsole.log('Cleaning up...');\n\n}; 在下一次执行 effect 函数之前执行\n\n依赖数组:\n\n * 无依赖数组 ：如果不提供依赖数组，effect 函数将在每次组件渲染后执行。\n * 空依赖数组 ：如果提供一个空数组，effect 函数只会在组件挂载和卸载时执行一次。\n * 依赖数组 ：如果提供了依赖数组，effect 函数将在组件挂载、卸载以及依赖项发生变化时执行。\n\n自定义 hook\n\n用 use 开头 并在内部调用原生 hooks\n\n\nreact-router#\n\n包裹根组件 BrowserRouter HashRouter 分别启动哈希模式和 history 模式\n\nRouter 主要是提供一个上下文环境\n\nRoute 在里面书写对应的路由 path 路由 element 匹配的组件\n\nNavigate 导航到某个组件 调用后返回一个函数\n\nuseLocation()拿到跳转给的参数 location.state\n\nNavLink a 标签\n\nuseParams 获取动态参数\n\nuseRouter 类似 vue 配置路由\n\nOutlet 父组件里面嵌套子路由使用\n\n在 useRoutes 配置 children 属性\n\n\nredux 状态管理#\n\n组件与组件之间统一的共享状态抽离到 redux 管理\n\nprops.store.getStore 获取仓库数据\n\nredux 直接绑定到 app 组件","routePath":"/notes/react/react","lang":"","toc":[{"text":"基础","id":"基础","depth":2,"charIndex":3},{"text":"jsx 语法","id":"jsx-语法","depth":3,"charIndex":9},{"text":"react 组件","id":"react-组件","depth":3,"charIndex":162},{"text":"hook","id":"hook","depth":3,"charIndex":908},{"text":"react-router","id":"react-router","depth":3,"charIndex":1659},{"text":"redux 状态管理","id":"redux-状态管理","depth":3,"charIndex":1959}],"domain":"","frontmatter":{},"version":""},{"id":15,"title":"TypeScript","content":"#\n\n@types 是一个第三方库 包含对 js 代码的类型描述\n\n * 类型描述 是对 js 代码的描述 描述的是 js 代码的结构和类型 @types/node\n\n\n基本类型约束#\n\n变量,函数的参数,函数的返回值限制类型 在变量后边加类型描述 ts 在很多场景可以完成类型推导 any 任意类型 推导不出来的 有三个点 用 any\n\n\n源代码和编译结果的差异#\n\n * 类型约束 不会出现在编译结果中 TS 类型检查 是静态的\n\n\n基本类型#\n\n * number\n * string\n * 数组 要指出每一项是什么类型 number[] string[] object[] Array\n * object 对象约束(用的比较少) 特殊类型 null undefined 严格模式下 不能赋值给 null 和 undefined\n\n\n其他常用类型#\n\n联合类型|连接符 typeof 可以触发简单类型保护 void 类型 没有返回值的函数 never 类型 永远不会结束函数 字面量类型 \"A\" 1 2\n以后只能赋值给某个字面量\n\n可以约束类型 元祖类型 固定长度的数组 约束每一项的类型 any 类型 绕过类型检查 可以赋值给任何类型\n\n\n类型别名#\n\n对已知的类型进行描述\n\n\n函数相关约束#\n\n函数重载:在函数实现之前,对函数调用的多种情况进行声明 可选参数?,不能放在首位\n\n\n扩展类型-枚举#\n\n扩展类型:类型别名/枚举/接口/类\n\n枚举: 约束某个变量的取值范围 枚举的类型: 数字枚举 字符串枚举 字面量和联合类型配合使用,可以达到同样的目标\n\n字面量类型存在问题\n\n * 不会进入到编译结果\n * 值混淆的话修改所需要的成本太高\n\n\n\n枚举会出现在编译结果中,表现为对象 枚举为字符串或者数字,数字的值会自增 数字枚举和字符串枚举有差异 最佳实践: 不要同时出现字符串和数字\n使用时尽量使用枚举字段的名称不要使用真实值\n\n位运算& | ~ ^ << >> 或| 可以用来判断是否拥有某个权限 且& 可以用来判断是否拥有某个权限 异或^ 可以用来删除权限 (相同取 0 不同取 1)\n\n\n模块化 TS#\n\n配置模块化导出导入模块 使用的是 es6 的模块化标准\n\n\n\n\n接口#\n\n扩展类型: 类型别名 枚举 接口 类 概念:用于约束类 对象 函数的契约(标准)\n\n不会出现在编译结果中 和类型别名一样 接口可以继承 让一个接口继承另一个接口所有成员 实现多种接口组合 在继承中不能去覆盖父接口成员的类型\n\n\n\n类型别名实现:& 交叉类型符,可以覆盖父接口成员的类型 使用少\n\nreadonly 只读属性 在接口中成员之前加 readonly 可以将成员变为只读属性 在编译后会被删除 readonly arr: readonly\nnumber[] 数组不能改变\n\n\n类型兼容性#\n\nB->A 如果能完成赋值则 B 和 A 是兼容的 鸭子辩型法 (子结构辩型法):目标类型需要某一些特征,赋值的类型只需要满足该特征即可\n\n基本类型完全匹配\n\n类型断言: as 关键词 直接使用字面量赋值,判定更严格\n\n\n类#\n\n面向对象思想 类 属性赋值 在构造函数中 在类中赋值 ?:可选属性 属性可以修饰为可选 / 只读 构造器中写上访问修饰符 可以正常赋值构造属性简写 访问修饰符\npublic/private/readonly\n\n\n访问器#\n\nset get 用来控制属性的读取\n\n\n泛型#\n\n在书写某个函数中会丢失一些类型信息 泛型:附属于函数类接口类型别名之上的类型 泛型可以设置默认值\n\n使用: 在函数名之后写上<泛型名称>通常写 在定义的时候不确定类型,在调用的时候传类型\n\n泛型约束 在 表示一个泛型继承了某个接口 某个类 用来限制泛型的取值 多泛型 返回(T | U)的结果类型 可以是 T 也可以是 U","routePath":"/notes/react/typescript","lang":"","toc":[{"text":"基本类型约束","id":"基本类型约束","depth":2,"charIndex":84},{"text":"源代码和编译结果的差异","id":"源代码和编译结果的差异","depth":3,"charIndex":170},{"text":"基本类型","id":"基本类型","depth":2,"charIndex":218},{"text":"其他常用类型","id":"其他常用类型","depth":2,"charIndex":369},{"text":"类型别名","id":"类型别名","depth":2,"charIndex":523},{"text":"函数相关约束","id":"函数相关约束","depth":2,"charIndex":543},{"text":"扩展类型-枚举","id":"扩展类型-枚举","depth":2,"charIndex":595},{"text":"模块化 TS","id":"模块化-ts","depth":2,"charIndex":903},{"text":"接口","id":"接口","depth":2,"charIndex":944},{"text":"类型兼容性","id":"类型兼容性","depth":2,"charIndex":1192},{"text":"类","id":"类","depth":2,"charIndex":1310},{"text":"访问器","id":"访问器","depth":3,"charIndex":1420},{"text":"泛型","id":"泛型","depth":2,"charIndex":1446}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"Vue in One Page","content":"#\n\n\nVue 实例属性和方法#\n\n * $data: 获取数据对象\n * $props: 获取传入的 props\n * $el: 获取根 DOM 元素\n * $refs: 获取注册过 ref 的所有 DOM 元素或组件实例\n * $watch: 观察数据变化\n\n\n生命周期#\n\n\nVue2 生命周期钩子#\n\n 1. 创建阶段\n    \n    * beforeCreate: 实例初始化之后，数据观测和事件配置之前调用\n    * created: 实例创建完成后调用，此时可以访问数据\n\n 2. 挂载阶段\n    \n    * beforeMount: 挂载开始之前调用\n    * mounted: 挂载完成后调用，可以访问 DOM\n\n 3. 更新阶段\n    \n    * beforeUpdate: 数据更新时调用，发生在虚拟 DOM 打补丁之前\n    * updated: 由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用\n\n 4. 销毁阶段\n    \n    * beforeDestroy: 实例销毁之前调用\n    * destroyed: 实例销毁后调用\n\n\nVue3 生命周期钩子#\n\n 1. 创建阶段\n    \n    * setup: 开始创建组件之前执行，在 beforeCreate 和 created 之前执行\n\n 2. 挂载阶段\n    \n    * onBeforeMount: 挂载开始之前调用\n    * onMounted: 挂载完成后调用\n\n 3. 更新阶段\n    \n    * onBeforeUpdate: 数据更新时调用，发生在虚拟 DOM 打补丁之前\n    * onUpdated: 数据更新后调用\n\n 4. 销毁阶段\n    \n    * onBeforeUnmount: 实例销毁之前调用（替代 beforeDestroy）\n    * onUnmounted: 实例销毁后调用（替代 destroyed）\n\n\n生命周期图示#\n\n\n\n\n模板语法#\n\n\n插值#\n\n * 文本插值：{{ message }}\n * HTML：v-html=\"rawHtml\"\n * 属性：v-bind:id=\"dynamicId\" 或简写 :id=\"dynamicId\"\n\n\n指令#\n\n 1. 条件渲染\n    \n    \n\n 2. 列表渲染\n    \n    \n\n 3. 事件处理\n    \n    \n\n 4. 表单输入绑定\n    \n    \n\n\n计算属性与侦听器#\n\n\n计算属性#\n\n\n\n\n侦听器#\n\n\n\n\nClass 与 Style 绑定#\n\n\nClass 绑定#\n\n\n\n\nStyle 绑定#\n\n\n\n\n组件系统#\n\n\n组件注册与使用#\n\n\n\n\nProps 与 Events#\n\n\n\n\n响应式原理#\n\n\nVue2 响应式原理#\n\n * 使用 Object.defineProperty 实现数据劫持\n   \n   \n\n * 主要特点：\n   * 对象属性必须提前声明\n   * 不能检测数组长度变化\n   * 不能检测对象属性的添加和删除\n   * 需要遍历对象所有属性\n * 解决方案：\n   * 使用 Vue.set() 或 this.$set() 添加响应式属性\n   * 使用 Vue.delete() 或 this.$delete() 删除属性\n   * 使用数组方法：push、pop、shift、unshift、splice、sort、reverse\n * 源码实现关键点：\n   * Observer：将数据对象的所有属性转换为 getter/setter\n   * Dep：依赖收集器，存储所有依赖（Watcher）\n   * Watcher：订阅者，负责触发视图更新\n\n\nVue3 响应式原理#\n\n * 使用 Proxy 实现响应式系统\n   \n   \n\n * 主要特点：\n   * 可以监听动态添加的属性\n   * 可以监听数组的索引和长度变化\n   * 可以监听删除的属性\n   * 不需要遍历对象所有属性\n   * 支持 Map、Set、WeakMap、WeakSet\n * 性能优势：\n   * 初始化性能更好，不需要递归遍历\n   * 内存占用更少\n   * 可以懒处理嵌套对象\n * 响应式 API：\n   * reactive：深层响应式代理\n   * ref：处理基本类型的响应式\n   * readonly：创建只读代理\n   * shallowReactive：浅层响应式\n   * shallowRef：浅层 ref\n\n\n常见面试题解答#\n\n 1. Vue2 和 Vue3 响应式的区别？\n    \n    * 实现原理不同：Vue2 使用 Object.defineProperty，Vue3 使用 Proxy\n    * 性能差异：Vue3 初始化更快，内存占用更少\n    * 功能限制：Vue2 无法监听属性添加/删除，Vue3 可以\n    * 数组处理：Vue2 需要特殊处理数组方法，Vue3 可以直接监听\n\n 2. 为什么 Vue2 不能检测数组长度变化？\n    \n    * Object.defineProperty 不能监听数组长度的变化\n    * Vue2 通过重写数组方法来实现响应式\n    * 直接通过索引修改数组不会触发更新\n\n 3. Vue3 为什么使用 Proxy？\n    \n    * 可以直接监听对象而非属性\n    * 可以监听动态添加的属性\n    * 可以监听数组的变化\n    * 可以监听对象的删除操作\n\n 4. Vue.set 的实现原理？\n    \n    \n\n 5. Vue3 ref 和 reactive 的区别？\n    \n    * ref 用于基本类型，reactive 用于对象\n    * ref 需要.value 访问，reactive 直接访问\n    * ref 可以用于模板，不需要.value\n    * reactive 不能用于基本类型\n\n\n高频面试题#\n\n\n组件通信#\n\n 1. 父子组件通信\n    \n    * Props / $emit\n    * $refs / $parent\n    * v-model / .sync (Vue2)\n    * provide / inject\n\n 2. 兄弟组件通信\n    \n    * EventBus\n    * Vuex / Pinia\n    * 通过共同的父组件\n\n 3. 跨层级组件通信\n    \n    * Vuex / Pinia\n    * provide / inject\n    * EventBus\n\n\n组件复用#\n\n 1. Vue2 复用方式\n    \n    \n\n 2. Vue3 复用方式\n    \n    \n\n\n核心概念对比#\n\n 1. 选项式 API vs 组合式 API\n    \n    * 选项式 API：\n      * 按 options 组织代码\n      * 适合简单组件\n      * 学习成本低\n    * 组合式 API：\n      * 按功能组织代码\n      * 更好的代码复用\n      * TypeScript 支持更好\n\n 2. 响应式系统\n    \n    * Vue2：Object.defineProperty\n      * 需要遍历对象属性\n      * 不能监听数组长度变化\n      * 不能监听对象属性添加/删除\n    * Vue3：Proxy\n      * 可以监听整个对象\n      * 可以监听数组变化\n      * 可以监听属性添加/删除\n\n\n性能优化建议#\n\n 1. Vue2 优化\n    \n    * 使用 Object.freeze() 冻结不需要响应式的数据\n    * 使用 v-show 代替频繁切换的 v-if\n    * 合理使用 computed 缓存\n    * 避免深度监听大数据\n    * 使用函数式组件\n    * 路由懒加载\n    * 第三方库按需引入\n\n 2. Vue3 优化\n    \n    * 使用 shallowRef 和 shallowReactive 处理大数据\n    * 使用 markRaw 标记不需要响应式的数据\n    * 合理使用 computed 和 watchEffect\n    * 使用 v-memo 缓存模板\n    * 使用 Suspense 和异步组件\n    * 动态导入组件\n    * Tree-shaking 优化\n\n\n虚拟 DOM#\n\n * 虚拟 DOM 树的构建\n   \n   * 用 JavaScript 对象描述 DOM 结构\n   * 通过 render 函数生成虚拟 DOM 树\n   * 数据变化时生成新的虚拟 DOM 树\n\n * Diff 算法实现\n   \n   1. Vue2 双端比较算法\n      \n      * 同时从新旧节点的两端开始比较\n      * 四个指针：新头、新尾、旧头、旧尾\n      * 比较策略：\n        \n        \n      \n      * 如果四种比较都未命中，则按 key 比较\n   \n   2. Vue3 快速 Diff 算法\n      \n      * 借鉴了 ivi 和 inferno 的算法\n      * 相同的前置和后置节点的预处理\n      * 最长递增子序列算法优化节点移动\n      \n      \n\n * 性能优化策略\n   \n   * 使用唯一 key 进行节点复用\n   * 避免无谓的节点更新\n   * 采用异步更新","routePath":"/notes/vue/","lang":"","toc":[{"text":"Vue 实例属性和方法","id":"vue-实例属性和方法","depth":3,"charIndex":3},{"text":"生命周期","id":"生命周期","depth":2,"charIndex":132},{"text":"Vue2 生命周期钩子","id":"vue2-生命周期钩子","depth":3,"charIndex":140},{"text":"Vue3 生命周期钩子","id":"vue3-生命周期钩子","depth":3,"charIndex":494},{"text":"生命周期图示","id":"生命周期图示","depth":3,"charIndex":840},{"text":"模板语法","id":"模板语法","depth":2,"charIndex":852},{"text":"插值","id":"插值","depth":3,"charIndex":860},{"text":"指令","id":"指令","depth":3,"charIndex":962},{"text":"计算属性与侦听器","id":"计算属性与侦听器","depth":2,"charIndex":1050},{"text":"计算属性","id":"计算属性","depth":3,"charIndex":1062},{"text":"侦听器","id":"侦听器","depth":3,"charIndex":1072},{"text":"Class 与 Style 绑定","id":"class-与-style-绑定","depth":2,"charIndex":1081},{"text":"Class 绑定","id":"class-绑定","depth":3,"charIndex":1101},{"text":"Style 绑定","id":"style-绑定","depth":3,"charIndex":1115},{"text":"组件系统","id":"组件系统","depth":2,"charIndex":1129},{"text":"组件注册与使用","id":"组件注册与使用","depth":3,"charIndex":1137},{"text":"Props 与 Events","id":"props-与-events","depth":3,"charIndex":1150},{"text":"响应式原理","id":"响应式原理","depth":2,"charIndex":1170},{"text":"Vue2 响应式原理","id":"vue2-响应式原理","depth":3,"charIndex":1179},{"text":"Vue3 响应式原理","id":"vue3-响应式原理","depth":3,"charIndex":1573},{"text":"常见面试题解答","id":"常见面试题解答","depth":3,"charIndex":1909},{"text":"高频面试题","id":"高频面试题","depth":2,"charIndex":2513},{"text":"组件通信","id":"组件通信","depth":3,"charIndex":2522},{"text":"组件复用","id":"组件复用","depth":3,"charIndex":2782},{"text":"核心概念对比","id":"核心概念对比","depth":3,"charIndex":2840},{"text":"性能优化建议","id":"性能优化建议","depth":3,"charIndex":3195},{"text":"虚拟 DOM","id":"虚拟-dom","depth":3,"charIndex":3574}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"VUE 原理与源码深入","content":"#\n\n\nkeep-alive 原理#\n\n内置组件,用来在多个组件间动态切换时缓存被移除的组件实例 属性 include :缓存的组件名称 支持字符串正则数组 exclude:不缓存的组件 prop\n来定制行为 传入 max prop 来限制可被缓存的最大组件实例数 指定 max 后内部执行类 LRU 算法: 如果缓存的实例数量即将超过指定的\nmax,则最久没有访问的缓存实例被销毁 底层原理 set? 生命周期勾子 onActivated 和 onDeacticated\n注册两个状态的生命周期勾子,只有开启了才会增加\n\n\n虚拟 DOM DIFF#\n\nkey 值 不能去重复 vue2:双端 diff 算法:头和头 尾和尾 头和尾 尾和头 没有给key的 diff 算法: for 循环重新渲染元素\n替换掉,如果有多的就会新增,如果减少了就会删除,有不必要的更新,没有复用 有key 五步走, isSameNodeType 判断是否是同一个类型且 key\n相等,先进行前序对比 如果有存在不同的 就跳出循环进行尾序对比,比 vue2 少了 交叉对比,如果有新的节点 就挂在 如果旧节点多旧卸载\n\n> 特殊乱序情况: 1.构建新节点的映射关系 keyToNewIndexMap 2.记录新节点在旧节点中的位置数组\n> 3.如果出现交叉求最长递增子序列(贪心+二分查找) 4.如果当前遍历的节点不在子序列中说明要进行移动","routePath":"/notes/vue/principle","lang":"","toc":[{"text":"keep-alive 原理","id":"keep-alive-原理","depth":2,"charIndex":3},{"text":"虚拟 DOM DIFF","id":"虚拟-dom-diff","depth":2,"charIndex":262}],"domain":"","frontmatter":{},"version":""}]