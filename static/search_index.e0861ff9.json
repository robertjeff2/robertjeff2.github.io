[{"id":0,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! 🎁","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"设计模式","content":"#\n\n设计模式是软件开发中常见问题的典型解决方案。每个模式都像一个蓝图，可以通过自定义来解决代码中的特定设计问题。在前端开发中，设计模式帮助我们编写更加可维护、可扩展\n的代码。\n\n\n设计模式的重要性#\n\n在前端面试中，设计模式是一个重要的考察点，主要关注以下几个方面：\n\n 1. 代码复用性和可维护性：通过合适的设计模式，可以提高代码的复用性，降低维护成本\n 2. 解耦和扩展性：好的设计模式可以实现模块间的解耦，使系统更容易扩展\n 3. 团队协作：设计模式提供了一种通用的解决方案，有助于团队成员之间的沟通\n 4. 性能优化：某些设计模式（如单例、享元模式）可以帮助优化应用性能\n\n\n选择设计模式的原则#\n\n在实际开发中，选择合适的设计模式需要考虑以下因素：\n\n 1. 场景适用性：不同的设计模式适用于不同的问题场景\n 2. 复杂度权衡：避免过度设计，在简单性和扩展性之间找到平衡\n 3. 团队水平：考虑团队对设计模式的理解和接受程度\n 4. 维护成本：评估采用某种设计模式后的长期维护成本\n\n\n设计模式分类#\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n创建型模式#\n\n创建型模式关注对象的创建过程，在前端开发中常用于组件和服务的实例化。\n\n * 工厂方法模式：用于创建不同类型的组件或服务\n   \n   \n\n * 单例模式：确保一个类只有一个实例，常用于全局状态管理\n   \n   \n\n * 建造者模式：用于分步骤创建复杂对象\n\n * 原型模式：通过克隆创建对象\n\n\n结构型模式#\n\n结构型模式关注类和对象的组合，在前端开发中用于优化组件结构和提高代码复用性。\n\n * 适配器模式：用于兼容不同接口，常用于处理 API 响应\n   \n   \n\n * 装饰器模式：动态地给对象添加功能，如 React 高阶组件\n   \n   \n\n * 代理模式：控制对对象的访问，如 Vue3 的响应式系统\n\n * 组合模式：将对象组合成树形结构\n\n * 外观模式：为子系统提供统一的接口\n\n\n行为型模式#\n\n行为型模式关注对象之间的通信，在前端开发中用于处理组件通信和状态管理。\n\n * 观察者模式：定义对象间的一对多依赖关系，常用于事件处理\n   \n   \n\n * 策略模式：定义一系列算法，使它们可以互相替换，如表单验证\n   \n   \n\n * 状态模式：允许对象在内部状态改变时改变它的行为\n\n * 命令模式：将请求封装成对象\n\n * 中介者模式：用于组件间的解耦\n\n\n前端开发中的最佳实践#\n\n 1. 组件设计\n    \n    * 使用工厂模式创建可配置的组件\n    * 使用装饰器模式增强组件功能\n    * 使用组合模式构建组件树\n\n 2. 状态管理\n    \n    * 使用单例模式实现全局状态\n    * 使用观察者模式处理状态变化\n    * 使用代理模式实现响应式\n\n 3. 数据处理\n    \n    * 使用适配器模式处理 API 数据\n    * 使用策略模式处理表单验证\n    * 使用命令模式处理用户操作","routePath":"/notes/design-pattern/","lang":"","toc":[{"text":"设计模式的重要性","id":"设计模式的重要性","depth":2,"charIndex":90},{"text":"选择设计模式的原则","id":"选择设计模式的原则","depth":2,"charIndex":292},{"text":"设计模式分类","id":"设计模式分类","depth":2,"charIndex":448},{"text":"创建型模式","id":"创建型模式","depth":3,"charIndex":458},{"text":"结构型模式","id":"结构型模式","depth":3,"charIndex":616},{"text":"行为型模式","id":"行为型模式","depth":3,"charIndex":820},{"text":"创建型模式","id":"创建型模式-1","depth":3,"charIndex":1012},{"text":"结构型模式","id":"结构型模式-1","depth":3,"charIndex":1170},{"text":"行为型模式","id":"行为型模式-1","depth":3,"charIndex":1374},{"text":"前端开发中的最佳实践","id":"前端开发中的最佳实践","depth":2,"charIndex":1566}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"发布订阅模式","content":"#\n\n\n简介#\n\n发布-订阅模式（Pub-Sub）是一种设计模式，用于在对象之间实现松耦合的通信。它允许一个对象（发布者）向多个对象（订阅者）发送消息，而发布者和订阅者之间不需要\n直接知道对方的存在。订阅者可以订阅感兴趣的事件，发布者可以在事件发生时通知所有订阅者。\n\n\n适用场景#\n\n这种模式在前端开发中非常常见，比如：\n\n事件驱动编程：DOM 事件（如 click、input）就是典型的发布-订阅模式。\n\n状态管理：在 Vue 或 React 中，全局状态管理工具（如 Vuex、Redux）的核心思想就是基于发布-订阅模式。\n\n组件通信：父子组件、兄弟组件之间的通信可以通过自定义事件（如 Vue 的 $emit 和 $on）实现。\n\n异步任务管理：比如消息队列、WebSocket 消息推送等。\n\n\n手写代码实现#\n\n\n\n * events 对象：用于存储事件名称和对应的回调函数列表。\n * subscribe 方法：允许订阅者订阅某个事件，并将回调函数添加到事件列表中。\n * publish 方法：当事件被触发时，遍历并执行所有订阅该事件的回调函数。\n * unsubscribe 方法：允许订阅者取消订阅，移除指定的回调函数。\n\n\n举例说明#\n\n可以用它来实现一个简单的消息通知系统\n\n\n\n\n扩展点#\n\n * 性能优化：如果事件列表很大，如何优化回调函数的执行效率？\n   \n   > 可以通过限制回调函数的数量、使用异步执行（如 setTimeout 或 Promise）来避免阻塞主线程。\n\n * 一次性订阅：如何实现只触发一次的事件订阅？\n   \n   > 可以在 subscribe 方法中添加一个标志位，执行一次后自动取消订阅。\n\n * 错误处理：如何处理回调函数中的错误？\n   \n   > 可以在 publish 方法中添加 try-catch，确保一个回调函数的错误不会影响其他回调函数的执行。\n\n\n总结#\n\n发布-订阅模式的优点是实现了对象之间的解耦，让代码更易于维护和扩展，特别适合处理复杂的异步通信场景。","routePath":"/notes/design-pattern/pubSub","lang":"","toc":[{"text":"简介","id":"简介","depth":2,"charIndex":3},{"text":"适用场景","id":"适用场景","depth":2,"charIndex":135},{"text":"手写代码实现","id":"手写代码实现","depth":2,"charIndex":354},{"text":"举例说明","id":"举例说明","depth":2,"charIndex":524},{"text":"扩展点","id":"扩展点","depth":2,"charIndex":554},{"text":"总结","id":"总结","depth":2,"charIndex":816}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"面试常见手写代码","content":"#\n\n这个分类主要记录前端开发中常见的手写代码实现，包括但不限于：\n\n * 防抖节流\n * 深浅拷贝\n * Promise 实现\n * 数组方法实现\n * 对象方法实现\n * 函数柯里化\n * 事件总线\n * 观察者模式\n\n这些代码实现不仅是面试中的高频考点，也是加深对 JavaScript 理解的重要方式。每个实现都会包含详细的代码注释和实现思路说明，帮助更好地理解其中的原理。","routePath":"/notes/handwriting/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":5,"title":"手写防抖节流","content":"#\n\n> 首先，防抖和节流都是用来优化高频触发的事件，比如滚动、输入或者窗口调整，防止这些事件处理函数被频繁调用，影响性能。不过它们的实现方式和应用场景不同，我得先搞\n> 清楚两者的区别。防抖（Debounce）的话，我记得是当事件被触发后，一定时间内的多次触发只会执行最后一次，或者只在开始时执行一次。比如搜索框输入，用户停止\n> 输入一段时间后才发送请求，避免每次按键都请求。而节流（Throttle）则是每隔一定时间执行一次，不管事件触发有多频繁，比如滚动事件，每隔 200ms\n> 执行一次处理函数。\n\n\n回答步骤#\n\n 1. 解释防抖和节流的定义和区别。\n\n 2. 写出基本的实现代码，并解释每一步的作用。\n\n 3. 比较不同实现方式的差异。\n\n 4. 举例说明应用场景。\n\n\n1. 防抖（Debounce）#\n\n定义：高频事件触发后，在指定时间内只执行最后一次。若在等待期内再次触发，则重新计时。\n\n应用场景：搜索框输入联想、窗口大小调整（resize）。\n\n实现思路：\n\n * 利用定时器，每次触发时重置定时。\n * 支持立即执行（首次触发立即执行，后续需等待停止触发）。\n\n代码示例：\n\n\n\n关键点：\n\n * 使用闭包保存 timeout。\n * 立即执行逻辑：首次触发且未在等待期内时执行。\n * clearTimeout 确保每次触发重置计时。\n\n--------------------------------------------------------------------------------\n\n\n2. 节流（Throttle）#\n\n定义：高频事件触发时，每隔指定时间执行一次，稀释执行频率。\n\n应用场景：滚动加载（scroll）、高频点击（如抢购按钮）。\n\n实现思路：\n\n * 时间戳版：记录上次执行时间，若间隔超过阈值则执行。\n * 定时器版：延迟执行，执行后重置定时器。\n * 结合版（推荐）：首次立即执行，最后一次触发延迟执行。\n\n代码示例（结合版）：\n\n\n\n关键点：\n\n * remaining 计算剩余等待时间。\n * 首次触发立即执行，最后一次触发在剩余时间后执行。\n * 定时器与时间戳结合，确保首尾触发均被执行。\n\n--------------------------------------------------------------------------------\n\n\n3. 对比与总结#\n\n特性     防抖（DEBOUNCE）    节流（THROTTLE）\n执行时机   最后一次触发后等待结束执行   固定间隔执行\n应用场景   搜索联想、resize     滚动事件、高频点击\n核心逻辑   重置定时器           时间间隔控制\n\n--------------------------------------------------------------------------------\n\n回答技巧：\n\n 1. 先解释概念：明确防抖和节流的定义及区别。\n 2. 手写代码：逐步写出代码并解释关键步骤（如闭包、定时器、this 绑定）。\n 3. 举例场景：结合具体场景说明为何选择防抖或节流。\n 4. 扩展优化：提及取消功能（如 debounced.cancel()）或参数配置（如 leading 和 trailing）。\n\n通过清晰的结构和代码示例，展示对性能优化问题的深入理解。","routePath":"/notes/handwriting/throttle","lang":"","toc":[{"text":"回答步骤","id":"回答步骤","depth":2,"charIndex":256},{"text":"**1. 防抖（Debounce）**","id":"1-防抖debounce","depth":3,"charIndex":-1},{"text":"**2. 节流（Throttle）**","id":"2-节流throttle","depth":3,"charIndex":-1},{"text":"**3. 对比与总结**","id":"3-对比与总结","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":6,"title":"学习笔记","content":"#\n\n欢迎来到我的博客！这里记录了我在学习过程中的心得体会和技术积累。\n\n\n关于这些笔记#\n\n这些笔记是我在学习过程中的总结和思考。我会不断更新和完善这些内容，希望能够帮助到同样在学习的你。如果你发现任何问题或有任何建议，欢迎与我交流。","routePath":"/notes/","lang":"","toc":[{"text":"关于这些笔记","id":"关于这些笔记","depth":2,"charIndex":37}],"domain":"","frontmatter":{},"version":""},{"id":7,"title":"前端面试准备","content":"#\n\n\n目录#\n\n * JS 基础(一)\n * 基础类型\n * this\n * JS 基础(二)\n   * 闭包\n   * 深浅拷贝\n   * 浅拷贝\n   * 深拷贝\n   * 原型\n * ES6\n   * var let const\n   * class 继承\n   * 模块化\n   * Proxy\n   * 数组方法 map,filter,reduce\n * JS 异步编程题\n   * Promise\n * 面试专项题\n   * AJAX fetch axios\n   * 防抖节流什么区别\n\n\n一、技术基础强化（核心必考）#\n\n1. JavaScript 底层原理#\n\n * 闭包/作用域链：手写闭包场景，解释内存泄漏风险。\n * 原型链与继承：实现寄生组合继承，对比 ES6 class 差异。\n * Event Loop：结合宏任务/微任务分析代码执行顺序，解释 Promise、async/await 的底层逻辑。\n * 手写高频 API：实现 Promise.all、深拷贝、防抖/节流、柯里化函数 等。\n\n2. 框架核心原理#\n\n * React：\n   * 虚拟 DOM Diff 算法优化逻辑。\n   * Hooks 原理（如 useState 如何绑定到 Fiber 节点）。\n   * 性能优化手段（React.memo、useMemo 使用场景）。\n * Vue：\n   * 响应式原理（Vue2 的 Object.defineProperty 与 Vue3 的 Proxy 对比）。\n   * 模板编译流程（AST 转换到 render 函数）。\n   * 手写简易版 Vue 响应式系统。\n\n3. 浏览器与网络#\n\n * 渲染机制：从输入 URL 到页面渲染的完整流程，关键优化点（如 CRP 优化）。\n * 缓存策略：强缓存与协商缓存的 Header 字段，Service Worker 应用场景。\n * 跨域解决方案：CORS 预检请求细节，JSONP 安全性问题。\n\n4. 前端工程化#\n\n * Webpack：\n   * 打包流程（Loader 与 Plugin 的区别）。\n   * 优化配置（Tree Shaking 原理、Code Splitting 策略）。\n * 性能监控：\n   * 使用 Lighthouse 分析性能指标（FCP、LCP、CLS）。\n   * 实现前端错误监控（SourceMap 还原线上错误）。\n\n--------------------------------------------------------------------------------\n\n\n二、项目经验深挖（高频追问点）#\n\n1. 项目难点与解决方案#\n\n * 典型问题：\n   * “介绍一个你主导的复杂项目，如何设计技术方案？”\n   * “遇到过哪些性能瓶颈？如何定位并解决？”\n * 回答策略：\n   * 使用 STAR 法则（背景、任务、行动、结果）。\n   * 量化成果：如“首屏加载时间从 3s 优化至 1.2s”。\n\n2. 技术选型与权衡#\n\n * 准备问题：\n   * “为什么选择 React 而不是 Vue？”\n   * “微前端方案（如 qiankun）的落地挑战是什么？”\n * 加分回答：\n   * 结合业务场景（如团队协作成本、生态支持度）分析。\n\n3. 协作与流程优化#\n\n * 举例说明：\n   * 如何推动团队落地代码规范（ESLint + Git Hooks）。\n   * 设计前端埋点系统或 CI/CD 自动化流程。\n\n--------------------------------------------------------------------------------\n\n\n三、算法与数据结构（大厂必考）#\n\n1. 刷题重点#\n\n * 高频题型：数组/字符串操作、链表、二叉树、DFS/BFS、动态规划。\n * 前端相关题：DOM 树遍历（递归/迭代）、模板解析（栈结构应用）。\n\n2. 刷题策略#\n\n * LeetCode 精选：优先刷 Hot 100 和前端厂题库（如字节、阿里）。\n * 手写代码规范：注重边界条件处理，代码可读性（命名、注释）。\n\n--------------------------------------------------------------------------------\n\n\n四、系统设计能力（高阶岗位重点）#\n\n1. 前端架构设计#\n\n * 场景题：\n   * “设计一个高并发场景下的前端缓存方案。”\n   * “如何实现跨团队组件库的灰度发布？”\n * 考察点：模块拆分、状态管理、异常兜底方案。\n\n2. 全栈能力验证#\n\n * 准备方向：\n   * 实现一个 SSR（服务端渲染）方案。\n   * 设计一个短链生成系统的前后端架构。\n\n--------------------------------------------------------------------------------\n\n\n五、行为面试与软技能#\n\n1. 常见问题#\n\n * “为什么离开上一家公司？”\n * “如何推动技术方案在团队中落地？”\n * “与产品经理发生分歧时如何处理？”\n\n2. 回答技巧#\n\n * 避坑指南：避免抱怨前公司，聚焦个人成长诉求。\n * 展示潜力：强调自主学习（如“通过研究 WebAssembly 优化项目性能”）。\n\n--------------------------------------------------------------------------------\n\n\n六、简历优化与面试模拟#\n\n1. 简历打磨#\n\n * 突出亮点：使用关键词如“性能优化 40%”“主导组件库重构”。\n * 数据支撑：如“日均 PV 1000 万+的系统稳定性保障”。\n\n2. 模拟面试#\n\n * 技术模拟：找同行模拟框架原理追问（如“React Fiber 如何中断/恢复任务”）。\n * 压力测试：练习在白板上手写代码并解释思路。\n\n--------------------------------------------------------------------------------\n\n\n七、资源推荐#\n\n * 书籍：《JavaScript 高级程序设计》《前端架构设计》\n * 学习平台：极客时间（前端进阶课）、Frontend Masters\n * 工具：CodeSandbox 在线编码练习、Chrome DevTools 性能分析实战\n\n--------------------------------------------------------------------------------\n\n\n八、面试后复盘#\n\n * 记录问题：整理被问倒的技术点，针对性补漏。\n * 横向对比：分析不同公司对“3 年经验前端”的能力侧重（如大厂重算法，创业公司重落地速度）。\n\n\nJS 基础(一)#\n\n\n基础类型#\n\n原始类型\n\nboolean null undefined number string symbol\n\ntypeof null会输出object 属于 js 遗留 bug\n\n对象类型\n\n对象类型存储的是地址 原始类型存储的是值\n\nObject function array 等\n\n> typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？\n\ntypeof对于原始类型来说，除了null都可以显示正确的类型\n\n\n\n对于对象来说 除了 function 都是 Object 所以不准确\n\ninstanceof 是用来判断对象的类型 内部机制是通过原型链来判断的\n\ninstanceof 支持自定义 , Symbol.hasInstance\n\n\nthis#\n\n\n\n * 对于直接调用foo来说，不管foo函数被放在了什么地方，this一定是window\n * 对于obj.foo()来说，我们只需要记住，谁调用了函数，谁就是this，所以在这个场景下foo函数中的this就是obj对象\n * 对于new的方式来说，this被永远绑定在了c上面，不会被任何方式改变this\n\n箭头函数中的 this 取决的是外层作用域的 this 如果没有,就往上层作用域查找 this\n\nnew的方式优先级最高，接下来是bind这些函数，然后是obj.foo()这种调用方式，最后是foo这种调用方式，同时，箭头函数的this一旦被绑定，就不会再被\n任何方式所改变。\n\n\nJS 基础(二)#\n\n> == 和 === 有什么区别？\n\n==来说，如果对比双方的类型不一样的话，就会进行类型转换，这也就用到了我们上一章节讲的内容。\n\n=== 是值和类型都相等\n\n闭包#\n\n涉及面试题：什么是闭包？\n\n闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。\n\n> 循环中使用闭包解决 var 定义函数的问题\n\n\n\n可以使用闭包解决\n\n\n\n在上述代码中，我们首先使用了立即执行函数将i传入函数内部，这个时候值就被固定在了参数j上面不会改变，当下次执行timer这个闭包的时候，就可以使用外部函数的变量\nj，从而达到目的。\n\n深浅拷贝#\n\n浅拷贝#\n\n1.浅拷贝通过Object.assign 实现,\nObject.assign只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。\n\n2.通过展开运算符实现...\n\n浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话,就需要用深拷贝实现\n\n深拷贝#\n\n 1. JSON.parse(JSON.stringify(object))\n\n局限性:\n\n * 会忽略undefined\n * 会忽略symbol\n * 不能序列化函数\n * 不能解决循环引用的对象\n\n 1. 不包含函数的 可以使用 MessageChannel\n 2. 自己实现深拷贝\n\n通过判断类型,递归实现\n\n\n\n原型#\n\n> 面试题: 如何理解原型？如何理解原型链？\n\n每一个对象上的内置属性 prototype\n\n对象原型__proto__\n\n函数原型prototype\n\n直接读取存在兼容性问题 Object.getPrototypeOf 方法获取(生产环境)\n\n原型之间相互引用形成了链条,即一个指向一个最顶层为null\n\n> 补充：new 操作符做的事情\n\n> 1.创建一个新对象\n\n> 2.将函数的 this 绑定到这个对象上\n\n> 3.将函数的 prottyp 复制给新对象的[prototype]属性\n\n> 4.默认返回这个新对象\n\n总结:\n\n * Object是所有对象的爸爸，所有对象都可以通过__proto__找到它\n * Function是所有函数的爸爸，所有函数都可以通过__proto__找到它\n * 函数的prototype是一个对象\n * 对象的__proto__属性指向原型，__proto__将对象和原型连接起来组成了原型链\n\n\nES6#\n\nvar let const#\n\n> 涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？\n\nvar : 使用var声明的变量会被提升到作用域的顶部\n\nlet、const因为暂时性死区的原因，不能在声明前使用\n\nvar在全局作用域下声明变量会导致变量挂载在window上，其他两者不会\n\nclass 继承#\n\n在 js 中并不存在类, class 是语法糖本质还是函数\n\n原型继承\n\n\n\n通过Parent.call(this)继承父类的属性，然后改变子类的原型为new Parent()来继承父类的函数\n\n继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了\n不需要的父类属性，存在内存上的浪费。\n\nclass 继承\n\n\n\nclass实现继承的核心在于使用extends表明继承自哪个父类，并且在子类构造函数中必须调用super，因为这段代码可以看成Parent.call(this,\nvalue)\n\n模块化#\n\n> 面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？\n\ncommonJs\n\n在 Webpack 中经常可以见到 ,在打包后的 js 文件里\n\n支持动态导入,使用require()\n\nEs module\n\n原生实现的模块化方案\n\n\n\n * CommonJS 支持动态导入，也就是require(${path}/xx.js)，后者目前不支持，但是已有提案\n * CommonJS\n   是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很\n   大影响\n * CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module\n   采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化\n * ES Module 会编译成require/exports来执行的\n\nProxy#\n\nvue3 的响应式实现原理\n\n\n\n需要我们在get中收集依赖，在set派发更新，之所以 Vue3.0 要使用Proxy替换原本的 API\n原因在于Proxy无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是Proxy可以完美监听到任何方\n式的数据改变，缺陷可能就是浏览器的兼容性不好了。\n\n数组方法 map,filter,reduce#\n\nmap作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。\n\n\n\n另外map的回调函数接受三个参数，分别是当前索引元素，索引，原数组\n\n> 经典 map 代码题\n\n\n\n * 第一轮遍历 parseInt('1', 0) -> 1\n * 第二轮遍历 parseInt('2', 1) -> NaN\n * 第三轮遍历 parseInt('3', 2) -> NaN\n\nfilter的作用也是生成一个新数组，在遍历数组的时候将返回值为true的元素放入新数组，我们可以利用这个函数删除一些不需要的元素\n\nreduce可以将数组中的元素通过回调函数最终转换为一个值。\n\n\n\n\nJS 异步编程题#\n\nPromise#\n\n三个状态\n\nPending Fulfilled Rejected\n\n在构造Promise的时候，构造函数内部的代码是立即执行的\n\n\n\nPromise实现了链式调用，也就是说每次调用then之后返回的都是一个Promise，并且是一个全新的Promise，原因也是因为状态不可变。如果你在then\n中 使用了return，那么return的值会被Promise.resolve()包装\n\n主要解决了回调地狱的问题\n\nPromise/A+ 规范 手写\n\n\n面试专项题#\n\nAJAX fetch axios#\n\najax 是一个技术统称 asynchronous javascript and xml\n\nfetch 是一个浏览器原生 API, 支持 promise\n\naxios 是第三方库 发起网络请求 内部 XMLHttpRequest 和 fetch 来实现\n\n防抖节流什么区别#\n\n1.两者区别,2.使用场景 ?\n\n防抖: 防止抖动,等不抖了 在执行下一步.\n\n输入框一直输入等输入停止后再去搜索,按钮多次点击\n\n","routePath":"/notes/interview/","lang":"","toc":[{"text":"目录","id":"目录","depth":2,"charIndex":3},{"text":"**一、技术基础强化（核心必考）**","id":"一技术基础强化核心必考","depth":3,"charIndex":-1},{"text":"**1. JavaScript 底层原理**","id":"1-javascript-底层原理","depth":4,"charIndex":-1},{"text":"**2. 框架核心原理**","id":"2-框架核心原理","depth":4,"charIndex":-1},{"text":"**3. 浏览器与网络**","id":"3-浏览器与网络","depth":4,"charIndex":-1},{"text":"**4. 前端工程化**","id":"4-前端工程化","depth":4,"charIndex":-1},{"text":"**二、项目经验深挖（高频追问点）**","id":"二项目经验深挖高频追问点","depth":3,"charIndex":-1},{"text":"**1. 项目难点与解决方案**","id":"1-项目难点与解决方案","depth":4,"charIndex":-1},{"text":"**2. 技术选型与权衡**","id":"2-技术选型与权衡","depth":4,"charIndex":-1},{"text":"**3. 协作与流程优化**","id":"3-协作与流程优化","depth":4,"charIndex":-1},{"text":"**三、算法与数据结构（大厂必考）**","id":"三算法与数据结构大厂必考","depth":3,"charIndex":-1},{"text":"**1. 刷题重点**","id":"1-刷题重点","depth":4,"charIndex":-1},{"text":"**2. 刷题策略**","id":"2-刷题策略","depth":4,"charIndex":-1},{"text":"**四、系统设计能力（高阶岗位重点）**","id":"四系统设计能力高阶岗位重点","depth":3,"charIndex":-1},{"text":"**1. 前端架构设计**","id":"1-前端架构设计","depth":4,"charIndex":-1},{"text":"**2. 全栈能力验证**","id":"2-全栈能力验证","depth":4,"charIndex":-1},{"text":"**五、行为面试与软技能**","id":"五行为面试与软技能","depth":3,"charIndex":-1},{"text":"**1. 常见问题**","id":"1-常见问题","depth":4,"charIndex":-1},{"text":"**2. 回答技巧**","id":"2-回答技巧","depth":4,"charIndex":-1},{"text":"**六、简历优化与面试模拟**","id":"六简历优化与面试模拟","depth":3,"charIndex":-1},{"text":"**1. 简历打磨**","id":"1-简历打磨","depth":4,"charIndex":-1},{"text":"**2. 模拟面试**","id":"2-模拟面试","depth":4,"charIndex":-1},{"text":"**七、资源推荐**","id":"七资源推荐","depth":3,"charIndex":-1},{"text":"**八、面试后复盘**","id":"八面试后复盘","depth":3,"charIndex":-1},{"text":"JS 基础(一)","id":"js-基础一","depth":3,"charIndex":2935},{"text":"基础类型","id":"基础类型","depth":3,"charIndex":2947},{"text":"this","id":"this","depth":3,"charIndex":3288},{"text":"JS 基础(二)","id":"js-基础二","depth":3,"charIndex":3594},{"text":"闭包","id":"闭包","depth":4,"charIndex":3686},{"text":"深浅拷贝","id":"深浅拷贝","depth":4,"charIndex":3896},{"text":"浅拷贝","id":"浅拷贝","depth":4,"charIndex":3903},{"text":"深拷贝","id":"深拷贝","depth":4,"charIndex":4049},{"text":"原型","id":"原型","depth":4,"charIndex":4216},{"text":"ES6","id":"es6","depth":3,"charIndex":4642},{"text":"var let const","id":"var-let-const","depth":4,"charIndex":4648},{"text":"class 继承","id":"class-继承","depth":4,"charIndex":4805},{"text":"模块化","id":"模块化","depth":4,"charIndex":5116},{"text":"Proxy","id":"proxy","depth":4,"charIndex":5564},{"text":"数组方法 map,filter,reduce","id":"数组方法-mapfilterreduce","depth":4,"charIndex":5748},{"text":"JS 异步编程题","id":"js-异步编程题","depth":3,"charIndex":6072},{"text":"Promise","id":"promise","depth":4,"charIndex":6083},{"text":"面试专项题","id":"面试专项题","depth":3,"charIndex":6319},{"text":"AJAX fetch axios","id":"ajax-fetch-axios","depth":4,"charIndex":6327},{"text":"防抖节流什么区别","id":"防抖节流什么区别","depth":4,"charIndex":6474}],"domain":"","frontmatter":{},"version":""},{"id":8,"title":"面试问题复盘","content":"#\n\n\n项目中遇到的最大挑战是什么,后来如何解决的#\n\n高分回答要点:\n\n * 真实性：选择真实、有技术深度的案例，避免虚构。\n * 结构化：用 STAR 法则清晰表达，避免冗长。\n * 技术细节：提及工具（Webpack/Lighthouse）、方法（代码分割/缓存策略），展示专业度。\n * 软技能：体现沟通、领导力（如协调团队）和复盘能力。\n * 数据化结果：用百分比、时间等量化指标增强说服力。 示例: 在开发某电商平台时，我负责解决首屏加载过慢的问题（5 秒+）。通过 Lighthouse\n   分析，发现图片体积和接口响应是瓶颈。我主导将图片转换为 WebP 格式并接入 CDN，推动后端为商品接口添加 Redis\n   缓存，同时用虚拟滚动优化长列表渲染。最终首屏时间降至 1.3 秒，跳出率降低\n   25%。这次经历让我学会用数据驱动跨团队协作，并在后续项目中提前设定性能预算以避免类似问题。\n   \n   > 要避免的陷阱包括：不要抱怨之前的团队或同事，不要选择因为自己疏忽导致的错误作为挑战（比如因为自己代码写错导致的\n   > bug），而应该选外部因素或技术难点。同时，要展示积极的态度和解决问题的能力。\n   > 比如，好的例子可能是处理高并发下的系统崩溃，通过水平扩展和负载均衡解决；或者在前端项目中实现复杂的交互需求，通过研究新技术或第三方库来解决。\n   > 再检查一下是否有遗漏的要点，比如是否展示了分析问题、解决问题、团队合作、学习能力等。可能还需要量化结果，比如性能提升了多少百分比，用户满意度提高，或者\n   > 项目按时交付等数据，这样更有说服力。\n\n\ntoken 放在 cookie 还是 localStorage#\n\n在前端开发中，将 Token 存储在 Cookie 还是 LocalStorage 是一个常见的安全与设计权衡问题。以下是两者的核心对比及最佳实践建议：\n\n一、核心对比\n\n特性        COOKIE                           LOCALSTORAGE\n安全性       ✅ 支持 HttpOnly 防止 XSS 读取          ❌ JavaScript 可直接访问，易受 XSS 攻击\n自动携带      ✅ 请求自动携带在 Cookie 头中              ❌ 需手动添加到请求头（如 Authorization）\n存储容量      4KB 左右                           5MB+\n跨域支持      需配置 SameSite 和 CORS              无限制，但需手动处理跨域请求头\nCSRF 风险   ❌ 需额外防护（如 CSRF Token、SameSite）   ✅ 无自动携带，CSRF 风险低\n服务端控制     ✅ 可设置过期时间、Secure、HttpOnly 等属性    ❌ 完全由前端控制\n\n二、安全性深度分析\n\n1. Cookie 的防护机制\n\n * HttpOnly：禁止 JavaScript 读取 Cookie，有效防御 XSS 窃取 Token。\n * Secure：仅通过 HTTPS 传输，防止中间人攻击。\n * SameSite=Strict/Lax：阻止跨站请求伪造（CSRF），现代浏览器默认 Lax。\n * 示例配置（服务端）：\n   \n   \n   \n   2. LocalStorage 的风险\n * XSS 攻击：一旦存在 XSS 漏洞，Token 会被直接窃取。\n * 无自动过期：需手动清理或依赖前端逻辑，易长期滞留。 三、适用场景建议 1. 优先选择 Cookie 的场景\n * 需要防御 XSS 窃取 Token：通过 HttpOnly 和 Secure 提升安全性。\n * 依赖自动携带 Token：简化前端代码，无需手动管理请求头。\n * 需要服务端控制会话：如设置过期时间、强制注销等。 2. 选择 LocalStorage 的场景\n * 需存储较大数据：如复杂的用户配置信息。\n * 跨域分离的前后端架构：如 JWT 需手动添加到 Authorization 头。\n * 对 CSRF 有独立防护：如已使用 CSRF Token 或加密请求参数。\n\n四、最佳实践\n\n 1. 使用 Cookie 的推荐方案：\n    \n    * 服务端设置 Cookie 时启用 HttpOnly、Secure 和 SameSite=Lax。\n    * 配合 CSRF Token（双重提交验证）或加密的请求参数。\n    * 示例流程：\n\n\n\n 2. 使用 LocalStorage 的防护措施：\n    \n    * 避免存储敏感信息，仅存 Token。\n    * 所有接口请求手动添加 Token 到 Authorization 头。\n    * 严格过滤输入输出，防御 XSS。\n    * 示例代码：\n\n\n\n五、面试回答模板\n\n“项目中如何选择 Token 存储方式？”\n\n> 我们优先选择 Cookie 存储 Token，并配置 HttpOnly、Secure 和 SameSite=Lax 防御 XSS 和\n> CSRF。对于需要更高灵活性的场景（如跨域分离架构），则用 LocalStorage 手动管理 Token，但会严格防御 XSS，如输入过滤、CSP\n> 策略。同时，无论哪种方式，都会确保 HTTPS 加密传输，并设置合理的 Token 过期时间。”\n\n通过结合安全需求和架构特点选择存储方式，并明确防御措施，可体现对安全与工程实践的深入理解。\n\n\n浏览器从输入 URL 到页面展示的整个过程#\n\n浏览器从输入 URL 到页面渲染的整个过程可以分为以下几个关键步骤：\n\n 1. URL 解析与输入处理\n    \n    * 浏览器解析用户输入，判断是 URL 还是搜索内容。如果是搜索词，使用默认搜索引擎进行搜索；否则，处理 URL。\n\n 2. DNS 解析\n    \n    * 将域名转换为 IP 地址：\n      1. 检查浏览器缓存 → 操作系统缓存 → 本地 Hosts 文件 → 递归查询 DNS 服务器（如未命中缓存）。\n\n 3. 建立 TCP 连接\n    \n    * 通过三次握手与服务器建立 TCP 连接：\n      \n      SYN → SYN-ACK → ACK。\n    * 若为 HTTPS，还需 TLS 握手（交换证书、协商加密算法、生成会话密钥）。\n\n 4. 发送 HTTP 请求\n    \n    * 浏览器发送 HTTP 请求，包含请求方法（如 GET）、请求头（User-Agent、Accept 等）。\n    * 若存在重定向（如 301/302），重新开始流程。\n\n 5. 服务器处理请求并返回响应\n    \n    * 服务器处理请求，返回 HTTP 响应（状态码、响应头、HTML 等资源）。\n\n 6. 浏览器解析与渲染\n    \n    * 构建 DOM 树：解析 HTML 生成 DOM 树，遇到","routePath":"/notes/interview/review","lang":"","toc":[{"text":"项目中遇到的最大挑战是什么,后来如何解决的","id":"项目中遇到的最大挑战是什么后来如何解决的","depth":3,"charIndex":3},{"text":"token 放在 cookie 还是 localStorage","id":"token-放在-cookie-还是-localstorage","depth":3,"charIndex":699},{"text":"浏览器从输入 URL 到页面展示的整个过程","id":"浏览器从输入-url-到页面展示的整个过程","depth":3,"charIndex":2348},{"text":"3.7 某医科技面试","id":"37-某医科技面试","depth":3,"charIndex":-1},{"text":"promise 状态吸收","id":"promise-状态吸收","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":9,"title":"React 基础","content":"#\n\n\n认识语法#\n\n\nJSX 语法#\n\n * JSX 是 JavaScript 的语法扩展，允许在 JavaScript 中编写类似 HTML 的代码\n * JSX 会被编译为 React.createElement() 调用\n * JSX 中使用大括号 {} 嵌入 JavaScript 表达式\n\n\n\n\n组件基础#\n\n * 函数组件：使用函数声明的简单组件\n * 类组件：使用 class 关键字声明，继承自 React.Component\n * 组件名称必须以大写字母开头\n\n\n\n\nProps 和 State#\n\nProps#\n\n * Props 是只读的，用于组件间数据传递\n * Props 可以传递任意类型的数据，包括函数和 JSX\n\n\n\nState#\n\n * State 用于管理组件内部状态\n * 使用 useState Hook 或 class 组件中的 setState 更新状态\n * State 更新可能是异步的\n\n\n\n\n生命周期#\n\n函数组件（Hooks）#\n\n * useEffect：处理副作用\n * useLayoutEffect：同步执行副作用\n * 自定义 Hooks：复用状态逻辑\n\n\n\n类组件#\n\n * 挂载阶段：constructor -> render -> componentDidMount\n * 更新阶段：render -> componentDidUpdate\n * 卸载阶段：componentWillUnmount\n\n\n\n\n事件处理#\n\n * React 事件使用驼峰命名\n * 事件处理器接收合成事件对象（SyntheticEvent）\n * 注意绑定 this 的问题（箭头函数或 bind）\n\n\n\n\n条件渲染#\n\n * 使用 if 语句或三元运算符\n * 使用逻辑运算符 &&\n * 防止组件返回 null 导致的问题\n\n\n\n\n列表渲染#\n\n * 使用 map 方法渲染列表\n * key 属性的重要性和正确使用\n * 避免使用索引作为 key\n\n","routePath":"/notes/react/react","lang":"","toc":[{"text":"认识语法","id":"认识语法","depth":2,"charIndex":3},{"text":"JSX 语法","id":"jsx-语法","depth":3,"charIndex":11},{"text":"组件基础","id":"组件基础","depth":3,"charIndex":153},{"text":"Props 和 State","id":"props-和-state","depth":3,"charIndex":243},{"text":"Props","id":"props","depth":4,"charIndex":259},{"text":"State","id":"state","depth":4,"charIndex":325},{"text":"生命周期","id":"生命周期","depth":3,"charIndex":422},{"text":"函数组件（Hooks）","id":"函数组件hooks","depth":4,"charIndex":429},{"text":"类组件","id":"类组件","depth":4,"charIndex":512},{"text":"事件处理","id":"事件处理","depth":3,"charIndex":639},{"text":"条件渲染","id":"条件渲染","depth":3,"charIndex":730},{"text":"列表渲染","id":"列表渲染","depth":3,"charIndex":794}],"domain":"","frontmatter":{},"version":""},{"id":10,"title":"TypeScript","content":"#\n\n@types 是一个第三方库 包含对 js 代码的类型描述\n\n * 类型描述 是对 js 代码的描述 描述的是 js 代码的结构和类型 @types/node\n\n\n基本类型约束#\n\n变量,函数的参数,函数的返回值限制类型 在变量后边加类型描述 ts 在很多场景可以完成类型推导 any 任意类型 推导不出来的 有三个点 用 any\n\n\n源代码和编译结果的差异#\n\n * 类型约束 不会出现在编译结果中 TS 类型检查 是静态的\n\n\n基本类型#\n\n * number\n * string\n * 数组 要指出每一项是什么类型 number[] string[] object[] Array\n * object 对象约束(用的比较少) 特殊类型 null undefined 严格模式下 不能赋值给 null 和 undefined\n\n\n其他常用类型#\n\n联合类型|连接符 typeof 可以触发简单类型保护 void 类型 没有返回值的函数 never 类型 永远不会结束函数 字面量类型 \"A\" 1 2\n以后只能赋值给某个字面量\n\n可以约束类型 元祖类型 固定长度的数组 约束每一项的类型 any 类型 绕过类型检查 可以赋值给任何类型\n\n\n类型别名#\n\n对已知的类型进行描述\n\n\n函数相关约束#\n\n函数重载:在函数实现之前,对函数调用的多种情况进行声明 可选参数?,不能放在首位\n\n\n扩展类型-枚举#\n\n扩展类型:类型别名/枚举/接口/类\n\n枚举: 约束某个变量的取值范围 枚举的类型: 数字枚举 字符串枚举 字面量和联合类型配合使用,可以达到同样的目标\n\n字面量类型存在问题\n\n * 不会进入到编译结果\n * 值混淆的话修改所需要的成本太高\n\n\n\n枚举会出现在编译结果中,表现为对象 枚举为字符串或者数字,数字的值会自增 数字枚举和字符串枚举有差异 最佳实践: 不要同时出现字符串和数字\n使用时尽量使用枚举字段的名称不要使用真实值\n\n位运算& | ~ ^ << >> 或| 可以用来判断是否拥有某个权限 且& 可以用来判断是否拥有某个权限 异或^ 可以用来删除权限 (相同取 0 不同取 1)\n\n\n模块化 TS#\n\n配置模块化导出导入模块 使用的是 es6 的模块化标准\n\n\n\n\n接口#\n\n扩展类型: 类型别名 枚举 接口 类 概念:用于约束类 对象 函数的契约(标准)\n\n不会出现在编译结果中 和类型别名一样 接口可以继承 让一个接口继承另一个接口所有成员 实现多种接口组合 在继承中不能去覆盖父接口成员的类型\n\n\n\n类型别名实现:& 交叉类型符,可以覆盖父接口成员的类型 使用少\n\nreadonly 只读属性 在接口中成员之前加 readonly 可以将成员变为只读属性 在编译后会被删除 readonly arr: readonly\nnumber[] 数组不能改变\n\n\n类型兼容性#\n\nB->A 如果能完成赋值则 B 和 A 是兼容的 鸭子辩型法 (子结构辩型法):目标类型需要某一些特征,赋值的类型只需要满足该特征即可\n\n基本类型完全匹配\n\n类型断言: as 关键词 直接使用字面量赋值,判定更严格\n\n\n类#\n\n面向对象思想 类 属性赋值 在构造函数中 在类中赋值 ?:可选属性 属性可以修饰为可选 / 只读 构造器中写上访问修饰符 可以正常赋值构造属性简写 访问修饰符\npublic/private/readonly\n\n\n访问器#\n\nset get 用来控制属性的读取\n\n\n泛型#\n\n在书写某个函数中会丢失一些类型信息 泛型:附属于函数类接口类型别名之上的类型 泛型可以设置默认值\n\n使用: 在函数名之后写上<泛型名称>通常写 在定义的时候不确定类型,在调用的时候传类型\n\n泛型约束 在 表示一个泛型继承了某个接口 某个类 用来限制泛型的取值 多泛型 返回(T | U)的结果类型 可以是 T 也可以是 U","routePath":"/notes/react/typescript","lang":"","toc":[{"text":"基本类型约束","id":"基本类型约束","depth":2,"charIndex":84},{"text":"源代码和编译结果的差异","id":"源代码和编译结果的差异","depth":3,"charIndex":170},{"text":"基本类型","id":"基本类型","depth":2,"charIndex":218},{"text":"其他常用类型","id":"其他常用类型","depth":2,"charIndex":369},{"text":"类型别名","id":"类型别名","depth":2,"charIndex":523},{"text":"函数相关约束","id":"函数相关约束","depth":2,"charIndex":543},{"text":"扩展类型-枚举","id":"扩展类型-枚举","depth":2,"charIndex":595},{"text":"模块化 TS","id":"模块化-ts","depth":2,"charIndex":903},{"text":"接口","id":"接口","depth":2,"charIndex":944},{"text":"类型兼容性","id":"类型兼容性","depth":2,"charIndex":1192},{"text":"类","id":"类","depth":2,"charIndex":1310},{"text":"访问器","id":"访问器","depth":3,"charIndex":1420},{"text":"泛型","id":"泛型","depth":2,"charIndex":1446}],"domain":"","frontmatter":{},"version":""},{"id":11,"title":"Vue in One Page","content":"#\n\n\nVue 实例属性和方法#\n\n * $data: 获取数据对象\n * $props: 获取传入的 props\n * $el: 获取根 DOM 元素\n * $refs: 获取注册过 ref 的所有 DOM 元素或组件实例\n * $watch: 观察数据变化\n\n\n生命周期#\n\n\nVue2 生命周期钩子#\n\n 1. 创建阶段\n    \n    * beforeCreate: 实例初始化之后，数据观测和事件配置之前调用\n    * created: 实例创建完成后调用，此时可以访问数据\n\n 2. 挂载阶段\n    \n    * beforeMount: 挂载开始之前调用\n    * mounted: 挂载完成后调用，可以访问 DOM\n\n 3. 更新阶段\n    \n    * beforeUpdate: 数据更新时调用，发生在虚拟 DOM 打补丁之前\n    * updated: 由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用\n\n 4. 销毁阶段\n    \n    * beforeDestroy: 实例销毁之前调用\n    * destroyed: 实例销毁后调用\n\n\nVue3 生命周期钩子#\n\n 1. 创建阶段\n    \n    * setup: 开始创建组件之前执行，在 beforeCreate 和 created 之前执行\n\n 2. 挂载阶段\n    \n    * onBeforeMount: 挂载开始之前调用\n    * onMounted: 挂载完成后调用\n\n 3. 更新阶段\n    \n    * onBeforeUpdate: 数据更新时调用，发生在虚拟 DOM 打补丁之前\n    * onUpdated: 数据更新后调用\n\n 4. 销毁阶段\n    \n    * onBeforeUnmount: 实例销毁之前调用（替代 beforeDestroy）\n    * onUnmounted: 实例销毁后调用（替代 destroyed）\n\n\n生命周期图示#\n\n\n\n\n模板语法#\n\n\n插值#\n\n * 文本插值：{{ message }}\n * HTML：v-html=\"rawHtml\"\n * 属性：v-bind:id=\"dynamicId\" 或简写 :id=\"dynamicId\"\n\n\n指令#\n\n 1. 条件渲染\n    \n    \n\n 2. 列表渲染\n    \n    \n\n 3. 事件处理\n    \n    \n\n 4. 表单输入绑定\n    \n    \n\n\n计算属性与侦听器#\n\n\n计算属性#\n\n\n\n\n侦听器#\n\n\n\n\nClass 与 Style 绑定#\n\n\nClass 绑定#\n\n\n\n\nStyle 绑定#\n\n\n\n\n组件系统#\n\n\n组件注册与使用#\n\n\n\n\nProps 与 Events#\n\n\n\n\n响应式原理#\n\n\nVue2 响应式原理#\n\n * 使用 Object.defineProperty 实现数据劫持\n   \n   \n\n * 主要特点：\n   * 对象属性必须提前声明\n   * 不能检测数组长度变化\n   * 不能检测对象属性的添加和删除\n   * 需要遍历对象所有属性\n * 解决方案：\n   * 使用 Vue.set() 或 this.$set() 添加响应式属性\n   * 使用 Vue.delete() 或 this.$delete() 删除属性\n   * 使用数组方法：push、pop、shift、unshift、splice、sort、reverse\n * 源码实现关键点：\n   * Observer：将数据对象的所有属性转换为 getter/setter\n   * Dep：依赖收集器，存储所有依赖（Watcher）\n   * Watcher：订阅者，负责触发视图更新\n\n\nVue3 响应式原理#\n\n * 使用 Proxy 实现响应式系统\n   \n   \n\n * 主要特点：\n   * 可以监听动态添加的属性\n   * 可以监听数组的索引和长度变化\n   * 可以监听删除的属性\n   * 不需要遍历对象所有属性\n   * 支持 Map、Set、WeakMap、WeakSet\n * 性能优势：\n   * 初始化性能更好，不需要递归遍历\n   * 内存占用更少\n   * 可以懒处理嵌套对象\n * 响应式 API：\n   * reactive：深层响应式代理\n   * ref：处理基本类型的响应式\n   * readonly：创建只读代理\n   * shallowReactive：浅层响应式\n   * shallowRef：浅层 ref\n\n\n常见面试题解答#\n\n 1. Vue2 和 Vue3 响应式的区别？\n    \n    * 实现原理不同：Vue2 使用 Object.defineProperty，Vue3 使用 Proxy\n    * 性能差异：Vue3 初始化更快，内存占用更少\n    * 功能限制：Vue2 无法监听属性添加/删除，Vue3 可以\n    * 数组处理：Vue2 需要特殊处理数组方法，Vue3 可以直接监听\n\n 2. 为什么 Vue2 不能检测数组长度变化？\n    \n    * Object.defineProperty 不能监听数组长度的变化\n    * Vue2 通过重写数组方法来实现响应式\n    * 直接通过索引修改数组不会触发更新\n\n 3. Vue3 为什么使用 Proxy？\n    \n    * 可以直接监听对象而非属性\n    * 可以监听动态添加的属性\n    * 可以监听数组的变化\n    * 可以监听对象的删除操作\n\n 4. Vue.set 的实现原理？\n    \n    \n\n 5. Vue3 ref 和 reactive 的区别？\n    \n    * ref 用于基本类型，reactive 用于对象\n    * ref 需要.value 访问，reactive 直接访问\n    * ref 可以用于模板，不需要.value\n    * reactive 不能用于基本类型\n\n\n高频面试题#\n\n\n组件通信#\n\n 1. 父子组件通信\n    \n    * Props / $emit\n    * $refs / $parent\n    * v-model / .sync (Vue2)\n    * provide / inject\n\n 2. 兄弟组件通信\n    \n    * EventBus\n    * Vuex / Pinia\n    * 通过共同的父组件\n\n 3. 跨层级组件通信\n    \n    * Vuex / Pinia\n    * provide / inject\n    * EventBus\n\n\n组件复用#\n\n 1. Vue2 复用方式\n    \n    \n\n 2. Vue3 复用方式\n    \n    \n\n\n核心概念对比#\n\n 1. 选项式 API vs 组合式 API\n    \n    * 选项式 API：\n      * 按 options 组织代码\n      * 适合简单组件\n      * 学习成本低\n    * 组合式 API：\n      * 按功能组织代码\n      * 更好的代码复用\n      * TypeScript 支持更好\n\n 2. 响应式系统\n    \n    * Vue2：Object.defineProperty\n      * 需要遍历对象属性\n      * 不能监听数组长度变化\n      * 不能监听对象属性添加/删除\n    * Vue3：Proxy\n      * 可以监听整个对象\n      * 可以监听数组变化\n      * 可以监听属性添加/删除\n\n\n性能优化建议#\n\n 1. Vue2 优化\n    \n    * 使用 Object.freeze() 冻结不需要响应式的数据\n    * 使用 v-show 代替频繁切换的 v-if\n    * 合理使用 computed 缓存\n    * 避免深度监听大数据\n    * 使用函数式组件\n    * 路由懒加载\n    * 第三方库按需引入\n\n 2. Vue3 优化\n    \n    * 使用 shallowRef 和 shallowReactive 处理大数据\n    * 使用 markRaw 标记不需要响应式的数据\n    * 合理使用 computed 和 watchEffect\n    * 使用 v-memo 缓存模板\n    * 使用 Suspense 和异步组件\n    * 动态导入组件\n    * Tree-shaking 优化\n\n\n虚拟 DOM#\n\n * 虚拟 DOM 树的构建\n   \n   * 用 JavaScript 对象描述 DOM 结构\n   * 通过 render 函数生成虚拟 DOM 树\n   * 数据变化时生成新的虚拟 DOM 树\n\n * Diff 算法实现\n   \n   1. Vue2 双端比较算法\n      \n      * 同时从新旧节点的两端开始比较\n      * 四个指针：新头、新尾、旧头、旧尾\n      * 比较策略：\n        \n        \n      \n      * 如果四种比较都未命中，则按 key 比较\n   \n   2. Vue3 快速 Diff 算法\n      \n      * 借鉴了 ivi 和 inferno 的算法\n      * 相同的前置和后置节点的预处理\n      * 最长递增子序列算法优化节点移动\n      \n      \n\n * 性能优化策略\n   \n   * 使用唯一 key 进行节点复用\n   * 避免无谓的节点更新\n   * 采用异步更新\n\n\n虚拟 DOM#\n\n * 虚拟 DOM 树的构建\n   \n   * 用 JavaScript 对象描述 DOM 结构\n   * 通过 render 函数生成虚拟 DOM 树\n   * 数据变化时生成新的虚拟 DOM 树\n\n * Diff 算法实现\n   \n   1. Vue2 双端比较算法\n      \n      * 同时从新旧节点的两端开始比较\n      * 四个指针：新头、新尾、旧头、旧尾\n      * 比较策略：\n        \n        \n      \n      * 如果四种比较都未命中，则按 key 比较\n   \n   2. Vue3 快速 Diff 算法\n      \n      * 借鉴了 ivi 和 inferno 的算法\n      * 相同的前置和后置节点的预处理\n      * 最长递增子序列算法优化节点移动\n      \n      \n\n * 性能优化策略\n   \n   * 使用唯一 key 进行节点复用\n   * 避免无谓的节点更新\n   * 采用异步更新","routePath":"/notes/vue/","lang":"","toc":[{"text":"Vue 实例属性和方法","id":"vue-实例属性和方法","depth":3,"charIndex":3},{"text":"生命周期","id":"生命周期","depth":2,"charIndex":132},{"text":"Vue2 生命周期钩子","id":"vue2-生命周期钩子","depth":3,"charIndex":140},{"text":"Vue3 生命周期钩子","id":"vue3-生命周期钩子","depth":3,"charIndex":494},{"text":"生命周期图示","id":"生命周期图示","depth":3,"charIndex":840},{"text":"模板语法","id":"模板语法","depth":2,"charIndex":852},{"text":"插值","id":"插值","depth":3,"charIndex":860},{"text":"指令","id":"指令","depth":3,"charIndex":962},{"text":"计算属性与侦听器","id":"计算属性与侦听器","depth":2,"charIndex":1050},{"text":"计算属性","id":"计算属性","depth":3,"charIndex":1062},{"text":"侦听器","id":"侦听器","depth":3,"charIndex":1072},{"text":"Class 与 Style 绑定","id":"class-与-style-绑定","depth":2,"charIndex":1081},{"text":"Class 绑定","id":"class-绑定","depth":3,"charIndex":1101},{"text":"Style 绑定","id":"style-绑定","depth":3,"charIndex":1115},{"text":"组件系统","id":"组件系统","depth":2,"charIndex":1129},{"text":"组件注册与使用","id":"组件注册与使用","depth":3,"charIndex":1137},{"text":"Props 与 Events","id":"props-与-events","depth":3,"charIndex":1150},{"text":"响应式原理","id":"响应式原理","depth":2,"charIndex":1170},{"text":"Vue2 响应式原理","id":"vue2-响应式原理","depth":3,"charIndex":1179},{"text":"Vue3 响应式原理","id":"vue3-响应式原理","depth":3,"charIndex":1573},{"text":"常见面试题解答","id":"常见面试题解答","depth":3,"charIndex":1909},{"text":"高频面试题","id":"高频面试题","depth":2,"charIndex":2513},{"text":"组件通信","id":"组件通信","depth":3,"charIndex":2522},{"text":"组件复用","id":"组件复用","depth":3,"charIndex":2782},{"text":"核心概念对比","id":"核心概念对比","depth":3,"charIndex":2840},{"text":"性能优化建议","id":"性能优化建议","depth":3,"charIndex":3195},{"text":"虚拟 DOM","id":"虚拟-dom","depth":3,"charIndex":3574},{"text":"虚拟 DOM","id":"虚拟-dom-1","depth":3,"charIndex":4031}],"domain":"","frontmatter":{},"version":""}]