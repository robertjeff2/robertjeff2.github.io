"use strict";(self.webpackChunkjeff_blog=self.webpackChunkjeff_blog||[]).push([["224"],{6784:function(n,e,s){s.r(e),s.d(e,{default:()=>c});var r=s(5893),i=s(65);function l(n){let e=Object.assign({h1:"h1",a:"a",h3:"h3",p:"p",ul:"ul",li:"li",blockquote:"blockquote",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",code:"code",pre:"pre",ol:"ol",br:"br"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"面试问题复盘",children:["面试问题复盘",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#面试问题复盘",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"项目中遇到的最大挑战是什么后来如何解决的",children:["项目中遇到的最大挑战是什么,后来如何解决的",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#项目中遇到的最大挑战是什么后来如何解决的",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"高分回答要点:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"真实性：选择真实、有技术深度的案例，避免虚构。"}),"\n",(0,r.jsx)(e.li,{children:"结构化：用 STAR 法则清晰表达，避免冗长。"}),"\n",(0,r.jsx)(e.li,{children:"技术细节：提及工具（Webpack/Lighthouse）、方法（代码分割/缓存策略），展示专业度。"}),"\n",(0,r.jsx)(e.li,{children:"软技能：体现沟通、领导力（如协调团队）和复盘能力。"}),"\n",(0,r.jsxs)(e.li,{children:["数据化结果：用百分比、时间等量化指标增强说服力。\n示例: 在开发某电商平台时，我负责解决首屏加载过慢的问题（5 秒+）。通过 Lighthouse 分析，发现图片体积和接口响应是瓶颈。我主导将图片转换为 WebP 格式并接入 CDN，推动后端为商品接口添加 Redis 缓存，同时用虚拟滚动优化长列表渲染。最终首屏时间降至 1.3 秒，跳出率降低 25%。这次经历让我学会用数据驱动跨团队协作，并在后续项目中提前设定性能预算以避免类似问题。","\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"要避免的陷阱包括：不要抱怨之前的团队或同事，不要选择因为自己疏忽导致的错误作为挑战（比如因为自己代码写错导致的 bug），而应该选外部因素或技术难点。同时，要展示积极的态度和解决问题的能力。\n比如，好的例子可能是处理高并发下的系统崩溃，通过水平扩展和负载均衡解决；或者在前端项目中实现复杂的交互需求，通过研究新技术或第三方库来解决。\n再检查一下是否有遗漏的要点，比如是否展示了分析问题、解决问题、团队合作、学习能力等。可能还需要量化结果，比如性能提升了多少百分比，用户满意度提高，或者项目按时交付等数据，这样更有说服力。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"token-放在-cookie-还是-localstorage",children:["token 放在 cookie 还是 localStorage",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#token-放在-cookie-还是-localstorage",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在前端开发中，将 Token 存储在 ",(0,r.jsx)(e.strong,{children:"Cookie"})," 还是 ",(0,r.jsx)(e.strong,{children:"LocalStorage"})," 是一个常见的安全与设计权衡问题。以下是两者的核心对比及最佳实践建议："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"一、核心对比"})}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{children:(0,r.jsx)(e.strong,{children:"特性"})}),"\n",(0,r.jsx)(e.th,{children:(0,r.jsx)(e.strong,{children:"Cookie"})}),"\n",(0,r.jsx)(e.th,{children:(0,r.jsx)(e.strong,{children:"LocalStorage"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"安全性"})}),"\n",(0,r.jsxs)(e.td,{children:["✅ 支持 ",(0,r.jsx)(e.code,{children:"HttpOnly"})," 防止 XSS 读取"]}),"\n",(0,r.jsx)(e.td,{children:"❌ JavaScript 可直接访问，易受 XSS 攻击"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"自动携带"})}),"\n",(0,r.jsxs)(e.td,{children:["✅ 请求自动携带在 ",(0,r.jsx)(e.code,{children:"Cookie"})," 头中"]}),"\n",(0,r.jsxs)(e.td,{children:["❌ 需手动添加到请求头（如 ",(0,r.jsx)(e.code,{children:"Authorization"}),"）"]}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"存储容量"})}),"\n",(0,r.jsx)(e.td,{children:"4KB 左右"}),"\n",(0,r.jsx)(e.td,{children:"5MB+"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"跨域支持"})}),"\n",(0,r.jsxs)(e.td,{children:["需配置 ",(0,r.jsx)(e.code,{children:"SameSite"})," 和 CORS"]}),"\n",(0,r.jsx)(e.td,{children:"无限制，但需手动处理跨域请求头"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"CSRF 风险"})}),"\n",(0,r.jsx)(e.td,{children:"❌ 需额外防护（如 CSRF Token、SameSite）"}),"\n",(0,r.jsx)(e.td,{children:"✅ 无自动携带，CSRF 风险低"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"服务端控制"})}),"\n",(0,r.jsx)(e.td,{children:"✅ 可设置过期时间、Secure、HttpOnly 等属性"}),"\n",(0,r.jsx)(e.td,{children:"❌ 完全由前端控制"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"二、安全性深度分析"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"1. Cookie 的防护机制"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"HttpOnly"})}),"：禁止 JavaScript 读取 Cookie，有效防御 XSS 窃取 Token。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"Secure"})}),"：仅通过 HTTPS 传输，防止中间人攻击。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"SameSite=Strict/Lax"})}),"：阻止跨站请求伪造（CSRF），现代浏览器默认 ",(0,r.jsx)(e.code,{children:"Lax"}),"。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"示例配置（服务端）"}),"：","\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-http",children:"Set-Cookie: token=<value>; Path=/; HttpOnly; Secure; SameSite=Lax\n"})}),"\n",(0,r.jsx)(e.strong,{children:"2. LocalStorage 的风险"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"XSS 攻击"}),"：一旦存在 XSS 漏洞，Token 会被直接窃取。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"无自动过期"}),"：需手动清理或依赖前端逻辑，易长期滞留。\n",(0,r.jsx)(e.strong,{children:"三、适用场景建议"}),"\n",(0,r.jsx)(e.strong,{children:"1. 优先选择 Cookie 的场景"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"需要防御 XSS 窃取 Token"}),"：通过 ",(0,r.jsx)(e.code,{children:"HttpOnly"})," 和 ",(0,r.jsx)(e.code,{children:"Secure"})," 提升安全性。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"依赖自动携带 Token"}),"：简化前端代码，无需手动管理请求头。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"需要服务端控制会话"}),"：如设置过期时间、强制注销等。\n",(0,r.jsx)(e.strong,{children:"2. 选择 LocalStorage 的场景"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"需存储较大数据"}),"：如复杂的用户配置信息。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"跨域分离的前后端架构"}),"：如 JWT 需手动添加到 ",(0,r.jsx)(e.code,{children:"Authorization"})," 头。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"对 CSRF 有独立防护"}),"：如已使用 CSRF Token 或加密请求参数。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"四、最佳实践"})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"使用 Cookie 的推荐方案"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["服务端设置 Cookie 时启用 ",(0,r.jsx)(e.code,{children:"HttpOnly"}),"、",(0,r.jsx)(e.code,{children:"Secure"})," 和 ",(0,r.jsx)(e.code,{children:"SameSite=Lax"}),"。"]}),"\n",(0,r.jsx)(e.li,{children:"配合 CSRF Token（双重提交验证）或加密的请求参数。"}),"\n",(0,r.jsx)(e.li,{children:"示例流程："}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 服务端返回 Cookie，前端无需处理 Token\nfetch('/login', { method: 'POST', body: credentials }).then((response) => {\n  // Cookie 自动存储，后续请求自动携带\n});\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"使用 LocalStorage 的防护措施"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"避免存储敏感信息，仅存 Token。"}),"\n",(0,r.jsxs)(e.li,{children:["所有接口请求手动添加 Token 到 ",(0,r.jsx)(e.code,{children:"Authorization"})," 头。"]}),"\n",(0,r.jsx)(e.li,{children:"严格过滤输入输出，防御 XSS。"}),"\n",(0,r.jsx)(e.li,{children:"示例代码："}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 登录后存储 Token\nlocalStorage.setItem('token', 'Bearer xxx');\n\n// 请求时手动添加\nfetch('/api/data', {\n  headers: {\n    Authorization: localStorage.getItem('token')\n  }\n});\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"五、面试回答模板"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"“项目中如何选择 Token 存储方式？”"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["我们优先选择 Cookie 存储 Token，并配置 ",(0,r.jsx)(e.code,{children:"HttpOnly"}),"、",(0,r.jsx)(e.code,{children:"Secure"})," 和 ",(0,r.jsx)(e.code,{children:"SameSite=Lax"})," 防御 XSS 和 CSRF。对于需要更高灵活性的场景（如跨域分离架构），则用 LocalStorage 手动管理 Token，但会严格防御 XSS，如输入过滤、CSP 策略。同时，无论哪种方式，都会确保 HTTPS 加密传输，并设置合理的 Token 过期时间。”"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"通过结合安全需求和架构特点选择存储方式，并明确防御措施，可体现对安全与工程实践的深入理解。"}),"\n",(0,r.jsxs)(e.h3,{id:"浏览器从输入-url-到页面展示的整个过程",children:["浏览器从输入 URL 到页面展示的整个过程",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器从输入-url-到页面展示的整个过程",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"浏览器从输入 URL 到页面渲染的整个过程可以分为以下几个关键步骤："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"URL 解析与输入处理"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"浏览器解析用户输入，判断是 URL 还是搜索内容。如果是搜索词，使用默认搜索引擎进行搜索；否则，处理 URL。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"DNS 解析"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["将域名转换为 IP 地址：","\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"检查浏览器缓存 → 操作系统缓存 → 本地 Hosts 文件 → 递归查询 DNS 服务器（如未命中缓存）。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"建立 TCP 连接"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["通过三次握手与服务器建立 TCP 连接：",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.code,{children:"SYN → SYN-ACK → ACK"}),"。"]}),"\n",(0,r.jsx)(e.li,{children:"若为 HTTPS，还需 TLS 握手（交换证书、协商加密算法、生成会话密钥）。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"发送 HTTP 请求"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"浏览器发送 HTTP 请求，包含请求方法（如 GET）、请求头（User-Agent、Accept 等）。"}),"\n",(0,r.jsx)(e.li,{children:"若存在重定向（如 301/302），重新开始流程。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"服务器处理请求并返回响应"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"服务器处理请求，返回 HTTP 响应（状态码、响应头、HTML 等资源）。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"浏览器解析与渲染"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"构建 DOM 树"}),"：解析 HTML 生成 DOM 树，遇到",(0,r.jsx)(e.code,{children:"<script>"}),"时可能阻塞（除非标记为",(0,r.jsx)(e.code,{children:"async/defer"}),"）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"构建 CSSOM 树"}),"：解析 CSS 生成 CSSOM，CSS 会阻塞渲染（避免 FOUC）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"合并渲染树（Render Tree）"}),"：结合 DOM 和 CSSOM，排除不可见元素（如",(0,r.jsx)(e.code,{children:"<meta>"}),"）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"布局（Layout）"}),"：计算每个节点的尺寸和位置（重排）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"绘制（Paint）"}),"：将渲染树转换为屏幕上的像素（重绘）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"合成（Composite）"}),"：分层绘制，优化渲染性能（如 GPU 加速）。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"加载子资源与优化"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"预加载扫描器（Preload Scanner）"}),"：提前发现资源（如图片、CSS）并并行下载。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"处理 JavaScript"}),"：执行可能修改 DOM/CSSOM 的脚本，触发重新渲染。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"事件触发"}),"：",(0,r.jsx)(e.code,{children:"DOMContentLoaded"}),"（DOM 就绪）→ ",(0,r.jsx)(e.code,{children:"load"}),"（所有资源加载完成）。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"连接管理与优化"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"HTTP/1.1 使用持久连接，HTTP/2 支持多路复用减少延迟。"}),"\n",(0,r.jsx)(e.li,{children:"缓存策略（强缓存/协商缓存）减少重复请求。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"关键细节与优化"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"缓存机制"}),"：强缓存（Cache-Control/Expires）与协商缓存（ETag/Last-Modified）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"渲染阻塞"}),"：CSSOM 构建阻塞渲染，JS 默认阻塞 DOM 解析。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"现代渲染策略"}),"：渐进式渲染、懒加载、异步脚本。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"安全机制"}),"：CORS 预检、Same-Origin 策略、HTTPS 加密。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"流程图示例"}),"："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"输入URL → DNS解析 → TCP/TLS握手 → 发送请求\n→接收响应 → 解析HTML → 构建DOM/CSSOM → 渲染树\n→ 布局 → 绘制 → 合成 → 页面展示\n"})}),"\n",(0,r.jsx)(e.p,{children:"此过程涉及网络协议、浏览器引擎协作及性能优化策略，理解各阶段有助于诊断页面加载性能问题。"}),"\n",(0,r.jsxs)(e.h3,{id:"37-某医科技面试",children:["3.7 某医科技面试",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#37-某医科技面试",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"1.事件循环,宏任务微任务"}),"\n",(0,r.jsx)(e.li,{children:"2.vue router"}),"\n",(0,r.jsx)(e.li,{children:"3.pinia vuex"}),"\n",(0,r.jsx)(e.li,{children:"4.内存快照"}),"\n",(0,r.jsx)(e.li,{children:"5.组件间传值 父子兄弟传值方式"}),"\n",(0,r.jsx)(e.li,{children:"6.promise 原理"}),"\n",(0,r.jsx)(e.li,{children:"7.权限控制,分角色"}),"\n",(0,r.jsxs)(e.li,{children:["8.keep-alive 原理属性","\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"keep-alive 是一个内置组件,用来在多个组件间动态切换时缓存被移除的组件实例\n定制行为 include exclude prop 来定制行为\n传入 max prop 来限制可被缓存的最大组件实例数\n指定 max 后内部执行类 LRU 算法: 如果缓存的实例数量即将超过指定的 max,则最久没有访问的缓存实例被销毁 底层原理 set?\n生命周期勾子 onActivated 和 onDeacticated 注册两个状态的生命周期勾子"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"promise-状态吸收",children:["promise 状态吸收",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#promise-状态吸收",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"当.then()返回一个已解决的 Promise 时，浏览器会强制插入两次微任务（PromiseResolveThenableJob），导致后续回调被延迟。"}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["notes%2Finterview%2Freview.md"]={toc:[{text:"项目中遇到的最大挑战是什么,后来如何解决的",id:"项目中遇到的最大挑战是什么后来如何解决的",depth:3},{text:"token 放在 cookie 还是 localStorage",id:"token-放在-cookie-还是-localstorage",depth:3},{text:"浏览器从输入 URL 到页面展示的整个过程",id:"浏览器从输入-url-到页面展示的整个过程",depth:3},{text:"3.7 某医科技面试",id:"37-某医科技面试",depth:3},{text:"promise 状态吸收",id:"promise-状态吸收",depth:3}],title:"面试问题复盘",headingTitle:"面试问题复盘",frontmatter:{}}}}]);