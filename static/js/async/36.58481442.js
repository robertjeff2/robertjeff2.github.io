"use strict";(self.webpackChunkjeff_blog=self.webpackChunkjeff_blog||[]).push([["36"],{3255:function(e,n,i){i.r(n),i.d(n,{default:()=>t});var l=i(5893),r=i(65);function c(e){let n=Object.assign({h1:"h1",a:"a",ul:"ul",li:"li",blockquote:"blockquote",p:"p"},(0,r.ah)(),e.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(n.h1,{id:"37-面试",children:["3.7 面试",(0,l.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#37-面试",children:"#"})]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"1.事件循环,宏任务微任务"}),"\n",(0,l.jsx)(n.li,{children:"2.vue router"}),"\n",(0,l.jsx)(n.li,{children:"3.pinia vuex"}),"\n",(0,l.jsx)(n.li,{children:"4.内存快照"}),"\n",(0,l.jsx)(n.li,{children:"5.组件间传值 父子兄弟传值方式"}),"\n",(0,l.jsx)(n.li,{children:"6.promise 原理"}),"\n",(0,l.jsx)(n.li,{children:"7.权限控制,分角色"}),"\n",(0,l.jsxs)(n.li,{children:["8.keep-alive 原理属性","\n",(0,l.jsxs)(n.blockquote,{children:["\n",(0,l.jsx)(n.p,{children:"keep-alive 是一个内置组件,用来在多个组件间动态切换时缓存被移除的组件实例\n定制行为 include exclude prop 来定制行为\n传入 max prop 来限制可被缓存的最大组件实例数\n指定 max 后内部执行类 LRU 算法: 如果缓存的实例数量即将超过指定的 max,则最久没有访问的缓存实例被销毁 底层原理 set?\n生命周期勾子 onActivated 和 onDeacticated 注册两个状态的生命周期勾子"}),"\n"]}),"\n"]}),"\n"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,r.ah)(),e.components);return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}let t=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["experience%2Finterview%2Findex.md"]={toc:[],title:"3.7 面试",headingTitle:"3.7 面试",frontmatter:{}}}}]);