"use strict";(self.webpackChunkjeff_blog=self.webpackChunkjeff_blog||[]).push([["406"],{2672:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var s=r(5893),i=r(65);function d(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",ul:"ul",li:"li",h3:"h3",strong:"strong",h4:"h4",code:"code",hr:"hr",p:"p",blockquote:"blockquote",pre:"pre",ol:"ol"},(0,i.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"前端面试准备",children:["前端面试准备",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#前端面试准备",children:"#"})]}),"\n",(0,s.jsxs)(n.h2,{id:"目录",children:["目录",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#目录",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#JS%E5%9F%BA%E7%A1%80%E4%B8%80",children:"JS 基础(一)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B",children:"基础类型"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#this",children:"this"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#JS%E5%9F%BA%E7%A1%80%E4%BA%8C",children:"JS 基础(二)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E9%97%AD%E5%8C%85",children:"闭包"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D",children:"深浅拷贝"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E6%B5%85%E6%8B%B7%E8%B4%9D",children:"浅拷贝"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E6%B7%B1%E6%8B%B7%E8%B4%9D",children:"深拷贝"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E5%8E%9F%E5%9E%8B",children:"原型"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#ES6",children:"ES6"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#var-let-const",children:"var let const"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#class-%E7%BB%A7%E6%89%BF",children:"class 继承"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E6%A8%A1%E5%9D%97%E5%8C%96",children:"模块化"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#Proxy",children:"Proxy"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95mapfilterreduce",children:"数组方法 map,filter,reduce"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#JS%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E9%A2%98",children:"JS 异步编程题"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#Promise",children:"Promise"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A1%B9%E9%A2%98",children:"面试专项题"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#AJAX-fetch-axios",children:"AJAX fetch axios"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB",children:"防抖节流什么区别"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"一技术基础强化核心必考",children:[(0,s.jsx)(n.strong,{children:"一、技术基础强化（核心必考）"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#一技术基础强化核心必考",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"1-javascript-底层原理",children:[(0,s.jsx)(n.strong,{children:"1. JavaScript 底层原理"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-javascript-底层原理",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"闭包/作用域链"}),"：手写闭包场景，解释内存泄漏风险。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"原型链与继承"}),"：实现寄生组合继承，对比 ES6 ",(0,s.jsx)(n.code,{children:"class"})," 差异。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Loop"}),"：结合宏任务/微任务分析代码执行顺序，解释 ",(0,s.jsx)(n.code,{children:"Promise"}),"、",(0,s.jsx)(n.code,{children:"async/await"})," 的底层逻辑。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"手写高频 API"}),"：实现 ",(0,s.jsx)(n.code,{children:"Promise.all"}),"、",(0,s.jsx)(n.code,{children:"深拷贝"}),"、",(0,s.jsx)(n.code,{children:"防抖/节流"}),"、",(0,s.jsx)(n.code,{children:"柯里化函数"})," 等。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"2-框架核心原理",children:[(0,s.jsx)(n.strong,{children:"2. 框架核心原理"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-框架核心原理",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"React"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"虚拟 DOM Diff 算法优化逻辑。"}),"\n",(0,s.jsxs)(n.li,{children:["Hooks 原理（如 ",(0,s.jsx)(n.code,{children:"useState"})," 如何绑定到 Fiber 节点）。"]}),"\n",(0,s.jsx)(n.li,{children:"性能优化手段（React.memo、useMemo 使用场景）。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Vue"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"响应式原理（Vue2 的 Object.defineProperty 与 Vue3 的 Proxy 对比）。"}),"\n",(0,s.jsx)(n.li,{children:"模板编译流程（AST 转换到 render 函数）。"}),"\n",(0,s.jsx)(n.li,{children:"手写简易版 Vue 响应式系统。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"3-浏览器与网络",children:[(0,s.jsx)(n.strong,{children:"3. 浏览器与网络"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-浏览器与网络",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"渲染机制"}),"：从输入 URL 到页面渲染的完整流程，关键优化点（如 CRP 优化）。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"缓存策略"}),"：强缓存与协商缓存的 Header 字段，Service Worker 应用场景。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"跨域解决方案"}),"：CORS 预检请求细节，JSONP 安全性问题。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"4-前端工程化",children:[(0,s.jsx)(n.strong,{children:"4. 前端工程化"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#4-前端工程化",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Webpack"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"打包流程（Loader 与 Plugin 的区别）。"}),"\n",(0,s.jsx)(n.li,{children:"优化配置（Tree Shaking 原理、Code Splitting 策略）。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"性能监控"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"使用 Lighthouse 分析性能指标（FCP、LCP、CLS）。"}),"\n",(0,s.jsx)(n.li,{children:"实现前端错误监控（SourceMap 还原线上错误）。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"二项目经验深挖高频追问点",children:[(0,s.jsx)(n.strong,{children:"二、项目经验深挖（高频追问点）"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#二项目经验深挖高频追问点",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"1-项目难点与解决方案",children:[(0,s.jsx)(n.strong,{children:"1. 项目难点与解决方案"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-项目难点与解决方案",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"典型问题"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"“介绍一个你主导的复杂项目，如何设计技术方案？”"}),"\n",(0,s.jsx)(n.li,{children:"“遇到过哪些性能瓶颈？如何定位并解决？”"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"回答策略"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["使用 ",(0,s.jsx)(n.strong,{children:"STAR 法则"}),"（背景、任务、行动、结果）。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"量化成果"}),"：如“首屏加载时间从 3s 优化至 1.2s”。"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"2-技术选型与权衡",children:[(0,s.jsx)(n.strong,{children:"2. 技术选型与权衡"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-技术选型与权衡",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["准备问题：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"“为什么选择 React 而不是 Vue？”"}),"\n",(0,s.jsx)(n.li,{children:"“微前端方案（如 qiankun）的落地挑战是什么？”"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["加分回答：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"结合业务场景（如团队协作成本、生态支持度）分析。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"3-协作与流程优化",children:[(0,s.jsx)(n.strong,{children:"3. 协作与流程优化"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-协作与流程优化",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["举例说明：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如何推动团队落地代码规范（ESLint + Git Hooks）。"}),"\n",(0,s.jsx)(n.li,{children:"设计前端埋点系统或 CI/CD 自动化流程。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"三算法与数据结构大厂必考",children:[(0,s.jsx)(n.strong,{children:"三、算法与数据结构（大厂必考）"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#三算法与数据结构大厂必考",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"1-刷题重点",children:[(0,s.jsx)(n.strong,{children:"1. 刷题重点"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-刷题重点",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"高频题型"}),"：数组/字符串操作、链表、二叉树、DFS/BFS、动态规划。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"前端相关题"}),"：DOM 树遍历（递归/迭代）、模板解析（栈结构应用）。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"2-刷题策略",children:[(0,s.jsx)(n.strong,{children:"2. 刷题策略"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-刷题策略",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"LeetCode 精选"}),"：优先刷 Hot 100 和前端厂题库（如字节、阿里）。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"手写代码规范"}),"：注重边界条件处理，代码可读性（命名、注释）。"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"四系统设计能力高阶岗位重点",children:[(0,s.jsx)(n.strong,{children:"四、系统设计能力（高阶岗位重点）"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#四系统设计能力高阶岗位重点",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"1-前端架构设计",children:[(0,s.jsx)(n.strong,{children:"1. 前端架构设计"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-前端架构设计",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"场景题"}),"：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"“设计一个高并发场景下的前端缓存方案。”"}),"\n",(0,s.jsx)(n.li,{children:"“如何实现跨团队组件库的灰度发布？”"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"考察点"}),"：模块拆分、状态管理、异常兜底方案。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"2-全栈能力验证",children:[(0,s.jsx)(n.strong,{children:"2. 全栈能力验证"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-全栈能力验证",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["准备方向：","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"实现一个 SSR（服务端渲染）方案。"}),"\n",(0,s.jsx)(n.li,{children:"设计一个短链生成系统的前后端架构。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"五行为面试与软技能",children:[(0,s.jsx)(n.strong,{children:"五、行为面试与软技能"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#五行为面试与软技能",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"1-常见问题",children:[(0,s.jsx)(n.strong,{children:"1. 常见问题"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-常见问题",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"“为什么离开上一家公司？”"}),"\n",(0,s.jsx)(n.li,{children:"“如何推动技术方案在团队中落地？”"}),"\n",(0,s.jsx)(n.li,{children:"“与产品经理发生分歧时如何处理？”"}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"2-回答技巧",children:[(0,s.jsx)(n.strong,{children:"2. 回答技巧"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-回答技巧",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"避坑指南"}),"：避免抱怨前公司，聚焦个人成长诉求。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"展示潜力"}),"：强调自主学习（如“通过研究 WebAssembly 优化项目性能”）。"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"六简历优化与面试模拟",children:[(0,s.jsx)(n.strong,{children:"六、简历优化与面试模拟"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#六简历优化与面试模拟",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"1-简历打磨",children:[(0,s.jsx)(n.strong,{children:"1. 简历打磨"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-简历打磨",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"突出亮点"}),"：使用关键词如“性能优化 40%”“主导组件库重构”。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"数据支撑"}),"：如“日均 PV 1000 万+的系统稳定性保障”。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"2-模拟面试",children:[(0,s.jsx)(n.strong,{children:"2. 模拟面试"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-模拟面试",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"技术模拟"}),"：找同行模拟框架原理追问（如“React Fiber 如何中断/恢复任务”）。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"压力测试"}),"：练习在白板上手写代码并解释思路。"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"七资源推荐",children:[(0,s.jsx)(n.strong,{children:"七、资源推荐"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#七资源推荐",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"书籍"}),"：《JavaScript 高级程序设计》《前端架构设计》"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"学习平台"}),"：极客时间（前端进阶课）、Frontend Masters"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"工具"}),"：CodeSandbox 在线编码练习、Chrome DevTools 性能分析实战"]}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.h3,{id:"八面试后复盘",children:[(0,s.jsx)(n.strong,{children:"八、面试后复盘"}),(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#八面试后复盘",children:"#"})]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"记录问题"}),"：整理被问倒的技术点，针对性补漏。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"横向对比"}),"：分析不同公司对“3 年经验前端”的能力侧重（如大厂重算法，创业公司重落地速度）。"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"js-基础一",children:["JS 基础(一)",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#js-基础一",children:"#"})]}),"\n",(0,s.jsxs)(n.h3,{id:"基础类型",children:["基础类型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基础类型",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"原始类型 "}),"\n",(0,s.jsx)(n.p,{children:"boolean null undefined number string symbol"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"typeof null"}),"会输出",(0,s.jsx)(n.code,{children:"object"})," 属于 js 遗留 bug"]}),"\n",(0,s.jsx)(n.p,{children:"对象类型"}),"\n",(0,s.jsx)(n.p,{children:"对象类型存储的是地址 原始类型存储的是值"}),"\n",(0,s.jsx)(n.p,{children:"Object function array 等"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"typeof"}),"对于原始类型来说，除了",(0,s.jsx)(n.code,{children:"null"}),"都可以显示正确的类型"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:'title="type示例"',children:"typeof 1; // 'number'\ntypeof '1'; // 'string'\ntypeof undefined; // 'undefined'\ntypeof true; // 'boolean'\ntypeof Symbol(); // 'symbol'\n"})}),"\n",(0,s.jsx)(n.p,{children:"对于对象来说 除了 function 都是 Object 所以不准确"}),"\n",(0,s.jsx)(n.p,{children:"instanceof 是用来判断对象的类型 内部机制是通过原型链来判断的"}),"\n",(0,s.jsx)(n.p,{children:"instanceof 支持自定义 , Symbol.hasInstance"}),"\n",(0,s.jsxs)(n.h3,{id:"this",children:["this",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#this",children:"#"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function foo() {\n  console.log(this.a);\n}\nvar a = 1;\nfoo();\nconst obj = { a: 2, foo: foo };\nobj.foo();\nconst c = new foo();\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["对于直接调用",(0,s.jsx)(n.code,{children:"foo"}),"来说，不管",(0,s.jsx)(n.code,{children:"foo"}),"函数被放在了什么地方，",(0,s.jsx)(n.code,{children:"this"}),"一定是",(0,s.jsx)(n.code,{children:"window"})]}),"\n",(0,s.jsxs)(n.li,{children:["对于",(0,s.jsx)(n.code,{children:"obj.foo()"}),"来说，我们只需要记住，谁调用了函数，谁就是",(0,s.jsx)(n.code,{children:"this"}),"，所以在这个场景下",(0,s.jsx)(n.code,{children:"foo"}),"函数中的",(0,s.jsx)(n.code,{children:"this"}),"就是",(0,s.jsx)(n.code,{children:"obj"}),"对象"]}),"\n",(0,s.jsxs)(n.li,{children:["对于",(0,s.jsx)(n.code,{children:"new"}),"的方式来说，",(0,s.jsx)(n.code,{children:"this"}),"被永远绑定在了",(0,s.jsx)(n.code,{children:"c"}),"上面，不会被任何方式改变",(0,s.jsx)(n.code,{children:"this"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"箭头函数中的 this 取决的是外层作用域的 this 如果没有,就往上层作用域查找 this"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"new"}),"的方式优先级最高，接下来是",(0,s.jsx)(n.code,{children:"bind"}),"这些函数，然后是",(0,s.jsx)(n.code,{children:"obj.foo()"}),"这种调用方式，最后是",(0,s.jsx)(n.code,{children:"foo"}),"这种调用方式，同时，箭头函数的",(0,s.jsx)(n.code,{children:"this"}),"一旦被绑定，就不会再被任何方式所改变。"]}),"\n",(0,s.jsxs)(n.h3,{id:"js-基础二",children:["JS 基础(二)",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#js-基础二",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"== 和 === 有什么区别？"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"=="}),"来说，如果对比双方的类型",(0,s.jsx)(n.strong,{children:"不一样"}),"的话，就会进行",(0,s.jsx)(n.strong,{children:"类型转换"}),"，这也就用到了我们上一章节讲的内容。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"==="})," 是值和类型都相等"]}),"\n",(0,s.jsxs)(n.h4,{id:"闭包",children:["闭包",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#闭包",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"涉及面试题：什么是闭包？"}),"\n",(0,s.jsx)(n.p,{children:"闭包的定义其实很简单：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["循环中使用闭包解决 ",(0,s.jsx)(n.code,{children:"var"})," 定义函数的问题"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"for (var i = 1; i <= 5; i++) {\n  setTimeout(function timer() {\n    console.log(i);\n  }, i * 1000);\n}\n//输出一堆6 因为当timer执行的时候 for循环已经执行完毕\n"})}),"\n",(0,s.jsx)(n.p,{children:"可以使用闭包解决"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"for (var i = 1; i <= 5; i++) {\n  (function (j) {\n    setTimeout(function timer() {\n      console.log(j);\n    }, j * 1000);\n  })(i);\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["在上述代码中，我们首先使用了立即执行函数将",(0,s.jsx)(n.code,{children:"i"}),"传入函数内部，这个时候值就被固定在了参数",(0,s.jsx)(n.code,{children:"j"}),"上面不会改变，当下次执行",(0,s.jsx)(n.code,{children:"timer"}),"这个闭包的时候，就可以使用外部函数的变量",(0,s.jsx)(n.code,{children:"j"}),"，从而达到目的。"]}),"\n",(0,s.jsxs)(n.h4,{id:"深浅拷贝",children:["深浅拷贝",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#深浅拷贝",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"浅拷贝",children:["浅拷贝",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#浅拷贝",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:["1.浅拷贝通过",(0,s.jsx)(n.code,{children:"Object.assign"})," 实现, ",(0,s.jsx)(n.code,{children:"Object.assign"}),"只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。"]}),"\n",(0,s.jsxs)(n.p,{children:["2.通过展开运算符实现",(0,s.jsx)(n.code,{children:"..."})," "]}),"\n",(0,s.jsx)(n.p,{children:"浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话,就需要用深拷贝实现"}),"\n",(0,s.jsxs)(n.h4,{id:"深拷贝",children:["深拷贝",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#深拷贝",children:"#"})]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"JSON.parse(JSON.stringify(object))"})}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"局限性: "}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["会忽略",(0,s.jsx)(n.code,{children:"undefined"})]}),"\n",(0,s.jsxs)(n.li,{children:["会忽略",(0,s.jsx)(n.code,{children:"symbol"})]}),"\n",(0,s.jsx)(n.li,{children:"不能序列化函数"}),"\n",(0,s.jsx)(n.li,{children:"不能解决循环引用的对象"}),"\n"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["不包含函数的 可以使用 ",(0,s.jsx)(n.code,{children:"MessageChannel"})]}),"\n",(0,s.jsx)(n.li,{children:"自己实现深拷贝"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"通过判断类型,递归实现"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:'title="简易版深拷贝"',children:"function deepClone(obj) {\n  function isObject(o) {\n    return (typeof o === 'object' || typeof o === 'function') && o !== null;\n  }\n\n  if (!isObject(obj)) {\n    throw new Error('非对象');\n  }\n\n  let isArray = Array.isArray(obj);\n  let newObj = isArray ? [...obj] : { ...obj };\n  Reflect.ownKeys(newObj).forEach((key) => {\n    newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key];\n  });\n\n  return newObj;\n}\n\nlet obj = {\n  a: [1, 2, 3],\n  b: {\n    c: 2,\n    d: 3\n  }\n};\nlet newObj = deepClone(obj);\nnewObj.b.c = 1;\nconsole.log(obj.b.c); // 2\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"原型",children:["原型",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#原型",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"面试题: 如何理解原型？如何理解原型链？"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"每一个对象上的内置属性 prototype"}),"\n",(0,s.jsxs)(n.p,{children:["对象原型",(0,s.jsx)(n.code,{children:"__proto"}),"__ "]}),"\n",(0,s.jsxs)(n.p,{children:["函数原型",(0,s.jsx)(n.code,{children:"prototype"})]}),"\n",(0,s.jsx)(n.p,{children:"直接读取存在兼容性问题 Object.getPrototypeOf 方法获取(生产环境)"}),"\n",(0,s.jsxs)(n.p,{children:["原型之间相互引用形成了链条,即一个指向一个最顶层为",(0,s.jsx)(n.code,{children:"null"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"补充：new 操作符做的事情"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"1.创建一个新对象"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"2.将函数的 this 绑定到这个对象上"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"3.将函数的 prottyp 复制给新对象的[prototype]属性"}),"\n"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"4.默认返回这个新对象"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"总结:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Object"}),"是所有对象的爸爸，所有对象都可以通过",(0,s.jsx)(n.code,{children:"__proto__"}),"找到它"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"Function"}),"是所有函数的爸爸，所有函数都可以通过",(0,s.jsx)(n.code,{children:"__proto__"}),"找到它"]}),"\n",(0,s.jsxs)(n.li,{children:["函数的",(0,s.jsx)(n.code,{children:"prototype"}),"是一个对象"]}),"\n",(0,s.jsxs)(n.li,{children:["对象的",(0,s.jsx)(n.code,{children:"__proto__"}),"属性指向原型，",(0,s.jsx)(n.code,{children:"__proto__"}),"将对象和原型连接起来组成了原型链"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"es6",children:["ES6",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#es6",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"var-let-const",children:["var let const",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#var-let-const",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["var : 使用",(0,s.jsx)(n.code,{children:"var"}),"声明的变量会被提升到作用域的顶部"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"let"}),"、",(0,s.jsx)(n.code,{children:"const"}),"因为暂时性死区的原因，不能在声明前使用"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"var"}),"在全局作用域下声明变量会导致变量挂载在",(0,s.jsx)(n.code,{children:"window"}),"上，其他两者不会"]}),"\n",(0,s.jsxs)(n.h4,{id:"class-继承",children:["class 继承",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#class-继承",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"在 js 中并不存在类, class 是语法糖本质还是函数"}),"\n",(0,s.jsx)(n.p,{children:"原型继承"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"function Parent(value) {\n  this.val = value;\n}\nParent.prototype.getValue = function () {\n  console.log(this.val);\n};\nfunction Child(value) {\n  Parent.call(this, value);\n}\nChild.prototypy = new Parent();\nconst child = new Child(1);\n\nchild.getValue(); //1\nchile instanceof Parent; //true\n"})}),"\n",(0,s.jsxs)(n.p,{children:["通过",(0,s.jsx)(n.code,{children:"Parent.call(this)"}),"继承父类的属性，然后改变子类的原型为",(0,s.jsx)(n.code,{children:"new Parent()"}),"来继承父类的函数"]}),"\n",(0,s.jsx)(n.p,{children:"继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。"}),"\n",(0,s.jsx)(n.p,{children:"class 继承"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"class Parent {\n  constructor(value) {\n    this.val = value;\n  }\n  getValue() {\n    console.log(this.val);\n  }\n}\nclass Chile extends Parent {\n  constructor(value) {\n    super(value);\n    this.val = value;\n  }\n}\nlet child = new Child(1);\nchild.getValue(); //1\nchile instanceof Parent; ///true\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"class"}),"实现继承的核心在于使用",(0,s.jsx)(n.code,{children:"extends"}),"表明继承自哪个父类，并且在子类构造函数中必须调用",(0,s.jsx)(n.code,{children:"super"}),"，因为这段代码可以看成",(0,s.jsx)(n.code,{children:"Parent.call(this, value)"})]}),"\n",(0,s.jsxs)(n.h4,{id:"模块化",children:["模块化",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块化",children:"#"})]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"commonJs "}),"\n",(0,s.jsx)(n.p,{children:"在 Webpack 中经常可以见到 ,在打包后的 js 文件里"}),"\n",(0,s.jsxs)(n.p,{children:["支持动态导入,使用",(0,s.jsx)(n.code,{children:"require()"})]}),"\n",(0,s.jsx)(n.p,{children:"Es module "}),"\n",(0,s.jsx)(n.p,{children:"原生实现的模块化方案"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:'title="Es module"',children:"// 引入模块 API\nimport XXX from './a.js';\nimport { XXX } from './a.js';\n// 导出模块 API\nexport function a() {}\nexport default function () {}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["CommonJS 支持动态导入，也就是",(0,s.jsx)(n.code,{children:"require(${path}/xx.js)"}),"，后者目前不支持，但是已有提案"]}),"\n",(0,s.jsx)(n.li,{children:"CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响"}),"\n",(0,s.jsx)(n.li,{children:"CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化"}),"\n",(0,s.jsxs)(n.li,{children:["ES Module 会编译成",(0,s.jsx)(n.code,{children:"require/exports"}),"来执行的"]}),"\n"]}),"\n",(0,s.jsxs)(n.h4,{id:"proxy",children:["Proxy",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#proxy",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"vue3 的响应式实现原理 "}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"let onWatch = (obj, setBind, getLogger) => {\n  let handler = {\n    get(target, property, receiver) {\n      getLogger(target, property);\n      return Reflect.get(target, property, receiver);\n    },\n    set(target, property, value, receiver) {\n      setBind(value, property);\n      return Reflect.set(target, property, value);\n    }\n  };\n  return new Proxy(obj, handler);\n};\n\nlet obj = { a: 1 };\nlet p = onWatch(\n  obj,\n  (v, property) => {\n    console.log(`监听到属性${property}改变为${v}`);\n  },\n  (target, property) => {\n    console.log(`'${property}' = ${target[property]}`);\n  }\n);\np.a = 2; // 监听到属性a改变\np.a; // 'a' = 2\n"})}),"\n",(0,s.jsxs)(n.p,{children:["需要我们在",(0,s.jsx)(n.code,{children:"get"}),"中收集依赖，在",(0,s.jsx)(n.code,{children:"set"}),"派发更新，之所以 Vue3.0 要使用",(0,s.jsx)(n.code,{children:"Proxy"}),"替换原本的 API 原因在于",(0,s.jsx)(n.code,{children:"Proxy"}),"无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是",(0,s.jsx)(n.code,{children:"Proxy"}),"可以完美监听到任何方式的数据改变，缺陷可能就是浏览器的兼容性不好了。"]}),"\n",(0,s.jsxs)(n.h4,{id:"数组方法-mapfilterreduce",children:["数组方法 map,filter,reduce",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#数组方法-mapfilterreduce",children:"#"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"map"}),"作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"[1, 2, 3].map((v) => v + 1); // -> [2, 3, 4]\n"})}),"\n",(0,s.jsxs)(n.p,{children:["另外",(0,s.jsx)(n.code,{children:"map"}),"的回调函数接受三个参数，分别是当前索引元素，索引，原数组"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"经典 map 代码题"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"['1', '2', '3'].map(parseInt); //[1,NaN,NaN]\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"第一轮遍历 parseInt('1', 0) -> 1"}),"\n",(0,s.jsx)(n.li,{children:"第二轮遍历 parseInt('2', 1) -> NaN"}),"\n",(0,s.jsx)(n.li,{children:"第三轮遍历 parseInt('3', 2) -> NaN"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"filter"}),"的作用也是生成一个新数组，在遍历数组的时候将返回值为",(0,s.jsx)(n.code,{children:"true"}),"的元素放入新数组，我们可以利用这个函数删除一些不需要的元素"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"reduce"}),"可以将数组中的元素通过回调函数最终转换为一个值。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:'title="reduce"',children:"const arr = [1, 2, 3];\nlet total = 0;\nfor (let i = 0; i < arr.length; i++) {\n  total += arr[i];\n}\nconsole.log(total); //6\n//转换为\nconst arr = [1, 2, 3];\nconst sum = arr.reduce((acc, current) => acc + current, 0);\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"js-异步编程题",children:["JS 异步编程题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#js-异步编程题",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"promise",children:["Promise",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#promise",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"三个状态"}),"\n",(0,s.jsx)(n.p,{children:"Pending Fulfilled Rejected"}),"\n",(0,s.jsxs)(n.p,{children:["在构造",(0,s.jsx)(n.code,{children:"Promise"}),"的时候，构造函数内部的代码是立即执行的"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:"new Promise((resolve, reject) => {\n  console.log('new Promise');\n  resolve('success');\n});\nconsole.log('finifsh');\n// new Promise -> finifsh\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"Promise"}),"实现了链式调用，也就是说每次调用",(0,s.jsx)(n.code,{children:"then"}),"之后返回的都是一个",(0,s.jsx)(n.code,{children:"Promise"}),"，并且是一个全新的",(0,s.jsx)(n.code,{children:"Promise"}),"，原因也是因为状态不可变。如果你在",(0,s.jsx)(n.code,{children:"then"}),"中 使用了",(0,s.jsx)(n.code,{children:"return"}),"，那么",(0,s.jsx)(n.code,{children:"return"}),"的值会被",(0,s.jsx)(n.code,{children:"Promise.resolve()"}),"包装"]}),"\n",(0,s.jsx)(n.p,{children:"主要解决了回调地狱的问题"}),"\n",(0,s.jsx)(n.p,{children:"Promise/A+ 规范 手写"}),"\n",(0,s.jsxs)(n.h3,{id:"面试专项题",children:["面试专项题",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#面试专项题",children:"#"})]}),"\n",(0,s.jsxs)(n.h4,{id:"ajax-fetch-axios",children:["AJAX fetch axios",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#ajax-fetch-axios",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"ajax 是一个技术统称 asynchronous javascript and xml"}),"\n",(0,s.jsx)(n.p,{children:"fetch 是一个浏览器原生 API, 支持 promise"}),"\n",(0,s.jsx)(n.p,{children:"axios 是第三方库 发起网络请求 内部 XMLHttpRequest 和 fetch 来实现"}),"\n",(0,s.jsxs)(n.h4,{id:"防抖节流什么区别",children:["防抖节流什么区别",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖节流什么区别",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"1.两者区别,2.使用场景 ?  "}),"\n",(0,s.jsx)(n.p,{children:"防抖: 防止抖动,等不抖了 在执行下一步."}),"\n",(0,s.jsx)(n.p,{children:"输入框一直输入等输入停止后再去搜索,按钮多次点击 "}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:'title="手写防抖函数"',children:"function debounce(fn, delay = 200) {\n  let timer = null;\n  return function () {\n    //如果存在定时器就重新计时\n    if (timer) clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, arguments);\n      timer = null;\n    }, delay);\n  };\n}\n"})})]})}function l(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["notes%2Finterview%2Findex.md"]={toc:[{text:"目录",id:"目录",depth:2},{text:"**一、技术基础强化（核心必考）**",id:"一技术基础强化核心必考",depth:3},{text:"**1. JavaScript 底层原理**",id:"1-javascript-底层原理",depth:4},{text:"**2. 框架核心原理**",id:"2-框架核心原理",depth:4},{text:"**3. 浏览器与网络**",id:"3-浏览器与网络",depth:4},{text:"**4. 前端工程化**",id:"4-前端工程化",depth:4},{text:"**二、项目经验深挖（高频追问点）**",id:"二项目经验深挖高频追问点",depth:3},{text:"**1. 项目难点与解决方案**",id:"1-项目难点与解决方案",depth:4},{text:"**2. 技术选型与权衡**",id:"2-技术选型与权衡",depth:4},{text:"**3. 协作与流程优化**",id:"3-协作与流程优化",depth:4},{text:"**三、算法与数据结构（大厂必考）**",id:"三算法与数据结构大厂必考",depth:3},{text:"**1. 刷题重点**",id:"1-刷题重点",depth:4},{text:"**2. 刷题策略**",id:"2-刷题策略",depth:4},{text:"**四、系统设计能力（高阶岗位重点）**",id:"四系统设计能力高阶岗位重点",depth:3},{text:"**1. 前端架构设计**",id:"1-前端架构设计",depth:4},{text:"**2. 全栈能力验证**",id:"2-全栈能力验证",depth:4},{text:"**五、行为面试与软技能**",id:"五行为面试与软技能",depth:3},{text:"**1. 常见问题**",id:"1-常见问题",depth:4},{text:"**2. 回答技巧**",id:"2-回答技巧",depth:4},{text:"**六、简历优化与面试模拟**",id:"六简历优化与面试模拟",depth:3},{text:"**1. 简历打磨**",id:"1-简历打磨",depth:4},{text:"**2. 模拟面试**",id:"2-模拟面试",depth:4},{text:"**七、资源推荐**",id:"七资源推荐",depth:3},{text:"**八、面试后复盘**",id:"八面试后复盘",depth:3},{text:"JS 基础(一)",id:"js-基础一",depth:3},{text:"基础类型",id:"基础类型",depth:3},{text:"this",id:"this",depth:3},{text:"JS 基础(二)",id:"js-基础二",depth:3},{text:"闭包",id:"闭包",depth:4},{text:"深浅拷贝",id:"深浅拷贝",depth:4},{text:"浅拷贝",id:"浅拷贝",depth:4},{text:"深拷贝",id:"深拷贝",depth:4},{text:"原型",id:"原型",depth:4},{text:"ES6",id:"es6",depth:3},{text:"var let const",id:"var-let-const",depth:4},{text:"class 继承",id:"class-继承",depth:4},{text:"模块化",id:"模块化",depth:4},{text:"Proxy",id:"proxy",depth:4},{text:"数组方法 map,filter,reduce",id:"数组方法-mapfilterreduce",depth:4},{text:"JS 异步编程题",id:"js-异步编程题",depth:3},{text:"Promise",id:"promise",depth:4},{text:"面试专项题",id:"面试专项题",depth:3},{text:"AJAX fetch axios",id:"ajax-fetch-axios",depth:4},{text:"防抖节流什么区别",id:"防抖节流什么区别",depth:4}],title:"前端面试准备",headingTitle:"前端面试准备",frontmatter:{}}}}]);