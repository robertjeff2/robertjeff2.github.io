"use strict";(self.webpackChunkjeff_blog=self.webpackChunkjeff_blog||[]).push([["224"],{6784:function(n,e,s){s.r(e),s.d(e,{default:()=>c});var r=s(5893),i=s(65);function d(n){let e=Object.assign({h1:"h1",a:"a",h3:"h3",p:"p",ul:"ul",li:"li",blockquote:"blockquote",strong:"strong",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",code:"code",pre:"pre",ol:"ol",br:"br",h4:"h4"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"面试问题复盘",children:["面试问题复盘",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#面试问题复盘",children:"#"})]}),"\n",(0,r.jsxs)(e.h3,{id:"项目中遇到的最大挑战是什么后来如何解决的",children:["项目中遇到的最大挑战是什么,后来如何解决的",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#项目中遇到的最大挑战是什么后来如何解决的",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"高分回答要点:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"真实性：选择真实、有技术深度的案例，避免虚构。"}),"\n",(0,r.jsx)(e.li,{children:"结构化：用 STAR 法则清晰表达，避免冗长。"}),"\n",(0,r.jsx)(e.li,{children:"技术细节：提及工具（Webpack/Lighthouse）、方法（代码分割/缓存策略），展示专业度。"}),"\n",(0,r.jsx)(e.li,{children:"软技能：体现沟通、领导力（如协调团队）和复盘能力。"}),"\n",(0,r.jsxs)(e.li,{children:["数据化结果：用百分比、时间等量化指标增强说服力。\n示例: 在开发某电商平台时，我负责解决首屏加载过慢的问题（5 秒+）。通过 Lighthouse 分析，发现图片体积和接口响应是瓶颈。我主导将图片转换为 WebP 格式并接入 CDN，推动后端为商品接口添加 Redis 缓存，同时用虚拟滚动优化长列表渲染。最终首屏时间降至 1.3 秒，跳出率降低 25%。这次经历让我学会用数据驱动跨团队协作，并在后续项目中提前设定性能预算以避免类似问题。","\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"要避免的陷阱包括：不要抱怨之前的团队或同事，不要选择因为自己疏忽导致的错误作为挑战（比如因为自己代码写错导致的 bug），而应该选外部因素或技术难点。同时，要展示积极的态度和解决问题的能力。\n比如，好的例子可能是处理高并发下的系统崩溃，通过水平扩展和负载均衡解决；或者在前端项目中实现复杂的交互需求，通过研究新技术或第三方库来解决。\n再检查一下是否有遗漏的要点，比如是否展示了分析问题、解决问题、团队合作、学习能力等。可能还需要量化结果，比如性能提升了多少百分比，用户满意度提高，或者项目按时交付等数据，这样更有说服力。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"token-放在-cookie-还是-localstorage",children:["token 放在 cookie 还是 localStorage",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#token-放在-cookie-还是-localstorage",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["在前端开发中，将 Token 存储在 ",(0,r.jsx)(e.strong,{children:"Cookie"})," 还是 ",(0,r.jsx)(e.strong,{children:"LocalStorage"})," 是一个常见的安全与设计权衡问题。以下是两者的核心对比及最佳实践建议："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"一、核心对比"})}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{children:(0,r.jsx)(e.strong,{children:"特性"})}),"\n",(0,r.jsx)(e.th,{children:(0,r.jsx)(e.strong,{children:"Cookie"})}),"\n",(0,r.jsx)(e.th,{children:(0,r.jsx)(e.strong,{children:"LocalStorage"})}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"安全性"})}),"\n",(0,r.jsxs)(e.td,{children:["✅ 支持 ",(0,r.jsx)(e.code,{children:"HttpOnly"})," 防止 XSS 读取"]}),"\n",(0,r.jsx)(e.td,{children:"❌ JavaScript 可直接访问，易受 XSS 攻击"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"自动携带"})}),"\n",(0,r.jsxs)(e.td,{children:["✅ 请求自动携带在 ",(0,r.jsx)(e.code,{children:"Cookie"})," 头中"]}),"\n",(0,r.jsxs)(e.td,{children:["❌ 需手动添加到请求头（如 ",(0,r.jsx)(e.code,{children:"Authorization"}),"）"]}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"存储容量"})}),"\n",(0,r.jsx)(e.td,{children:"4KB 左右"}),"\n",(0,r.jsx)(e.td,{children:"5MB+"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"跨域支持"})}),"\n",(0,r.jsxs)(e.td,{children:["需配置 ",(0,r.jsx)(e.code,{children:"SameSite"})," 和 CORS"]}),"\n",(0,r.jsx)(e.td,{children:"无限制，但需手动处理跨域请求头"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"CSRF 风险"})}),"\n",(0,r.jsx)(e.td,{children:"❌ 需额外防护（如 CSRF Token、SameSite）"}),"\n",(0,r.jsx)(e.td,{children:"✅ 无自动携带，CSRF 风险低"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"服务端控制"})}),"\n",(0,r.jsx)(e.td,{children:"✅ 可设置过期时间、Secure、HttpOnly 等属性"}),"\n",(0,r.jsx)(e.td,{children:"❌ 完全由前端控制"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"二、安全性深度分析"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"1. Cookie 的防护机制"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"HttpOnly"})}),"：禁止 JavaScript 读取 Cookie，有效防御 XSS 窃取 Token。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"Secure"})}),"：仅通过 HTTPS 传输，防止中间人攻击。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:(0,r.jsx)(e.code,{children:"SameSite=Strict/Lax"})}),"：阻止跨站请求伪造（CSRF），现代浏览器默认 ",(0,r.jsx)(e.code,{children:"Lax"}),"。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"示例配置（服务端）"}),"：","\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-http",children:"Set-Cookie: token=<value>; Path=/; HttpOnly; Secure; SameSite=Lax\n"})}),"\n",(0,r.jsx)(e.strong,{children:"2. LocalStorage 的风险"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"XSS 攻击"}),"：一旦存在 XSS 漏洞，Token 会被直接窃取。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"无自动过期"}),"：需手动清理或依赖前端逻辑，易长期滞留。\n",(0,r.jsx)(e.strong,{children:"三、适用场景建议"}),"\n",(0,r.jsx)(e.strong,{children:"1. 优先选择 Cookie 的场景"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"需要防御 XSS 窃取 Token"}),"：通过 ",(0,r.jsx)(e.code,{children:"HttpOnly"})," 和 ",(0,r.jsx)(e.code,{children:"Secure"})," 提升安全性。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"依赖自动携带 Token"}),"：简化前端代码，无需手动管理请求头。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"需要服务端控制会话"}),"：如设置过期时间、强制注销等。\n",(0,r.jsx)(e.strong,{children:"2. 选择 LocalStorage 的场景"})]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"需存储较大数据"}),"：如复杂的用户配置信息。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"跨域分离的前后端架构"}),"：如 JWT 需手动添加到 ",(0,r.jsx)(e.code,{children:"Authorization"})," 头。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"对 CSRF 有独立防护"}),"：如已使用 CSRF Token 或加密请求参数。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"四、最佳实践"})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"使用 Cookie 的推荐方案"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["服务端设置 Cookie 时启用 ",(0,r.jsx)(e.code,{children:"HttpOnly"}),"、",(0,r.jsx)(e.code,{children:"Secure"})," 和 ",(0,r.jsx)(e.code,{children:"SameSite=Lax"}),"。"]}),"\n",(0,r.jsx)(e.li,{children:"配合 CSRF Token（双重提交验证）或加密的请求参数。"}),"\n",(0,r.jsx)(e.li,{children:"示例流程："}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 服务端返回 Cookie，前端无需处理 Token\nfetch('/login', { method: 'POST', body: credentials }).then((response) => {\n  // Cookie 自动存储，后续请求自动携带\n});\n"})}),"\n",(0,r.jsxs)(e.ol,{start:"2",children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"使用 LocalStorage 的防护措施"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"避免存储敏感信息，仅存 Token。"}),"\n",(0,r.jsxs)(e.li,{children:["所有接口请求手动添加 Token 到 ",(0,r.jsx)(e.code,{children:"Authorization"})," 头。"]}),"\n",(0,r.jsx)(e.li,{children:"严格过滤输入输出，防御 XSS。"}),"\n",(0,r.jsx)(e.li,{children:"示例代码："}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"// 登录后存储 Token\nlocalStorage.setItem('token', 'Bearer xxx');\n\n// 请求时手动添加\nfetch('/api/data', {\n  headers: {\n    Authorization: localStorage.getItem('token')\n  }\n});\n"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"五、面试回答模板"})}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"“项目中如何选择 Token 存储方式？”"})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsxs)(e.p,{children:["我们优先选择 Cookie 存储 Token，并配置 ",(0,r.jsx)(e.code,{children:"HttpOnly"}),"、",(0,r.jsx)(e.code,{children:"Secure"})," 和 ",(0,r.jsx)(e.code,{children:"SameSite=Lax"})," 防御 XSS 和 CSRF。对于需要更高灵活性的场景（如跨域分离架构），则用 LocalStorage 手动管理 Token，但会严格防御 XSS，如输入过滤、CSP 策略。同时，无论哪种方式，都会确保 HTTPS 加密传输，并设置合理的 Token 过期时间。”"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"通过结合安全需求和架构特点选择存储方式，并明确防御措施，可体现对安全与工程实践的深入理解。"}),"\n",(0,r.jsxs)(e.h3,{id:"浏览器从输入-url-到页面展示的整个过程",children:["浏览器从输入 URL 到页面展示的整个过程",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#浏览器从输入-url-到页面展示的整个过程",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"浏览器从输入 URL 到页面渲染的整个过程可以分为以下几个关键步骤："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"URL 解析与输入处理"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"浏览器解析用户输入，判断是 URL 还是搜索内容。如果是搜索词，使用默认搜索引擎进行搜索；否则，处理 URL。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"DNS 解析"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["将域名转换为 IP 地址：","\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"检查浏览器缓存 → 操作系统缓存 → 本地 Hosts 文件 → 递归查询 DNS 服务器（如未命中缓存）。"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"建立 TCP 连接"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["通过三次握手与服务器建立 TCP 连接：",(0,r.jsx)(e.br,{}),"\n",(0,r.jsx)(e.code,{children:"SYN → SYN-ACK → ACK"}),"。"]}),"\n",(0,r.jsx)(e.li,{children:"若为 HTTPS，还需 TLS 握手（交换证书、协商加密算法、生成会话密钥）。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"发送 HTTP 请求"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"浏览器发送 HTTP 请求，包含请求方法（如 GET）、请求头（User-Agent、Accept 等）。"}),"\n",(0,r.jsx)(e.li,{children:"若存在重定向（如 301/302），重新开始流程。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"服务器处理请求并返回响应"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"服务器处理请求，返回 HTTP 响应（状态码、响应头、HTML 等资源）。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"浏览器解析与渲染"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"构建 DOM 树"}),"：解析 HTML 生成 DOM 树，遇到",(0,r.jsx)(e.code,{children:"<script>"}),"时可能阻塞（除非标记为",(0,r.jsx)(e.code,{children:"async/defer"}),"）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"构建 CSSOM 树"}),"：解析 CSS 生成 CSSOM，CSS 会阻塞渲染（避免 FOUC）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"合并渲染树（Render Tree）"}),"：结合 DOM 和 CSSOM，排除不可见元素（如",(0,r.jsx)(e.code,{children:"<meta>"}),"）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"布局（Layout）"}),"：计算每个节点的尺寸和位置（重排）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"绘制（Paint）"}),"：将渲染树转换为屏幕上的像素（重绘）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"合成（Composite）"}),"：分层绘制，优化渲染性能（如 GPU 加速）。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"加载子资源与优化"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"预加载扫描器（Preload Scanner）"}),"：提前发现资源（如图片、CSS）并并行下载。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"处理 JavaScript"}),"：执行可能修改 DOM/CSSOM 的脚本，触发重新渲染。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"事件触发"}),"：",(0,r.jsx)(e.code,{children:"DOMContentLoaded"}),"（DOM 就绪）→ ",(0,r.jsx)(e.code,{children:"load"}),"（所有资源加载完成）。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:(0,r.jsx)(e.strong,{children:"连接管理与优化"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"HTTP/1.1 使用持久连接，HTTP/2 支持多路复用减少延迟。"}),"\n",(0,r.jsx)(e.li,{children:"缓存策略（强缓存/协商缓存）减少重复请求。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"关键细节与优化"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"缓存机制"}),"：强缓存（Cache-Control/Expires）与协商缓存（ETag/Last-Modified）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"渲染阻塞"}),"：CSSOM 构建阻塞渲染，JS 默认阻塞 DOM 解析。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"现代渲染策略"}),"：渐进式渲染、懒加载、异步脚本。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"安全机制"}),"：CORS 预检、Same-Origin 策略、HTTPS 加密。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"流程图示例"}),"："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"输入URL → DNS解析 → TCP/TLS握手 → 发送请求\n→接收响应 → 解析HTML → 构建DOM/CSSOM → 渲染树\n→ 布局 → 绘制 → 合成 → 页面展示\n"})}),"\n",(0,r.jsx)(e.p,{children:"此过程涉及网络协议、浏览器引擎协作及性能优化策略，理解各阶段有助于诊断页面加载性能问题。"}),"\n",(0,r.jsxs)(e.h3,{id:"37-某医科技面试",children:["3.7 某医科技面试",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#37-某医科技面试",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"1.事件循环,宏任务微任务"}),"\n",(0,r.jsx)(e.li,{children:"2.vue router"}),"\n",(0,r.jsx)(e.li,{children:"3.pinia vuex"}),"\n",(0,r.jsx)(e.li,{children:"4.内存快照"}),"\n",(0,r.jsx)(e.li,{children:"5.组件间传值 父子兄弟传值方式"}),"\n",(0,r.jsx)(e.li,{children:"6.promise 原理"}),"\n",(0,r.jsx)(e.li,{children:"7.权限控制,分角色"}),"\n",(0,r.jsxs)(e.li,{children:["8.keep-alive 原理属性","\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"keep-alive 是一个内置组件,用来在多个组件间动态切换时缓存被移除的组件实例\n定制行为 include exclude prop 来定制行为\n传入 max prop 来限制可被缓存的最大组件实例数\n指定 max 后内部执行类 LRU 算法: 如果缓存的实例数量即将超过指定的 max,则最久没有访问的缓存实例被销毁 底层原理 set?\n生命周期勾子 onActivated 和 onDeacticated 注册两个状态的生命周期勾子"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"promise-状态吸收",children:["promise 状态吸收",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#promise-状态吸收",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"当.then()返回一个已解决的 Promise 时，浏览器会强制插入两次微任务（PromiseResolveThenableJob），导致后续回调被延迟。"}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"331-面试复盘",children:["3.31 面试复盘",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#331-面试复盘",children:"#"})]}),"\n",(0,r.jsxs)(e.h4,{id:"echarts-性能调优举例说明",children:["Echarts 性能调优,举例说明",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#echarts-性能调优举例说明",children:"#"})]}),"\n",(0,r.jsxs)(e.h4,{id:"首屏加载速度",children:["首屏加载速度",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#首屏加载速度",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"按需引入 ECharts\n懒加载图表组件\n预加载关键资源\n数据分片加载:先加载核心数据,在加载完整数据"}),"\n",(0,r.jsxs)(e.h4,{id:"3权限系统后端菜单怎么转前端路由-前端写死-和动态加载",children:["3.权限系统:后端菜单怎么转前端路由: 前端写死 和动态加载",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3权限系统后端菜单怎么转前端路由-前端写死-和动态加载",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"组件懒加载 ：使用 () => import() 语法实现组件懒加载\n动态路由 ：通过 router.addRoute 动态添加路由\n路径处理 ：确保前后端路径格式一致\n权限控制 ：在路由守卫中完成菜单获取和路由添加\n这种方案可以实现前后端权限的统一管理，后端只需要维护菜单结构，前端负责动态生成路由和菜单"}),"\n",(0,r.jsxs)(e.h4,{id:"4浏览器事件循环",children:["4.浏览器事件循环",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4浏览器事件循环",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"为什么需要事件循环,\n同步代码 > 微任务 > 渲染 > 宏任务"}),"\n",(0,r.jsxs)(e.h4,{id:"5回流跟重绘",children:["5.回流跟重绘",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5回流跟重绘",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"回流(Reflow) ：当元素的尺寸、位置或内容发生变化，导致浏览器需要重新计算元素几何属性并重新构建渲染树的过程。\n重绘(Repaint) ：当元素的外观样式改变（如颜色、背景色等），但不影响布局时，浏览器只需要重新绘制受影响区域的过程。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"回流代价更高 ：回流必定引起重绘，但重绘不一定引起回流"}),"\n",(0,r.jsx)(e.li,{children:"现代浏览器优化 ：浏览器会批量处理回流操作（队列机制）"}),"\n",(0,r.jsx)(e.li,{children:"CSS 属性影响 ：不同 CSS 属性触发的渲染阶段不同"}),"\n",(0,r.jsx)(e.li,{children:"最佳实践 ："}),"\n",(0,r.jsx)(e.li,{children:"避免频繁读取会触发回流的属性（如 offsetWidth）"}),"\n",(0,r.jsx)(e.li,{children:"使用 requestAnimationFrame 安排动画"}),"\n",(0,r.jsx)(e.li,{children:"对复杂动画使用 position: absolute/fixed 脱离文档流"}),"\n",(0,r.jsx)(e.li,{children:"使用 CSS3 硬件加速（transform/opacity 等）"}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"6一次性在页面上加载很多元素",children:["6.一次性在页面上加载很多元素",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#6一次性在页面上加载很多元素",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"虚拟滚动技术 (核心方案)\n分块加载 (时间切片)\n使用文档片段批量插入"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"优先使用虚拟滚动 ：适合列表/表格等线性布局"}),"\n",(0,r.jsx)(e.li,{children:"复杂布局使用分块加载 ：配合 requestIdleCallback"}),"\n",(0,r.jsx)(e.li,{children:"减少 DOM 复杂度 ：简化节点结构和样式"}),"\n",(0,r.jsx)(e.li,{children:"避免同步布局抖动 ：不要在循环中读取布局属性"}),"\n",(0,r.jsx)(e.li,{children:"使用 CSS containment ：限制重绘范围"}),"\n",(0,r.jsx)(e.li,{children:"大数据处理在 Worker 中完成 ：保持主线程流畅\n这些方法可以单独或组合使用，根据具体场景选择最适合的方案。虚拟滚动是处理超长列表最有效的解决方案。"}),"\n"]}),"\n",(0,r.jsxs)(e.h4,{id:"7js-判断是一个对象是空对象",children:["7.JS 判断是一个对象是空对象",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#7js-判断是一个对象是空对象",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-JavaScript",children:"functionisEmptyObject(obj) {\n  // 处理null和undefined\n  if(obj==null)returnfalse;\n  // 处理非对象类型\n  if(typeof obj!=='object')returnfalse;\n  // 处理数组\n  if(Array.isArray(obj))returnobj.length===0;\n  // 处理普通对象\n  returnObject.keys(obj).length===0;\n}\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"8一个数组需要依次用里面的-id-去调用接口获得用户信息返回一个用户信息数组编写代码",children:["8.一个数组,需要依次用里面的 id 去调用接口获得用户信息,返回一个用户信息数组,编写代码",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#8一个数组需要依次用里面的-id-去调用接口获得用户信息返回一个用户信息数组编写代码",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-JavaScript",children:"async function fetchUsersByIds(userIds) {\n  const userInfos = [];\n  for (const id of userIds) {\n    try {\n      const response = await fetch(`/api/users/${id}`);\n      const userData = await response.json();\n      userInfos.push(userData);\n    } catch (error) {\n      console.error(`获取用户 ${id} 信息失败:`, error);\n      userInfos.push(null); // 失败时放入null保持数组顺序\n    }\n  }\n  return userInfos;\n}\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-JavaScript",children:"async function fetchUsersByIds(userIds, maxConcurrent = 3) {\n  const userInfos = Array(userIds.length).fill(null);\n  let index = 0;\n  async function fetchBatch() {\n    while (index < userIds.length) {\n      const currentIndex = index++;\n      const id = userIds[currentIndex];\n      try {\n        const response = await fetch(`/api/users/${id}`);\n        const userData = await response.json();\n        userInfos[currentIndex] = userData;\n      } catch (error) {\n        console.error(`获取用户 ${id} 信息失败:`, error);\n      }\n    }\n  }\n  // 创建并发请求\n  const promises = Array(Math.min(maxConcurrent, userIds.length))\n    .fill()\n    .map(fetchBatch);\n\n  await Promise.all(promises);\n  return userInfos;\n}\n"})}),"\n",(0,r.jsxs)(e.h4,{id:"9foreach-跳出循环",children:["9.forEach 跳出循环",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#9foreach-跳出循环",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"使用 for...of 代替\n使用异常跳出"}),"\n",(0,r.jsxs)(e.h4,{id:"10精度问题",children:["10.精度问题",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#10精度问题",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"toFixed(2) 四舍五入不准确\n第三方数据库\nBigInt\n原理"}),"\n",(0,r.jsxs)(e.h4,{id:"11diff-算法",children:["11.diff 算法",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11diff-算法",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"vue2/vue3"}),"\n",(0,r.jsx)(e.p,{children:"12.uniapp 跟原生小程序的区别"}),"\n",(0,r.jsxs)(e.h3,{id:"416-面试复盘",children:["4.16 面试复盘",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#416-面试复盘",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"1.bigInt 2.倒计时 setInterval 准确么 不准确用什么实现\n3.websocket 跟 http keep-alive 有什么区别"})]})}function l(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}let c=l;l.__RSPRESS_PAGE_META={},l.__RSPRESS_PAGE_META["notes%2Finterview%2Freview.md"]={toc:[{text:"项目中遇到的最大挑战是什么,后来如何解决的",id:"项目中遇到的最大挑战是什么后来如何解决的",depth:3},{text:"token 放在 cookie 还是 localStorage",id:"token-放在-cookie-还是-localstorage",depth:3},{text:"浏览器从输入 URL 到页面展示的整个过程",id:"浏览器从输入-url-到页面展示的整个过程",depth:3},{text:"3.7 某医科技面试",id:"37-某医科技面试",depth:3},{text:"promise 状态吸收",id:"promise-状态吸收",depth:3},{text:"3.31 面试复盘",id:"331-面试复盘",depth:3},{text:"Echarts 性能调优,举例说明",id:"echarts-性能调优举例说明",depth:4},{text:"首屏加载速度",id:"首屏加载速度",depth:4},{text:"3.权限系统:后端菜单怎么转前端路由: 前端写死 和动态加载",id:"3权限系统后端菜单怎么转前端路由-前端写死-和动态加载",depth:4},{text:"4.浏览器事件循环",id:"4浏览器事件循环",depth:4},{text:"5.回流跟重绘",id:"5回流跟重绘",depth:4},{text:"6.一次性在页面上加载很多元素",id:"6一次性在页面上加载很多元素",depth:4},{text:"7.JS 判断是一个对象是空对象",id:"7js-判断是一个对象是空对象",depth:4},{text:"8.一个数组,需要依次用里面的 id 去调用接口获得用户信息,返回一个用户信息数组,编写代码",id:"8一个数组需要依次用里面的-id-去调用接口获得用户信息返回一个用户信息数组编写代码",depth:4},{text:"9.forEach 跳出循环",id:"9foreach-跳出循环",depth:4},{text:"10.精度问题",id:"10精度问题",depth:4},{text:"11.diff 算法",id:"11diff-算法",depth:4},{text:"4.16 面试复盘",id:"416-面试复盘",depth:3}],title:"面试问题复盘",headingTitle:"面试问题复盘",frontmatter:{}}}}]);