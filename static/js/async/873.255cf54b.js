"use strict";(self.webpackChunkjeff_blog=self.webpackChunkjeff_blog||[]).push([["873"],{9285:function(e,n,s){s.r(n),s.d(n,{default:()=>h});var i=s(5893),c=s(65);function l(e){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",ul:"ul",li:"li",blockquote:"blockquote"},(0,c.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"发布订阅模式",children:["发布订阅模式",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布订阅模式",children:"#"})]}),"\n",(0,i.jsxs)(n.h2,{id:"简介",children:["简介",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#简介",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"发布-订阅模式（Pub-Sub）是一种设计模式，用于在对象之间实现松耦合的通信。它允许一个对象（发布者）向多个对象（订阅者）发送消息，而发布者和订阅者之间不需要直接知道对方的存在。订阅者可以订阅感兴趣的事件，发布者可以在事件发生时通知所有订阅者。"}),"\n",(0,i.jsxs)(n.h2,{id:"适用场景",children:["适用场景",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#适用场景",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"这种模式在前端开发中非常常见，比如："}),"\n",(0,i.jsx)(n.p,{children:"事件驱动编程：DOM 事件（如 click、input）就是典型的发布-订阅模式。"}),"\n",(0,i.jsx)(n.p,{children:"状态管理：在 Vue 或 React 中，全局状态管理工具（如 Vuex、Redux）的核心思想就是基于发布-订阅模式。"}),"\n",(0,i.jsx)(n.p,{children:"组件通信：父子组件、兄弟组件之间的通信可以通过自定义事件（如 Vue 的 $emit 和 $on）实现。"}),"\n",(0,i.jsx)(n.p,{children:"异步任务管理：比如消息队列、WebSocket 消息推送等。"}),"\n",(0,i.jsxs)(n.h2,{id:"手写代码实现",children:["手写代码实现",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#手写代码实现",children:"#"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"class PubSub {\n  constructor() {\n    this.events = {}; // 用于存储事件和对应的回调函数\n  }\n\n  // 订阅事件\n  subscribe(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = []; // 如果事件不存在，初始化一个空数组\n    }\n    this.events[event].push(callback); // 将回调函数添加到事件列表中\n  }\n\n  // 发布事件\n  publish(event, ...args) {\n    if (this.events[event]) {\n      this.events[event].forEach((callback) => {\n        callback(...args); // 执行所有订阅该事件的回调函数\n      });\n    }\n  }\n\n  // 取消订阅\n  unsubscribe(event, callback) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event].filter((cb) => cb !== callback); // 过滤掉指定的回调函数\n    }\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"events 对象：用于存储事件名称和对应的回调函数列表。"}),"\n",(0,i.jsx)(n.li,{children:"subscribe 方法：允许订阅者订阅某个事件，并将回调函数添加到事件列表中。"}),"\n",(0,i.jsx)(n.li,{children:"publish 方法：当事件被触发时，遍历并执行所有订阅该事件的回调函数。"}),"\n",(0,i.jsx)(n.li,{children:"unsubscribe 方法：允许订阅者取消订阅，移除指定的回调函数。"}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"举例说明",children:["举例说明",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#举例说明",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"可以用它来实现一个简单的消息通知系统"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const pubsub = new PubSub();\n\n// 订阅事件\nconst logMessage = (message) => {\n  console.log('Received message:', message);\n};\npubsub.subscribe('message', logMessage);\n\n// 发布事件\npubsub.publish('message', 'Hello, World!'); // 输出: Received message: Hello, World!\n\n// 取消订阅\npubsub.unsubscribe('message', logMessage);\npubsub.publish('message', 'This will not be logged'); // 无输出\n"})}),"\n",(0,i.jsxs)(n.h2,{id:"扩展点",children:["扩展点",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展点",children:"#"})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["性能优化：如果事件列表很大，如何优化回调函数的执行效率？","\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"可以通过限制回调函数的数量、使用异步执行（如 setTimeout 或 Promise）来避免阻塞主线程。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["一次性订阅：如何实现只触发一次的事件订阅？","\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"可以在 subscribe 方法中添加一个标志位，执行一次后自动取消订阅。"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["错误处理：如何处理回调函数中的错误？","\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:"可以在 publish 方法中添加 try-catch，确保一个回调函数的错误不会影响其他回调函数的执行。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.h2,{id:"总结",children:["总结",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"发布-订阅模式的优点是实现了对象之间的解耦，让代码更易于维护和扩展，特别适合处理复杂的异步通信场景。"})]})}function r(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,c.ah)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}let h=r;r.__RSPRESS_PAGE_META={},r.__RSPRESS_PAGE_META["notes%2Fdesign-pattern%2FpubSub.md"]={toc:[{text:"简介",id:"简介",depth:2},{text:"适用场景",id:"适用场景",depth:2},{text:"手写代码实现",id:"手写代码实现",depth:2},{text:"举例说明",id:"举例说明",depth:2},{text:"扩展点",id:"扩展点",depth:2},{text:"总结",id:"总结",depth:2}],title:"发布订阅模式",headingTitle:"发布订阅模式",frontmatter:{}}}}]);