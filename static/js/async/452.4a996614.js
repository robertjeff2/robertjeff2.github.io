"use strict";(self.webpackChunkjeff_blog=self.webpackChunkjeff_blog||[]).push([["452"],{2273:function(n,e,s){s.r(e),s.d(e,{default:()=>c});var r=s(5893),i=s(65);function l(n){let e=Object.assign({h1:"h1",a:"a",blockquote:"blockquote",p:"p",h2:"h2",ol:"ol",li:"li",h3:"h3",strong:"strong",code:"code",ul:"ul",pre:"pre",hr:"hr",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"手写防抖节流",children:["手写防抖节流",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#手写防抖节流",children:"#"})]}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"首先，防抖和节流都是用来优化高频触发的事件，比如滚动、输入或者窗口调整，防止这些事件处理函数被频繁调用，影响性能。不过它们的实现方式和应用场景不同，我得先搞清楚两者的区别。防抖（Debounce）的话，我记得是当事件被触发后，一定时间内的多次触发只会执行最后一次，或者只在开始时执行一次。比如搜索框输入，用户停止输入一段时间后才发送请求，避免每次按键都请求。而节流（Throttle）则是每隔一定时间执行一次，不管事件触发有多频繁，比如滚动事件，每隔 200ms 执行一次处理函数。"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"回答步骤",children:["回答步骤",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#回答步骤",children:"#"})]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"解释防抖和节流的定义和区别。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"写出基本的实现代码，并解释每一步的作用。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"比较不同实现方式的差异。"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"举例说明应用场景。"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.h3,{id:"1-防抖debounce",children:[(0,r.jsx)(e.strong,{children:"1. 防抖（Debounce）"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-防抖debounce",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"定义"}),"：高频事件触发后，在指定时间内只执行最后一次。若在等待期内再次触发，则重新计时。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"应用场景"}),"：搜索框输入联想、窗口大小调整（",(0,r.jsx)(e.code,{children:"resize"}),"）。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"实现思路"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"利用定时器，每次触发时重置定时。"}),"\n",(0,r.jsx)(e.li,{children:"支持立即执行（首次触发立即执行，后续需等待停止触发）。"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"代码示例"}),"："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function debounce(func, wait, immediate = false) {\n  let timeout;\n  return function (...args) {\n    const context = this;\n    const later = () => {\n      timeout = null;\n      if (!immediate) func.apply(context, args);\n    };\n    const callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) func.apply(context, args);\n  };\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"关键点"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["使用闭包保存 ",(0,r.jsx)(e.code,{children:"timeout"}),"。"]}),"\n",(0,r.jsx)(e.li,{children:"立即执行逻辑：首次触发且未在等待期内时执行。"}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"clearTimeout"})," 确保每次触发重置计时。"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.h3,{id:"2-节流throttle",children:[(0,r.jsx)(e.strong,{children:"2. 节流（Throttle）"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-节流throttle",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"定义"}),"：高频事件触发时，每隔指定时间执行一次，稀释执行频率。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"应用场景"}),"：滚动加载（",(0,r.jsx)(e.code,{children:"scroll"}),"）、高频点击（如抢购按钮）。"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"实现思路"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"时间戳版"}),"：记录上次执行时间，若间隔超过阈值则执行。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"定时器版"}),"：延迟执行，执行后重置定时器。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"结合版"}),"（推荐）：首次立即执行，最后一次触发延迟执行。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"代码示例（结合版）"}),"："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"function throttle(func, wait) {\n  let timeout = null;\n  let previous = 0;\n\n  return function (...args) {\n    const context = this;\n    const now = Date.now();\n    const remaining = wait - (now - previous);\n\n    if (remaining <= 0) {\n      // 超过间隔时间，立即执行\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      func.apply(context, args);\n    } else if (!timeout) {\n      // 未超过间隔时间，设置定时器延迟执行\n      timeout = setTimeout(() => {\n        previous = Date.now();\n        timeout = null;\n        func.apply(context, args);\n      }, remaining);\n    }\n  };\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"关键点"}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"remaining"})," 计算剩余等待时间。"]}),"\n",(0,r.jsx)(e.li,{children:"首次触发立即执行，最后一次触发在剩余时间后执行。"}),"\n",(0,r.jsx)(e.li,{children:"定时器与时间戳结合，确保首尾触发均被执行。"}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.h3,{id:"3-对比与总结",children:[(0,r.jsx)(e.strong,{children:"3. 对比与总结"}),(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-对比与总结",children:"#"})]}),"\n",(0,r.jsxs)(e.table,{children:["\n",(0,r.jsxs)(e.thead,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.th,{children:"特性"}),"\n",(0,r.jsx)(e.th,{children:"防抖（Debounce）"}),"\n",(0,r.jsx)(e.th,{children:"节流（Throttle）"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(e.tbody,{children:["\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"执行时机"})}),"\n",(0,r.jsx)(e.td,{children:"最后一次触发后等待结束执行"}),"\n",(0,r.jsx)(e.td,{children:"固定间隔执行"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"应用场景"})}),"\n",(0,r.jsxs)(e.td,{children:["搜索联想、",(0,r.jsx)(e.code,{children:"resize"})]}),"\n",(0,r.jsx)(e.td,{children:"滚动事件、高频点击"}),"\n"]}),"\n",(0,r.jsxs)(e.tr,{children:["\n",(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"核心逻辑"})}),"\n",(0,r.jsx)(e.td,{children:"重置定时器"}),"\n",(0,r.jsx)(e.td,{children:"时间间隔控制"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.hr,{}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"回答技巧"}),"："]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"先解释概念"}),"：明确防抖和节流的定义及区别。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"手写代码"}),"：逐步写出代码并解释关键步骤（如闭包、定时器、",(0,r.jsx)(e.code,{children:"this"})," 绑定）。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"举例场景"}),"：结合具体场景说明为何选择防抖或节流。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"扩展优化"}),"：提及取消功能（如 ",(0,r.jsx)(e.code,{children:"debounced.cancel()"}),"）或参数配置（如 ",(0,r.jsx)(e.code,{children:"leading"})," 和 ",(0,r.jsx)(e.code,{children:"trailing"}),"）。"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"通过清晰的结构和代码示例，展示对性能优化问题的深入理解。"})]})}function t(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(l,{...n})}):l(n)}let c=t;t.__RSPRESS_PAGE_META={},t.__RSPRESS_PAGE_META["notes%2Fhandwriting%2Fthrottle.md"]={toc:[{text:"回答步骤",id:"回答步骤",depth:2},{text:"**1. 防抖（Debounce）**",id:"1-防抖debounce",depth:3},{text:"**2. 节流（Throttle）**",id:"2-节流throttle",depth:3},{text:"**3. 对比与总结**",id:"3-对比与总结",depth:3}],title:"手写防抖节流",headingTitle:"手写防抖节流",frontmatter:{}}}}]);