"use strict";(self.webpackChunkjeff_blog=self.webpackChunkjeff_blog||[]).push([["122"],{5619:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var d=r(5893),h=r(65);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",h2:"h2",h3:"h3",br:"br",pre:"pre",code:"code",strong:"strong"},(0,h.ah)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(n.h1,{id:"typescript",children:["TypeScript",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#typescript",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"@types 是一个第三方库 包含对 js 代码的类型描述"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"类型描述 是对 js 代码的描述 描述的是 js 代码的结构和类型\n@types/node"}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"基本类型约束",children:["基本类型约束",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本类型约束",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"变量,函数的参数,函数的返回值限制类型\n在变量后边加类型描述\nts 在很多场景可以完成类型推导\nany 任意类型 推导不出来的 有三个点 用 any"}),"\n",(0,d.jsxs)(n.h3,{id:"源代码和编译结果的差异",children:["源代码和编译结果的差异",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#源代码和编译结果的差异",children:"#"})]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"类型约束 不会出现在编译结果中\nTS 类型检查 是静态的"}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"基本类型",children:["基本类型",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#基本类型",children:"#"})]}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"number"}),"\n",(0,d.jsx)(n.li,{children:"string"}),"\n",(0,d.jsx)(n.li,{children:"数组 要指出每一项是什么类型 number[] string[] object[] Array"}),"\n",(0,d.jsx)(n.li,{children:"object 对象约束(用的比较少)\n特殊类型 null undefined 严格模式下 不能赋值给 null 和 undefined"}),"\n"]}),"\n",(0,d.jsxs)(n.h2,{id:"其他常用类型",children:["其他常用类型",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#其他常用类型",children:"#"})]}),"\n",(0,d.jsxs)(n.p,{children:['联合类型|连接符\ntypeof 可以触发简单类型保护\nvoid 类型 没有返回值的函数\nnever 类型 永远不会结束函数\n字面量类型 "A" 1 2 以后只能赋值给某个字面量',(0,d.jsx)(n.br,{}),"\n","可以约束类型\n元祖类型 固定长度的数组 约束每一项的类型\nany 类型 绕过类型检查 可以赋值给任何类型"]}),"\n",(0,d.jsxs)(n.h2,{id:"类型别名",children:["类型别名",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型别名",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"对已知的类型进行描述"}),"\n",(0,d.jsxs)(n.h2,{id:"函数相关约束",children:["函数相关约束",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#函数相关约束",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"函数重载:在函数实现之前,对函数调用的多种情况进行声明\n可选参数?,不能放在首位"}),"\n",(0,d.jsxs)(n.h2,{id:"扩展类型-枚举",children:["扩展类型-枚举",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#扩展类型-枚举",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"扩展类型:类型别名/枚举/接口/类"}),"\n",(0,d.jsx)(n.p,{children:"枚举: 约束某个变量的取值范围\n枚举的类型: 数字枚举 字符串枚举\n字面量和联合类型配合使用,可以达到同样的目标"}),"\n",(0,d.jsx)(n.p,{children:"字面量类型存在问题"}),"\n",(0,d.jsxs)(n.ul,{children:["\n",(0,d.jsx)(n.li,{children:"不会进入到编译结果"}),"\n",(0,d.jsx)(n.li,{children:"值混淆的话修改所需要的成本太高"}),"\n"]}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"enum 枚举名 {\n  枚举字段1: 值1,\n  枚举字段2:值2\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"枚举会出现在编译结果中,表现为对象\n枚举为字符串或者数字,数字的值会自增\n数字枚举和字符串枚举有差异\n最佳实践:\n不要同时出现字符串和数字\n使用时尽量使用枚举字段的名称不要使用真实值"}),"\n",(0,d.jsx)(n.p,{children:"位运算& | ~ ^ << >>\n或| 可以用来判断是否拥有某个权限\n且& 可以用来判断是否拥有某个权限\n异或^ 可以用来删除权限 (相同取 0 不同取 1)"}),"\n",(0,d.jsxs)(n.h2,{id:"模块化-ts",children:["模块化 TS",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#模块化-ts",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"配置模块化导出导入模块\n使用的是 es6 的模块化标准"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:'export const\nimport {} from ""\nexport default 导出默认值\n'})}),"\n",(0,d.jsxs)(n.h2,{id:"接口",children:["接口",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#接口",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"扩展类型: 类型别名 枚举 接口 类\n概念:用于约束类 对象 函数的契约(标准)"}),"\n",(0,d.jsx)(n.p,{children:"不会出现在编译结果中 和类型别名一样\n接口可以继承 让一个接口继承另一个接口所有成员 实现多种接口组合\n在继承中不能去覆盖父接口成员的类型"}),"\n",(0,d.jsx)(n.pre,{children:(0,d.jsx)(n.code,{children:"class 类名 implements 接口名 {\n}\n"})}),"\n",(0,d.jsx)(n.p,{children:"类型别名实现:& 交叉类型符,可以覆盖父接口成员的类型 使用少"}),"\n",(0,d.jsxs)(n.p,{children:[(0,d.jsx)(n.strong,{children:"readonly 只读属性"}),"\n在接口中成员之前加 readonly 可以将成员变为只读属性\n在编译后会被删除 readonly arr: readonly number[] 数组不能改变"]}),"\n",(0,d.jsxs)(n.h2,{id:"类型兼容性",children:["类型兼容性",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类型兼容性",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"B->A 如果能完成赋值则 B 和 A 是兼容的\n鸭子辩型法 (子结构辩型法):目标类型需要某一些特征,赋值的类型只需要满足该特征即可"}),"\n",(0,d.jsx)(n.p,{children:"基本类型完全匹配"}),"\n",(0,d.jsx)(n.p,{children:"类型断言: as 关键词\n直接使用字面量赋值,判定更严格"}),"\n",(0,d.jsxs)(n.h2,{id:"类",children:["类",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#类",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"面向对象思想\n类 属性赋值\n在构造函数中\n在类中赋值\n?:可选属性\n属性可以修饰为可选 / 只读\n构造器中写上访问修饰符 可以正常赋值构造属性简写\n访问修饰符 public/private/readonly"}),"\n",(0,d.jsxs)(n.h3,{id:"访问器",children:["访问器",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#访问器",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"set get 用来控制属性的读取"}),"\n",(0,d.jsxs)(n.h2,{id:"泛型",children:["泛型",(0,d.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#泛型",children:"#"})]}),"\n",(0,d.jsx)(n.p,{children:"在书写某个函数中会丢失一些类型信息\n泛型:附属于函数类接口类型别名之上的类型 泛型可以设置默认值"}),"\n",(0,d.jsxs)(n.p,{children:["使用: 在函数名之后写上",(0,d.jsx)(n.code,{children:"<泛型名称>"}),"通常写","\n在定义的时候不确定类型,在调用的时候传类型"]}),"\n",(0,d.jsxs)(n.p,{children:["泛型约束\n在",(0,d.jsx)(n.code,{children:"<T extands xx>"})," 表示一个泛型继承了某个接口 某个类 用来限制泛型的取值\n多泛型\n<T,U> 返回(T | U)的结果类型 可以是 T 也可以是 U"]})]})}function s(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,h.ah)(),e.components);return n?(0,d.jsx)(n,{...e,children:(0,d.jsx)(i,{...e})}):i(e)}let c=s;s.__RSPRESS_PAGE_META={},s.__RSPRESS_PAGE_META["notes%2Freact%2Ftypescript.md"]={toc:[{text:"基本类型约束",id:"基本类型约束",depth:2},{text:"源代码和编译结果的差异",id:"源代码和编译结果的差异",depth:3},{text:"基本类型",id:"基本类型",depth:2},{text:"其他常用类型",id:"其他常用类型",depth:2},{text:"类型别名",id:"类型别名",depth:2},{text:"函数相关约束",id:"函数相关约束",depth:2},{text:"扩展类型-枚举",id:"扩展类型-枚举",depth:2},{text:"模块化 TS",id:"模块化-ts",depth:2},{text:"接口",id:"接口",depth:2},{text:"类型兼容性",id:"类型兼容性",depth:2},{text:"类",id:"类",depth:2},{text:"访问器",id:"访问器",depth:3},{text:"泛型",id:"泛型",depth:2}],title:"TypeScript",headingTitle:"TypeScript",frontmatter:{}}}}]);