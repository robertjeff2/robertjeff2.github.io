"use strict";(self.webpackChunkjeff_blog=self.webpackChunkjeff_blog||[]).push([["481"],{8273:function(n,e,i){i.r(e),i.d(e,{default:()=>d});var s=i(5893),l=i(65);function r(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",ul:"ul",li:"li",ol:"ol",pre:"pre",code:"code",h4:"h4"},(0,l.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"简历涉及知识点准备",children:["简历涉及知识点准备",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#简历涉及知识点准备",children:"#"})]}),"\n",(0,s.jsxs)(e.h2,{id:"1-性能优化的前因后果说清楚",children:["1. 性能优化的前因后果说清楚",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#1-性能优化的前因后果说清楚",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"我使用 F12 开发者工具进入 LightHouse 工具分析了网站性能指标,指标包含了性能指标（Performance）、可访问性（Accessibility）、最佳实践（Best Practices）和 SEO（Search Engine Optimization）。\nFCP 时间比较场,所以这次的目的就是优化 FCP 时间。\nFCP 时间是指浏览器从开始加载页面到页面内容首次开始绘制的时间。\nFCP 时间越短，用户体验越好。\nFCP 时间过长，会导致用户等待时间过长，影响用户体验。\n使用的方式:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"使用图片懒加载：通过使用 JavaScript 或者在 HTML 属性中设置 onload 事件，当图片加载完成时再显示，这样可以减少初始化时的性能开销"}),"\n",(0,s.jsx)(e.li,{children:"使用预加载：通过在页面加载时预先加载一些数据和资源，当用户访问时可以更快地渲染。"}),"\n",(0,s.jsx)(e.li,{children:"优化列表和数组操作：使用现代前端框架提供的列表和数组操作方法，可以减少代码量，提高性能。"}),"\n",(0,s.jsx)(e.li,{children:"使用 CDN：通过将静态资源部署到 CDN 服务器上，可以提高用户体验，减少网络传输时的时间开销。"}),"\n",(0,s.jsx)(e.li,{children:"使用事件代理：将事件监听器添加到父元素上，可以减少事件监听器的数量，提高性能。"}),"\n",(0,s.jsx)(e.li,{children:"优化 DOM 操作：在使用 JavaScript 操作 DOM 时，尽量减少操作的次数和复杂度，以提高性能。"}),"\n",(0,s.jsx)(e.li,{children:"图片压缩：通过压缩图片的大小，可以减少网络传输时的时间开销。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"细说图片懒加载:\n图片懒加载是一种优化技术，它的目的是在用户滚动页面时，只有当图片进入可视区域时才加载图片，从而减少页面加载时间和带宽消耗。\n图片懒加载的实现方式有很多种，其中比较常用的是使用 JavaScript 和 onload 事件。\n具体实现步骤如下："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"在 HTML 中，将图片的 src 属性设置为一个占位图，例如："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",children:'<img src="loading.gif" data-src="real-image.jpg" alt="Real Image" />\n'})}),"\n",(0,s.jsxs)(e.ol,{start:"2",children:["\n",(0,s.jsx)(e.li,{children:"在 JavaScript 中，使用 onload 事件监听图片加载完成的事件，当图片加载完成时，将占位图的 src 属性替换为真实的图片地址，例如："}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"var images = document.querySelectorAll('img');\nfor (var i = 0; i < images.length; i++) {\n  images[i].onload = function () {\n    this.src = this.dataset.src;\n  };\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"2-怎么去封装一个组件",children:["2. 怎么去封装一个组件",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#2-怎么去封装一个组件",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"首先先分析组件的功能和特点，确定组件的结构和样式。\n然后根据组件的功能和特点，编写组件的代码。\n最后将组件的代码封装成一个独立的模块，方便在其他项目中使用。\n单一职责原则：每个组件只做一件事，便于维护和复用。\n可扩展性：组件可以根据需要进行扩展和修改，便于维护和升级。\n通过 props 传递数据和配置，通过事件（如 onChange 、 onSubmit ）向父组件传递变化。\n支持插槽/slot（Vue）或 children（React）\n通过 v-model（Vue）或 value/onChange（React）实现双向绑定。"}),"\n",(0,s.jsxs)(e.h2,{id:"3-在团队怎么去践行前端工程化",children:["3. 在团队怎么去践行前端工程化",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#3-在团队怎么去践行前端工程化",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"1.开发流程统一,构建统一的代码规范代码风格\n制定并推行代码规范（如 ESLint、Prettier），统一团队编码风格。\n采用 Git Flow、分支管理策略，规范代码提交（如 Commitlint、Husky 钩子）。"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"推行代码评审（Code Review）制度，提升代码质量和团队协作。 2.模块化与组件化开发\n推行组件化思想，封装高复用的 UI 组件和业务组件，沉淀组件库。 3.技术文档输出与知识沉淀\n编写详细的技术文档、接口文档、开发手册，降低团队成员沟通成本。 4.团队协作与持续改进\n定期技术分享、Code Review、技术沙龙，提升团队整体技术水平。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"4-git-rebase-和-git-merge-的区别",children:["4. git rebase 和 git merge 的区别",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#4-git-rebase-和-git-merge-的区别",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"git 工作流的搭建:"}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"首先创建一个新的分支，用于开发新的功能或修复 bug。"}),"\n",(0,s.jsx)(e.li,{children:"在新分支上进行开发和测试。"}),"\n",(0,s.jsx)(e.li,{children:"当开发完成后，将新分支合并到主分支（通常是 master 分支）。"}),"\n",(0,s.jsx)(e.li,{children:"合并过程中，需要进行代码审查和测试，确保代码质量和稳定性。"}),"\n",(0,s.jsx)(e.li,{children:"合并完成后，将新分支删除，保持主分支的整洁和清晰。"}),"\n",(0,s.jsx)(e.li,{children:"定期进行代码合并和部署，确保主分支的稳定性和可靠性。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"git rebase 和 git merge 的区别:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"git merge ：将两个分支的最新内容合并，保留两条分支的历史，产生一个新的合并提交（merge commit），历史记录呈现分叉和合并的树状结构。"}),"\n",(0,s.jsx)(e.li,{children:"git rebase ：将当前分支的提交“迁移”到目标分支的最新提交之后，重写提交历史，使历史记录更加线性。\n差异:"}),"\n",(0,s.jsx)(e.li,{children:"merge 会保留分支的分叉和合并点，历史更真实，但可能更复杂。"}),"\n",(0,s.jsx)(e.li,{children:"rebase 会让提交历史变得线性，便于查看和回溯，但会改变提交的哈希值。\n场景:"}),"\n",(0,s.jsx)(e.li,{children:"merge 适合保留完整的分支开发历史，适合团队协作。"}),"\n",(0,s.jsx)(e.li,{children:"rebase 适合整理提交历史，保持主干分支整洁，适合个人开发或合并前整理。\n冲突"}),"\n",(0,s.jsx)(e.li,{children:"merge 过程中如有冲突，只需解决一次。"}),"\n",(0,s.jsx)(e.li,{children:"rebase 过程中每次“迁移”一个提交都可能产生冲突，需要多次解决。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"5-在前端层面怎么保障整个系统的稳定性",children:["5. 在前端层面怎么保障整个系统的稳定性",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#5-在前端层面怎么保障整个系统的稳定性",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"1.代码规范与审核\n○ code review\n○ 编写代码层面的规范 2.错误处理与容错\n○ 让错误可控，组件内的错误不至于导致整个页面发生崩溃"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"组件内部做好异常捕获，防止单个组件错误导致页面整体崩溃。"}),"\n",(0,s.jsx)(e.li,{children:"全局异常捕获（如 window.onerror、Vue.config.errorHandler、React ErrorBoundary），及时上报和处理异常。"}),"\n",(0,s.jsx)(e.li,{children:"关键操作增加降级和兜底方案，保证核心功能可用。 3.性能优化"}),"\n",(0,s.jsx)(e.li,{children:"合理使用懒加载、预加载、CDN、事件代理等手段，提升整体性能。"}),"\n",(0,s.jsx)(e.li,{children:"监控线上性能指标，及时发现和优化性能瓶颈。\n代码复用与模块化\n○ 减少代码冗余，提高代码复用率，便于维护\n○ 需求开发前编写技术文档"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"6-权限控制方案",children:["6. 权限控制方案",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#6-权限控制方案",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"：基于角色 and 基于用户，优劣点分别是什么 1.基于角色"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"原理 ：为每个用户分配一个或多个角色，每个角色拥有不同的权限。前端根据用户角色决定页面展示内容、路由访问、按钮操作等。"}),"\n",(0,s.jsx)(e.li,{children:"优点 ：结构清晰，易于管理，适合权限体系较为稳定的系统。"}),"\n",(0,s.jsx)(e.li,{children:"登录后获取用户角色，前端根据角色动态生成路由和菜单。"}),"\n",(0,s.jsx)(e.li,{children:"组件/按钮通过指令或高阶组件判断当前用户角色是否有权限显示。 2.基于用户"}),"\n",(0,s.jsx)(e.li,{children:"原理 ：为每个用户单独分配权限，前端根据用户的具体权限控制页面元素的显示与操作。"}),"\n",(0,s.jsx)(e.li,{children:"优点 ：灵活，能满足个性化需求。"}),"\n",(0,s.jsx)(e.li,{children:"缺点 ：管理复杂，维护成本高，适合权限变化频繁或个性化需求强的场景。\n实现方式举例 ："}),"\n",(0,s.jsx)(e.li,{children:"登录后获取用户权限列表，前端根据权限列表渲染页面和功能。"}),"\n",(0,s.jsx)(e.li,{children:'通过权限码（如"CAN_EDIT_USER"）控制按钮、菜单、路由等的显示。'}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"常用技术实现"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"路由守卫（如 Vue Router、React Router 的 beforeEach/beforeEnter）"}),"\n",(0,s.jsx)(e.li,{children:"权限指令/高阶组件（如 v-permission、withPermission）"}),"\n",(0,s.jsx)(e.li,{children:"动态菜单/按钮渲染"}),"\n",(0,s.jsx)(e.li,{children:"权限码/权限点管理"}),"\n"]}),"\n",(0,s.jsxs)(e.ol,{start:"7",children:["\n",(0,s.jsx)(e.li,{children:"RSA 和浏览器指纹风控分别是什么\nRSA 是一种非对称加密算法（Rivest–Shamir–Adleman），在前端主要用于数据加密和安全传输。其核心思想是使用一对公钥和私钥：公钥用于加密数据，私钥用于解密数据。常见应用场景包括："}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"前端登录时对敏感信息（如密码）进行加密，防止明文传输被窃取。"}),"\n",(0,s.jsx)(e.li,{children:"与后端进行安全通信，防止中间人攻击和数据篡改。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"fingerprintjs"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"浏览器类型和版本"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"操作系统类型和版本"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"屏幕分辨率、颜色深度"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"安装的字体、插件、语言设置\n用途："}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"主要用于风控、反作弊、用户唯一性识别等场景。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"可以辅助判断同一用户是否多次访问、是否存在异常行为等。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.ol,{start:"8",children:["\n",(0,s.jsx)(e.li,{children:"keep-alive 的原理是什么\n用于缓存被包裹的动态组件，避免重复渲染和销毁，提高性能和用户体验。\nkeep-alive 通过内部维护一个缓存对象（通常是基于 LRU 策略的 Map），以组件的唯一标识（如 name 或 key）为 key，组件的实例为 value。当组件被切换出去时，不会销毁，而是将其实例存入缓存。\n第一次渲染时正常挂载\n切换的时候会触发 deactivated 钩子函数\n再次切换回来的时候会触发 activated 钩子函数"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"在 Vue 的 patch 过程中，keep-alive 会拦截对被包裹组件的卸载操作，将其转为缓存操作，并在需要时复用缓存中的 VNode 实例。"}),"\n",(0,s.jsx)(e.li,{children:"include/exclude 控制 通过 include/exclude 属性，keep-alive 会根据组件的 name 或 key 判断是否需要缓存，动态决定哪些组件参与缓存。"}),"\n",(0,s.jsx)(e.li,{children:"缓存淘汰 当缓存数量超过 max 属性时，keep-alive 会按照 LRU（最近最少使用）策略淘汰最久未使用的组件实例，释放内存。"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"9-对于多数据节点模型会发生卡顿的问题有没有做什么优化",children:["9. 对于多数据节点，模型会发生卡顿的问题，有没有做什么优化",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#9-对于多数据节点模型会发生卡顿的问题有没有做什么优化",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"虚拟列表（Virtual List）/虚拟滚动（Virtual Scrolling） 只渲染可视区域内的数据节点，未显示的数据不渲染，极大减少 DOM 数量，提升渲染性能。常见库有 react-window、vue-virtual-scroller 等。\n检测元素进入可用区域\n使用 Intersection Observer API 监听元素进入和离开可视区域，只渲染进入的元素，避免大量 DOM 渲染。\n使用懒加载（Lazy Loading）\n对于图片、视频等资源，只在元素进入可视区域时加载，避免一次性加载大量资源。\n渲染节奏用 requestAnimationFrame"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"优化滚动时的渲染节奏，避免频繁操作 DOM，提升性能"}),"\n"]}),"\n",(0,s.jsxs)(e.ol,{start:"10",children:["\n",(0,s.jsx)(e.li,{children:"Websocket 的心跳机制\nWebSocket 的心跳机制是指客户端和服务端定期发送“心跳包”（通常是特殊格式的数据包，如 ping/pong 或自定义消息），以检测连接是否存活、防止中间网络设备断开长时间无数据传输的连接。\n在 onmessage 周期监听消息\nws 失败重连机制"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"监听 onclose 和 onerror ，在断开时自动重连"}),"\n",(0,s.jsx)(e.li,{children:"使用定时器控制重连频率，避免频繁重连"}),"\n",(0,s.jsx)(e.li,{children:"可设置最大重连次数或指数退避"}),"\n",(0,s.jsx)(e.li,{children:"重连后恢复心跳和消息监听"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"11-websocket-和-http-的区别",children:["11. Websocket 和 http 的区别",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#11-websocket-和-http-的区别",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"HTTP 通信是“请求-响应”模式，客户端主动发起请求，服务端响应。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"WebSocket 支持双向通信，服务端可以主动推送消息给客户端，实时性强。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"HTTP 每次通信都需要携带完整的请求和响应头，数据包体积较大。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"WebSocket 握手后，数据帧头部很小，通信开销低，适合高频率、实时性强的场景。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"HTTP 默认端口为 80（HTTPS 为 443）。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"WebSocket 默认端口为 80（ws）和 443（wss），但协议不同。\nHTTP 适合请求-响应式的传统数据交互，WebSocket 适合需要实时、双向通信的高交互场景。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"12-垃圾回收机制",children:["12. 垃圾回收机制",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#12-垃圾回收机制",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"a. 引用计数"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"原理 ：跟踪记录每个值被引用的次数"}),"\n",(0,s.jsx)(e.li,{children:"优点 ：发现垃圾时立即回收"}),"\n",(0,s.jsx)(e.li,{children:"缺点 ：无法解决循环引用问题\nb. 标记清除"}),"\n",(0,s.jsx)(e.li,{children:"原理 ：从根对象开始遍历所有引用，标记活动对象，未被标记的进行清除"}),"\n",(0,s.jsx)(e.li,{children:"步骤 ："}),"\n"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"标记阶段：从根对象开始遍历"}),"\n",(0,s.jsx)(e.li,{children:"清除阶段：清除未被标记的对象"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"c.分代回收（Generational Collection）"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["新生代 ：存活时间短的对象","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"使用 Scavenge 算法"}),"\n",(0,s.jsx)(e.li,{children:"空间分为 From 和 To 两部分"}),"\n",(0,s.jsx)(e.li,{children:"存活对象复制到 To 空间"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["老生代 ：存活时间长的对象","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"使用标记清除和标记整理"}),"\n",(0,s.jsx)(e.li,{children:"减少碎片化"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"优点 ：能解决循环引用问题"}),"\n",(0,s.jsx)(e.li,{children:"缺点 ：会产生内存碎片"}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"13内存泄露一般怎么排查",children:["13.内存泄露一般怎么排查",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#13内存泄露一般怎么排查",children:"#"})]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"意外的全局变量"}),"\n",(0,s.jsx)(e.li,{children:"未清理的定时器"}),"\n",(0,s.jsx)(e.li,{children:"闭包引用"}),"\n",(0,s.jsx)(e.li,{children:"DOM 引用未清理"}),"\n",(0,s.jsx)(e.li,{children:"事件监听器未移除\n从这几个方面去排查, F12 开发工具中可以看到内存快照"}),"\n"]}),"\n",(0,s.jsxs)(e.ol,{start:"14",children:["\n",(0,s.jsx)(e.li,{children:"一般怎么进行技术选型呢\n○ 社区活跃度\n○ 同类型的技术对比"}),"\n",(0,s.jsx)(e.li,{children:"实时获取怎么做的\nws 通信"}),"\n",(0,s.jsx)(e.li,{children:"状态管理库 Vuex 的原理 ,vue 和 pinia 的区别"}),"\n"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式"}),"\n",(0,s.jsx)(e.li,{children:"采用集中式存储管理应用的所有组件的状态"}),"\n",(0,s.jsx)(e.li,{children:"以相应的规则保证状态以一种可预测的方式发生变化\n数据流向清晰 ：组件通过 dispatch 分发 action，action 可以包含异步操作，action 再通过 commit 提交 mutation，mutation 是唯一能修改 state 的地方，并且必须是同步的。这样保证了状态变更的可追踪和可预测。\nGetter ：类似于 Vue 的计算属性，对 state 进行二次处理，结果会被缓存。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"区别"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vuex 采用传统的模块化、mutation、action、getter 设计，API 较为繁琐。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Pinia 更加轻量、现代，API 设计更贴近 Composition API，使用 setup 语法糖，书写更简洁。\n模块化 ："}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vuex 需要手动注册模块，模块嵌套复杂。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Pinia 每个 store 独立，天然模块化，按需引入，易于拆分和维护。\n数据修改方式"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Vuex 必须通过 mutation 修改 state，mutation 必须同步，action 负责异步。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"Pinia 可以直接在 action 或外部直接修改 state，无需 mutation，简化了数据流。\n总结 ：Pinia 更轻量、易用、类型友好，推荐在 Vue3 项目中优先使用；Vuex 适合老项目或对 mutation/action 传统模式有依赖的场景。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"17-vue-中组件进行通信方案",children:["17. Vue 中组件进行通信方案",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#17-vue-中组件进行通信方案",children:"#"})]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"props / $emit"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"vue2 自定义事件总线（EventBus）vue3 不推荐使用"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"provide / inject\n适合祖孙组件通信，适合深层嵌套场景。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"ref / $parent /$children\n通过 ref 获取子组件实例，或通过 $parent、$children 访问父/子组件实例。适合简单场景，不推荐频繁使用。"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"全局状态管理"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"attrs / listeners\n通过 $attrs 和 $listeners 实现属性和事件的透传，适合多层组件嵌套时的通信。"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"18-为什么-eventbus-在-vue3-中不推荐",children:["18 为什么 eventBus 在 vue3 中不推荐",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#18-为什么-eventbus-在-vue3-中不推荐",children:"#"})]}),"\n",(0,s.jsx)(e.p,{children:"响应式系统升级 ：Vue3 的响应式系统基于 Proxy 实现，事件总线这种通过全局实例传递事件的方式，容易绕开响应式数据流，导致状态不可追踪、不透明，违背了 Vue3 推崇的“明确的数据流向”\n类型安全与可维护性差 ：EventBus 事件名和参数没有类型约束，容易出现拼写错误、参数不一致等问题，难以维护和重构，尤其是在大型项目中。\n更好的替代方案 ：Vue3 推荐使用 provide/inject、props/$emit、全局状态管理（如 Pinia）等更清晰、类型友好、易于维护的通信方式。这些方式更符合 Vue3 的设计理念和现代前端开发需求。"}),"\n",(0,s.jsxs)(e.h2,{id:"18-hash-路由和-history-的区别",children:["18. hash 路由和 history 的区别",(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#18-hash-路由和-history-的区别",children:"#"})]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"路由映射表（Route Mapping） vue-router 会根据开发者配置的 routes 数组，生成一份“路径与组件”的映射表。每当 URL 发生变化时，vue-router 会根据当前路径查找对应的组件进行渲染。\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"hash 模式 ：通过监听 window 的 hashchange 事件，URL 的 # 后面的内容变化时，vue-router 会解析 hash 并匹配路由。"}),"\n",(0,s.jsxs)(e.li,{children:["history 模式 ：利用 HTML5 History API（pushState/replaceState/popstate），监听浏览器的前进、后退等操作，URL 变化时同样进行路由匹配。\nvue-router 会在\n组件处动态渲染当前匹配到的路由组件。每当路由变化时，\n会自动切换显示对应的组件。\nvue-router 提供了全局、路由独享、组件内的导航守卫（如 beforeEach、beforeEnter、beforeRouteEnter 等），可以在路由跳转前后进行权限校验、数据预处理等操作。","\n",(0,s.jsx)(e.h4,{children:"区别"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"hash 路由：利用 URL 的 #（hash）部分，监听 window 的 hashchange 事件来实现路由切换。hash 变化不会导致页面重新加载，# 后面的内容不会被服务器解析。"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.li,{children:"history 路由：利用 HTML5 的 History API（pushState、replaceState、popstate），直接改变浏览器的 URL 路径，实现无刷新路由切换，URL 更加美观。"}),"\n",(0,s.jsx)(e.li,{children:"hash 模式 ：URL 中带有 # 符号，不支持 SEO，不美观。"}),"\n",(0,s.jsx)(e.li,{children:"history 模式 ：URL 中没有 # 符号，支持 SEO，美观。\n兼容性\nhash 模式 ：IE9 及以下不支持。\nhistory 模式 ：需要服务器配置支持。"}),"\n",(0,s.jsx)(e.li,{children:"hash 路由：# 后面的内容不会被服务器处理，不需要额外配置。"}),"\n",(0,s.jsx)(e.li,{children:"history 路由：需要后端支持，所有路由都要返回 index.html，否则刷新页面会 404。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"总结 ： hash 路由实现简单、兼容性好、无需后端配合，但不利于 SEO；history 路由 URL 更美观、利于 SEO，但需要服务器支持。实际开发中根据项目需求选择合适的路由模式。"})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,l.ah)(),n.components);return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(r,{...n})}):r(n)}let d=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["notes%2Finterview%2Fdeepresume.md"]={toc:[{text:"1. 性能优化的前因后果说清楚",id:"1-性能优化的前因后果说清楚",depth:2},{text:"2. 怎么去封装一个组件",id:"2-怎么去封装一个组件",depth:2},{text:"3. 在团队怎么去践行前端工程化",id:"3-在团队怎么去践行前端工程化",depth:2},{text:"4. git rebase 和 git merge 的区别",id:"4-git-rebase-和-git-merge-的区别",depth:2},{text:"5. 在前端层面怎么保障整个系统的稳定性",id:"5-在前端层面怎么保障整个系统的稳定性",depth:2},{text:"6. 权限控制方案",id:"6-权限控制方案",depth:2},{text:"9. 对于多数据节点，模型会发生卡顿的问题，有没有做什么优化",id:"9-对于多数据节点模型会发生卡顿的问题有没有做什么优化",depth:2},{text:"11. Websocket 和 http 的区别",id:"11-websocket-和-http-的区别",depth:2},{text:"12. 垃圾回收机制",id:"12-垃圾回收机制",depth:2},{text:"13.内存泄露一般怎么排查",id:"13内存泄露一般怎么排查",depth:2},{text:"17. Vue 中组件进行通信方案",id:"17-vue-中组件进行通信方案",depth:2},{text:"18 为什么 eventBus 在 vue3 中不推荐",id:"18-为什么-eventbus-在-vue3-中不推荐",depth:2},{text:"18. hash 路由和 history 的区别",id:"18-hash-路由和-history-的区别",depth:2}],title:"简历涉及知识点准备",headingTitle:"简历涉及知识点准备",frontmatter:{}}}}]);