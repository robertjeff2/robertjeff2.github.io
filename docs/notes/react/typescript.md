# TypeScript

@types 是一个第三方库 包含对 js 代码的类型描述

- 类型描述 是对 js 代码的描述 描述的是 js 代码的结构和类型
  @types/node

## 基本类型约束

变量,函数的参数,函数的返回值限制类型
在变量后边加类型描述
ts 在很多场景可以完成类型推导
any 任意类型 推导不出来的 有三个点 用 any

### 源代码和编译结果的差异

- 类型约束 不会出现在编译结果中
  TS 类型检查 是静态的

## 基本类型

- number
- string
- 数组 要指出每一项是什么类型 number[] string[] object[] Array<number>
- object 对象约束(用的比较少)
  特殊类型 null undefined 严格模式下 不能赋值给 null 和 undefined

## 其他常用类型

联合类型|连接符
typeof 可以触发简单类型保护
void 类型 没有返回值的函数
never 类型 永远不会结束函数
字面量类型 "A" 1 2 以后只能赋值给某个字面量  
可以约束类型
元祖类型 固定长度的数组 约束每一项的类型
any 类型 绕过类型检查 可以赋值给任何类型

## 类型别名

对已知的类型进行描述

## 函数相关约束

函数重载:在函数实现之前,对函数调用的多种情况进行声明
可选参数?,不能放在首位

## 扩展类型-枚举

扩展类型:类型别名/枚举/接口/类

枚举: 约束某个变量的取值范围
枚举的类型: 数字枚举 字符串枚举
字面量和联合类型配合使用,可以达到同样的目标

字面量类型存在问题

- 不会进入到编译结果
- 值混淆的话修改所需要的成本太高

```
enum 枚举名 {
  枚举字段1: 值1,
  枚举字段2:值2
}
```

枚举会出现在编译结果中,表现为对象
枚举为字符串或者数字,数字的值会自增
数字枚举和字符串枚举有差异
最佳实践:
不要同时出现字符串和数字
使用时尽量使用枚举字段的名称不要使用真实值

位运算& | ~ ^ << >>
或| 可以用来判断是否拥有某个权限
且& 可以用来判断是否拥有某个权限
异或^ 可以用来删除权限 (相同取 0 不同取 1)

## 模块化 TS

配置模块化导出导入模块
使用的是 es6 的模块化标准

```
export const
import {} from ""
export default 导出默认值
```

## 接口

扩展类型: 类型别名 枚举 接口 类
概念:用于约束类 对象 函数的契约(标准)

不会出现在编译结果中 和类型别名一样
接口可以继承 让一个接口继承另一个接口所有成员 实现多种接口组合
在继承中不能去覆盖父接口成员的类型

```
class 类名 implements 接口名 {
}
```

类型别名实现:& 交叉类型符,可以覆盖父接口成员的类型 使用少

**readonly 只读属性**
在接口中成员之前加 readonly 可以将成员变为只读属性
在编译后会被删除 readonly arr: readonly number[] 数组不能改变

## 类型兼容性

B->A 如果能完成赋值则 B 和 A 是兼容的
鸭子辩型法 (子结构辩型法):目标类型需要某一些特征,赋值的类型只需要满足该特征即可

基本类型完全匹配

类型断言: as 关键词
直接使用字面量赋值,判定更严格

## 类

面向对象思想
类 属性赋值
在构造函数中
在类中赋值
?:可选属性
属性可以修饰为可选 / 只读
构造器中写上访问修饰符 可以正常赋值构造属性简写
访问修饰符 public/private/readonly

### 访问器

set get 用来控制属性的读取

## 泛型

在书写某个函数中会丢失一些类型信息
泛型:附属于函数类接口类型别名之上的类型 泛型可以设置默认值

使用: 在函数名之后写上`<泛型名称>`通常写<T>
在定义的时候不确定类型,在调用的时候传类型

泛型约束
在`<T extands xx>` 表示一个泛型继承了某个接口 某个类 用来限制泛型的取值
多泛型
<T,U> 返回(T | U)的结果类型 可以是 T 也可以是 U
