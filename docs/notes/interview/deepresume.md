# 简历涉及知识点准备

## 1. 性能优化的前因后果说清楚

我使用 F12 开发者工具进入 LightHouse 工具分析了网站性能指标,指标包含了性能指标（Performance）、可访问性（Accessibility）、最佳实践（Best Practices）和 SEO（Search Engine Optimization）。
FCP 时间比较场,所以这次的目的就是优化 FCP 时间。
FCP 时间是指浏览器从开始加载页面到页面内容首次开始绘制的时间。
FCP 时间越短，用户体验越好。
FCP 时间过长，会导致用户等待时间过长，影响用户体验。
使用的方式:

- 使用图片懒加载：通过使用 JavaScript 或者在 HTML 属性中设置 onload 事件，当图片加载完成时再显示，这样可以减少初始化时的性能开销
- 使用预加载：通过在页面加载时预先加载一些数据和资源，当用户访问时可以更快地渲染。
- 优化列表和数组操作：使用现代前端框架提供的列表和数组操作方法，可以减少代码量，提高性能。
- 使用 CDN：通过将静态资源部署到 CDN 服务器上，可以提高用户体验，减少网络传输时的时间开销。
- 使用事件代理：将事件监听器添加到父元素上，可以减少事件监听器的数量，提高性能。
- 优化 DOM 操作：在使用 JavaScript 操作 DOM 时，尽量减少操作的次数和复杂度，以提高性能。
- 图片压缩：通过压缩图片的大小，可以减少网络传输时的时间开销。

细说图片懒加载:
图片懒加载是一种优化技术，它的目的是在用户滚动页面时，只有当图片进入可视区域时才加载图片，从而减少页面加载时间和带宽消耗。
图片懒加载的实现方式有很多种，其中比较常用的是使用 JavaScript 和 onload 事件。
具体实现步骤如下：

1. 在 HTML 中，将图片的 src 属性设置为一个占位图，例如：

```html
<img src="loading.gif" data-src="real-image.jpg" alt="Real Image" />
```

2. 在 JavaScript 中，使用 onload 事件监听图片加载完成的事件，当图片加载完成时，将占位图的 src 属性替换为真实的图片地址，例如：

```js
var images = document.querySelectorAll('img');
for (var i = 0; i < images.length; i++) {
  images[i].onload = function () {
    this.src = this.dataset.src;
  };
}
```

## 2. 怎么去封装一个组件

首先先分析组件的功能和特点，确定组件的结构和样式。
然后根据组件的功能和特点，编写组件的代码。
最后将组件的代码封装成一个独立的模块，方便在其他项目中使用。
单一职责原则：每个组件只做一件事，便于维护和复用。
可扩展性：组件可以根据需要进行扩展和修改，便于维护和升级。
通过 props 传递数据和配置，通过事件（如 onChange 、 onSubmit ）向父组件传递变化。
支持插槽/slot（Vue）或 children（React）
通过 v-model（Vue）或 value/onChange（React）实现双向绑定。

## 3. 在团队怎么去践行前端工程化

1.开发流程统一,构建统一的代码规范代码风格
制定并推行代码规范（如 ESLint、Prettier），统一团队编码风格。
采用 Git Flow、分支管理策略，规范代码提交（如 Commitlint、Husky 钩子）。

- 推行代码评审（Code Review）制度，提升代码质量和团队协作。 2.模块化与组件化开发
  推行组件化思想，封装高复用的 UI 组件和业务组件，沉淀组件库。 3.技术文档输出与知识沉淀
  编写详细的技术文档、接口文档、开发手册，降低团队成员沟通成本。 4.团队协作与持续改进
  定期技术分享、Code Review、技术沙龙，提升团队整体技术水平。

## 4. git rebase 和 git merge 的区别

git 工作流的搭建:

1. 首先创建一个新的分支，用于开发新的功能或修复 bug。
2. 在新分支上进行开发和测试。
3. 当开发完成后，将新分支合并到主分支（通常是 master 分支）。
4. 合并过程中，需要进行代码审查和测试，确保代码质量和稳定性。
5. 合并完成后，将新分支删除，保持主分支的整洁和清晰。
6. 定期进行代码合并和部署，确保主分支的稳定性和可靠性。

git rebase 和 git merge 的区别:

- git merge ：将两个分支的最新内容合并，保留两条分支的历史，产生一个新的合并提交（merge commit），历史记录呈现分叉和合并的树状结构。
- git rebase ：将当前分支的提交“迁移”到目标分支的最新提交之后，重写提交历史，使历史记录更加线性。
  差异:
- merge 会保留分支的分叉和合并点，历史更真实，但可能更复杂。
- rebase 会让提交历史变得线性，便于查看和回溯，但会改变提交的哈希值。
  场景:
- merge 适合保留完整的分支开发历史，适合团队协作。
- rebase 适合整理提交历史，保持主干分支整洁，适合个人开发或合并前整理。
  冲突
- merge 过程中如有冲突，只需解决一次。
- rebase 过程中每次“迁移”一个提交都可能产生冲突，需要多次解决。

## 5. 在前端层面怎么保障整个系统的稳定性

1.代码规范与审核
○ code review
○ 编写代码层面的规范 2.错误处理与容错
○ 让错误可控，组件内的错误不至于导致整个页面发生崩溃

- 组件内部做好异常捕获，防止单个组件错误导致页面整体崩溃。
- 全局异常捕获（如 window.onerror、Vue.config.errorHandler、React ErrorBoundary），及时上报和处理异常。
- 关键操作增加降级和兜底方案，保证核心功能可用。 3.性能优化
- 合理使用懒加载、预加载、CDN、事件代理等手段，提升整体性能。
- 监控线上性能指标，及时发现和优化性能瓶颈。
  代码复用与模块化
  ○ 减少代码冗余，提高代码复用率，便于维护
  ○ 需求开发前编写技术文档

## 6. 权限控制方案

：基于角色 and 基于用户，优劣点分别是什么 1.基于角色

- 原理 ：为每个用户分配一个或多个角色，每个角色拥有不同的权限。前端根据用户角色决定页面展示内容、路由访问、按钮操作等。
- 优点 ：结构清晰，易于管理，适合权限体系较为稳定的系统。
- 登录后获取用户角色，前端根据角色动态生成路由和菜单。
- 组件/按钮通过指令或高阶组件判断当前用户角色是否有权限显示。 2.基于用户
- 原理 ：为每个用户单独分配权限，前端根据用户的具体权限控制页面元素的显示与操作。
- 优点 ：灵活，能满足个性化需求。
- 缺点 ：管理复杂，维护成本高，适合权限变化频繁或个性化需求强的场景。
  实现方式举例 ：
- 登录后获取用户权限列表，前端根据权限列表渲染页面和功能。
- 通过权限码（如"CAN_EDIT_USER"）控制按钮、菜单、路由等的显示。

常用技术实现

- 路由守卫（如 Vue Router、React Router 的 beforeEach/beforeEnter）
- 权限指令/高阶组件（如 v-permission、withPermission）
- 动态菜单/按钮渲染
- 权限码/权限点管理

7.  RSA 和浏览器指纹风控分别是什么
    RSA 是一种非对称加密算法（Rivest–Shamir–Adleman），在前端主要用于数据加密和安全传输。其核心思想是使用一对公钥和私钥：公钥用于加密数据，私钥用于解密数据。常见应用场景包括：

- 前端登录时对敏感信息（如密码）进行加密，防止明文传输被窃取。
- 与后端进行安全通信，防止中间人攻击和数据篡改。

fingerprintjs

- 浏览器类型和版本
- 操作系统类型和版本
- 屏幕分辨率、颜色深度
- 安装的字体、插件、语言设置
  用途：

- 主要用于风控、反作弊、用户唯一性识别等场景。
- 可以辅助判断同一用户是否多次访问、是否存在异常行为等。

8. keep-alive 的原理是什么
   用于缓存被包裹的动态组件，避免重复渲染和销毁，提高性能和用户体验。
   keep-alive 通过内部维护一个缓存对象（通常是基于 LRU 策略的 Map），以组件的唯一标识（如 name 或 key）为 key，组件的实例为 value。当组件被切换出去时，不会销毁，而是将其实例存入缓存。
   第一次渲染时正常挂载
   切换的时候会触发 deactivated 钩子函数
   再次切换回来的时候会触发 activated 钩子函数

- 在 Vue 的 patch 过程中，keep-alive 会拦截对被包裹组件的卸载操作，将其转为缓存操作，并在需要时复用缓存中的 VNode 实例。
- include/exclude 控制 通过 include/exclude 属性，keep-alive 会根据组件的 name 或 key 判断是否需要缓存，动态决定哪些组件参与缓存。
- 缓存淘汰 当缓存数量超过 max 属性时，keep-alive 会按照 LRU（最近最少使用）策略淘汰最久未使用的组件实例，释放内存。

## 9. 对于多数据节点，模型会发生卡顿的问题，有没有做什么优化

虚拟列表（Virtual List）/虚拟滚动（Virtual Scrolling） 只渲染可视区域内的数据节点，未显示的数据不渲染，极大减少 DOM 数量，提升渲染性能。常见库有 react-window、vue-virtual-scroller 等。
检测元素进入可用区域
使用 Intersection Observer API 监听元素进入和离开可视区域，只渲染进入的元素，避免大量 DOM 渲染。
使用懒加载（Lazy Loading）
对于图片、视频等资源，只在元素进入可视区域时加载，避免一次性加载大量资源。
渲染节奏用 requestAnimationFrame

- 优化滚动时的渲染节奏，避免频繁操作 DOM，提升性能

10. Websocket 的心跳机制
    WebSocket 的心跳机制是指客户端和服务端定期发送“心跳包”（通常是特殊格式的数据包，如 ping/pong 或自定义消息），以检测连接是否存活、防止中间网络设备断开长时间无数据传输的连接。
    在 onmessage 周期监听消息
    ws 失败重连机制

- 监听 onclose 和 onerror ，在断开时自动重连
- 使用定时器控制重连频率，避免频繁重连
- 可设置最大重连次数或指数退避
- 重连后恢复心跳和消息监听

## 11. Websocket 和 http 的区别

- HTTP 通信是“请求-响应”模式，客户端主动发起请求，服务端响应。
- WebSocket 支持双向通信，服务端可以主动推送消息给客户端，实时性强。

- HTTP 每次通信都需要携带完整的请求和响应头，数据包体积较大。
- WebSocket 握手后，数据帧头部很小，通信开销低，适合高频率、实时性强的场景。
- HTTP 默认端口为 80（HTTPS 为 443）。
- WebSocket 默认端口为 80（ws）和 443（wss），但协议不同。
  HTTP 适合请求-响应式的传统数据交互，WebSocket 适合需要实时、双向通信的高交互场景。

## 12. 垃圾回收机制

a. 引用计数

- 原理 ：跟踪记录每个值被引用的次数
- 优点 ：发现垃圾时立即回收
- 缺点 ：无法解决循环引用问题
  b. 标记清除
- 原理 ：从根对象开始遍历所有引用，标记活动对象，未被标记的进行清除
- 步骤 ：

1. 标记阶段：从根对象开始遍历
2. 清除阶段：清除未被标记的对象

c.分代回收（Generational Collection）

- 新生代 ：存活时间短的对象
  - 使用 Scavenge 算法
  - 空间分为 From 和 To 两部分
  - 存活对象复制到 To 空间
- 老生代 ：存活时间长的对象
  - 使用标记清除和标记整理
  - 减少碎片化
- 优点 ：能解决循环引用问题
- 缺点 ：会产生内存碎片

## 13.内存泄露一般怎么排查

- 意外的全局变量
- 未清理的定时器
- 闭包引用
- DOM 引用未清理
- 事件监听器未移除
  从这几个方面去排查, F12 开发工具中可以看到内存快照

14. 一般怎么进行技术选型呢
    ○ 社区活跃度
    ○ 同类型的技术对比
15. 实时获取怎么做的
    ws 通信
16. 状态管理库 Vuex 的原理 ,vue 和 pinia 的区别

- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式
- 采用集中式存储管理应用的所有组件的状态
- 以相应的规则保证状态以一种可预测的方式发生变化
  数据流向清晰 ：组件通过 dispatch 分发 action，action 可以包含异步操作，action 再通过 commit 提交 mutation，mutation 是唯一能修改 state 的地方，并且必须是同步的。这样保证了状态变更的可追踪和可预测。
  Getter ：类似于 Vue 的计算属性，对 state 进行二次处理，结果会被缓存。

区别

- Vuex 采用传统的模块化、mutation、action、getter 设计，API 较为繁琐。
- Pinia 更加轻量、现代，API 设计更贴近 Composition API，使用 setup 语法糖，书写更简洁。
  模块化 ：
- Vuex 需要手动注册模块，模块嵌套复杂。
- Pinia 每个 store 独立，天然模块化，按需引入，易于拆分和维护。
  数据修改方式

- Vuex 必须通过 mutation 修改 state，mutation 必须同步，action 负责异步。
- Pinia 可以直接在 action 或外部直接修改 state，无需 mutation，简化了数据流。
  总结 ：Pinia 更轻量、易用、类型友好，推荐在 Vue3 项目中优先使用；Vuex 适合老项目或对 mutation/action 传统模式有依赖的场景。

## 17. Vue 中组件进行通信方案

1. props / $emit
2. vue2 自定义事件总线（EventBus）vue3 不推荐使用

3. provide / inject
   适合祖孙组件通信，适合深层嵌套场景。
4. ref / $parent /$children
   通过 ref 获取子组件实例，或通过 $parent、$children 访问父/子组件实例。适合简单场景，不推荐频繁使用。
5. 全局状态管理
6. attrs / listeners
   通过 $attrs 和 $listeners 实现属性和事件的透传，适合多层组件嵌套时的通信。

## 18 为什么 eventBus 在 vue3 中不推荐

响应式系统升级 ：Vue3 的响应式系统基于 Proxy 实现，事件总线这种通过全局实例传递事件的方式，容易绕开响应式数据流，导致状态不可追踪、不透明，违背了 Vue3 推崇的“明确的数据流向”
类型安全与可维护性差 ：EventBus 事件名和参数没有类型约束，容易出现拼写错误、参数不一致等问题，难以维护和重构，尤其是在大型项目中。
更好的替代方案 ：Vue3 推荐使用 provide/inject、props/$emit、全局状态管理（如 Pinia）等更清晰、类型友好、易于维护的通信方式。这些方式更符合 Vue3 的设计理念和现代前端开发需求。

## 18. hash 路由和 history 的区别

    路由映射表（Route Mapping） vue-router 会根据开发者配置的 routes 数组，生成一份“路径与组件”的映射表。每当 URL 发生变化时，vue-router 会根据当前路径查找对应的组件进行渲染。

- hash 模式 ：通过监听 window 的 hashchange 事件，URL 的 # 后面的内容变化时，vue-router 会解析 hash 并匹配路由。
- history 模式 ：利用 HTML5 History API（pushState/replaceState/popstate），监听浏览器的前进、后退等操作，URL 变化时同样进行路由匹配。
  vue-router 会在
  组件处动态渲染当前匹配到的路由组件。每当路由变化时，
  会自动切换显示对应的组件。
  vue-router 提供了全局、路由独享、组件内的导航守卫（如 beforeEach、beforeEnter、beforeRouteEnter 等），可以在路由跳转前后进行权限校验、数据预处理等操作。
  #### 区别
  - hash 路由：利用 URL 的 #（hash）部分，监听 window 的 hashchange 事件来实现路由切换。hash 变化不会导致页面重新加载，# 后面的内容不会被服务器解析。
- history 路由：利用 HTML5 的 History API（pushState、replaceState、popstate），直接改变浏览器的 URL 路径，实现无刷新路由切换，URL 更加美观。
- hash 模式 ：URL 中带有 # 符号，不支持 SEO，不美观。
- history 模式 ：URL 中没有 # 符号，支持 SEO，美观。
  兼容性
  hash 模式 ：IE9 及以下不支持。
  history 模式 ：需要服务器配置支持。
- hash 路由：# 后面的内容不会被服务器处理，不需要额外配置。
- history 路由：需要后端支持，所有路由都要返回 index.html，否则刷新页面会 404。

总结 ： hash 路由实现简单、兼容性好、无需后端配合，但不利于 SEO；history 路由 URL 更美观、利于 SEO，但需要服务器支持。实际开发中根据项目需求选择合适的路由模式。
